/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Animation/Animator.swift:
    1|       |//
    2|       |//  Animator.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |import QuartzCore
   15|       |
   16|       |@objc(ChartAnimatorDelegate)
   17|       |public protocol AnimatorDelegate
   18|       |{
   19|       |    /// Called when the Animator has stepped.
   20|       |    func animatorUpdated(_ animator: Animator)
   21|       |    
   22|       |    /// Called when the Animator has stopped.
   23|       |    func animatorStopped(_ animator: Animator)
   24|       |}
   25|       |
   26|       |@objc(ChartAnimator)
   27|       |open class Animator: NSObject
   28|       |{
   29|       |    @objc open weak var delegate: AnimatorDelegate?
   30|       |    @objc open var updateBlock: (() -> Void)?
   31|       |    @objc open var stopBlock: (() -> Void)?
   32|       |    
   33|       |    /// the phase that is animated and influences the drawn values on the x-axis
   34|       |    @objc open var phaseX: Double = 1.0
   35|       |    
   36|       |    /// the phase that is animated and influences the drawn values on the y-axis
   37|       |    @objc open var phaseY: Double = 1.0
   38|       |    
   39|       |    private var _startTimeX: TimeInterval = 0.0
   40|       |    private var _startTimeY: TimeInterval = 0.0
   41|       |    private var _displayLink: NSUIDisplayLink?
   42|       |    
   43|       |    private var _durationX: TimeInterval = 0.0
   44|       |    private var _durationY: TimeInterval = 0.0
   45|       |    
   46|       |    private var _endTimeX: TimeInterval = 0.0
   47|       |    private var _endTimeY: TimeInterval = 0.0
   48|       |    private var _endTime: TimeInterval = 0.0
   49|       |    
   50|       |    private var _enabledX: Bool = false
   51|       |    private var _enabledY: Bool = false
   52|       |    
   53|       |    private var _easingX: ChartEasingFunctionBlock?
   54|       |    private var _easingY: ChartEasingFunctionBlock?
   55|       |
   56|       |    public override init()
   57|      0|    {
   58|      0|        super.init()
   59|      0|    }
   60|       |    
   61|       |    deinit
   62|      0|    {
   63|      0|        stop()
   64|      0|    }
   65|       |    
   66|       |    @objc open func stop()
   67|      0|    {
   68|      0|        guard _displayLink != nil else { return }
   69|      0|
   70|      0|        _displayLink?.remove(from: .main, forMode: RunLoop.Mode.common)
   71|      0|        _displayLink = nil
   72|      0|
   73|      0|        _enabledX = false
   74|      0|        _enabledY = false
   75|      0|
   76|      0|        // If we stopped an animation in the middle, we do not want to leave it like this
   77|      0|        if phaseX != 1.0 || phaseY != 1.0
   78|      0|        {
   79|      0|            phaseX = 1.0
   80|      0|            phaseY = 1.0
   81|      0|
   82|      0|            delegate?.animatorUpdated(self)
   83|      0|            updateBlock?()
   84|      0|        }
   85|      0|
   86|      0|        delegate?.animatorStopped(self)
   87|      0|        stopBlock?()
   88|      0|    }
   89|       |    
   90|       |    private func updateAnimationPhases(_ currentTime: TimeInterval)
   91|      0|    {
   92|      0|        if _enabledX
   93|      0|        {
   94|      0|            let elapsedTime: TimeInterval = currentTime - _startTimeX
   95|      0|            let duration: TimeInterval = _durationX
   96|      0|            var elapsed: TimeInterval = elapsedTime
   97|      0|            if elapsed > duration
   98|      0|            {
   99|      0|                elapsed = duration
  100|      0|            }
  101|      0|           
  102|      0|            phaseX = _easingX?(elapsed, duration) ?? elapsed / duration
  103|      0|        }
  104|      0|        
  105|      0|        if _enabledY
  106|      0|        {
  107|      0|            let elapsedTime: TimeInterval = currentTime - _startTimeY
  108|      0|            let duration: TimeInterval = _durationY
  109|      0|            var elapsed: TimeInterval = elapsedTime
  110|      0|            if elapsed > duration
  111|      0|            {
  112|      0|                elapsed = duration
  113|      0|            }
  114|      0|
  115|      0|            phaseY = _easingY?(elapsed, duration) ?? elapsed / duration
  116|      0|        }
  117|      0|    }
  118|       |    
  119|       |    @objc private func animationLoop()
  120|      0|    {
  121|      0|        let currentTime: TimeInterval = CACurrentMediaTime()
  122|      0|        
  123|      0|        updateAnimationPhases(currentTime)
  124|      0|
  125|      0|        delegate?.animatorUpdated(self)
  126|      0|        updateBlock?()
  127|      0|        
  128|      0|        if currentTime >= _endTime
  129|      0|        {
  130|      0|            stop()
  131|      0|        }
  132|      0|    }
  133|       |    
  134|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  135|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  136|       |    ///
  137|       |    /// - Parameters:
  138|       |    ///   - xAxisDuration: duration for animating the x axis
  139|       |    ///   - yAxisDuration: duration for animating the y axis
  140|       |    ///   - easingX: an easing function for the animation on the x axis
  141|       |    ///   - easingY: an easing function for the animation on the y axis
  142|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easingX: ChartEasingFunctionBlock?, easingY: ChartEasingFunctionBlock?)
  143|      0|    {
  144|      0|        stop()
  145|      0|        
  146|      0|        _startTimeX = CACurrentMediaTime()
  147|      0|        _startTimeY = _startTimeX
  148|      0|        _durationX = xAxisDuration
  149|      0|        _durationY = yAxisDuration
  150|      0|        _endTimeX = _startTimeX + xAxisDuration
  151|      0|        _endTimeY = _startTimeY + yAxisDuration
  152|      0|        _endTime = _endTimeX > _endTimeY ? _endTimeX : _endTimeY
  153|      0|        _enabledX = xAxisDuration > 0.0
  154|      0|        _enabledY = yAxisDuration > 0.0
  155|      0|        
  156|      0|        _easingX = easingX
  157|      0|        _easingY = easingY
  158|      0|        
  159|      0|        // Take care of the first frame if rendering is already scheduled...
  160|      0|        updateAnimationPhases(_startTimeX)
  161|      0|        
  162|      0|        if _enabledX || _enabledY
  163|      0|        {
  164|      0|            _displayLink = NSUIDisplayLink(target: self, selector: #selector(animationLoop))
  165|      0|            _displayLink?.add(to: RunLoop.main, forMode: RunLoop.Mode.common)
  166|      0|        }
  167|      0|    }
  168|       |    
  169|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  170|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  171|       |    ///
  172|       |    /// - Parameters:
  173|       |    ///   - xAxisDuration: duration for animating the x axis
  174|       |    ///   - yAxisDuration: duration for animating the y axis
  175|       |    ///   - easingOptionX: the easing function for the animation on the x axis
  176|       |    ///   - easingOptionY: the easing function for the animation on the y axis
  177|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easingOptionX: ChartEasingOption, easingOptionY: ChartEasingOption)
  178|      0|    {
  179|      0|        animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration, easingX: easingFunctionFromOption(easingOptionX), easingY: easingFunctionFromOption(easingOptionY))
  180|      0|    }
  181|       |    
  182|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  183|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  184|       |    ///
  185|       |    /// - Parameters:
  186|       |    ///   - xAxisDuration: duration for animating the x axis
  187|       |    ///   - yAxisDuration: duration for animating the y axis
  188|       |    ///   - easing: an easing function for the animation
  189|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easing: ChartEasingFunctionBlock?)
  190|      0|    {
  191|      0|        animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration, easingX: easing, easingY: easing)
  192|      0|    }
  193|       |    
  194|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  195|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  196|       |    ///
  197|       |    /// - Parameters:
  198|       |    ///   - xAxisDuration: duration for animating the x axis
  199|       |    ///   - yAxisDuration: duration for animating the y axis
  200|       |    ///   - easingOption: the easing function for the animation
  201|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easingOption: ChartEasingOption = .easeInOutSine)
  202|      0|    {
  203|      0|        animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration, easing: easingFunctionFromOption(easingOption))
  204|      0|    }
  205|       |
  206|       |    /// Animates the drawing / rendering of the chart the x-axis with the specified animation time.
  207|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  208|       |    ///
  209|       |    /// - Parameters:
  210|       |    ///   - xAxisDuration: duration for animating the x axis
  211|       |    ///   - easing: an easing function for the animation
  212|       |    @objc open func animate(xAxisDuration: TimeInterval, easing: ChartEasingFunctionBlock?)
  213|      0|    {
  214|      0|        _startTimeX = CACurrentMediaTime()
  215|      0|        _durationX = xAxisDuration
  216|      0|        _endTimeX = _startTimeX + xAxisDuration
  217|      0|        _endTime = _endTimeX > _endTimeY ? _endTimeX : _endTimeY
  218|      0|        _enabledX = xAxisDuration > 0.0
  219|      0|        
  220|      0|        _easingX = easing
  221|      0|        
  222|      0|        // Take care of the first frame if rendering is already scheduled...
  223|      0|        updateAnimationPhases(_startTimeX)
  224|      0|        
  225|      0|        if _enabledX || _enabledY,
  226|      0|            _displayLink == nil
  227|      0|        {
  228|      0|            _displayLink = NSUIDisplayLink(target: self, selector: #selector(animationLoop))
  229|      0|            _displayLink?.add(to: .main, forMode: RunLoop.Mode.common)
  230|      0|        }
  231|      0|    }
  232|       |    
  233|       |    /// Animates the drawing / rendering of the chart the x-axis with the specified animation time.
  234|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  235|       |    ///
  236|       |    /// - Parameters:
  237|       |    ///   - xAxisDuration: duration for animating the x axis
  238|       |    ///   - easingOption: the easing function for the animation
  239|       |    @objc open func animate(xAxisDuration: TimeInterval, easingOption: ChartEasingOption = .easeInOutSine)
  240|      0|    {
  241|      0|        animate(xAxisDuration: xAxisDuration, easing: easingFunctionFromOption(easingOption))
  242|      0|    }
  243|       |
  244|       |    /// Animates the drawing / rendering of the chart the y-axis with the specified animation time.
  245|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  246|       |    ///
  247|       |    /// - Parameters:
  248|       |    ///   - yAxisDuration: duration for animating the y axis
  249|       |    ///   - easing: an easing function for the animation
  250|       |    @objc open func animate(yAxisDuration: TimeInterval, easing: ChartEasingFunctionBlock?)
  251|      0|    {
  252|      0|        _startTimeY = CACurrentMediaTime()
  253|      0|        _durationY = yAxisDuration
  254|      0|        _endTimeY = _startTimeY + yAxisDuration
  255|      0|        _endTime = _endTimeX > _endTimeY ? _endTimeX : _endTimeY
  256|      0|        _enabledY = yAxisDuration > 0.0
  257|      0|        
  258|      0|        _easingY = easing
  259|      0|        
  260|      0|        // Take care of the first frame if rendering is already scheduled...
  261|      0|        updateAnimationPhases(_startTimeY)
  262|      0|        
  263|      0|        if _enabledX || _enabledY,
  264|      0|            _displayLink == nil
  265|      0|        {
  266|      0|            _displayLink = NSUIDisplayLink(target: self, selector: #selector(animationLoop))
  267|      0|            _displayLink?.add(to: .main, forMode: RunLoop.Mode.common)
  268|      0|        }
  269|      0|    }
  270|       |    
  271|       |    /// Animates the drawing / rendering of the chart the y-axis with the specified animation time.
  272|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  273|       |    ///
  274|       |    /// - Parameters:
  275|       |    ///   - yAxisDuration: duration for animating the y axis
  276|       |    ///   - easingOption: the easing function for the animation
  277|       |    @objc open func animate(yAxisDuration: TimeInterval, easingOption: ChartEasingOption = .easeInOutSine)
  278|      0|    {
  279|      0|        animate(yAxisDuration: yAxisDuration, easing: easingFunctionFromOption(easingOption))
  280|      0|    }
  281|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Animation/ChartAnimationEasing.swift:
    1|       |//
    2|       |//  ChartAnimationUtils.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc
   16|       |public enum ChartEasingOption: Int
   17|       |{
   18|       |    case linear
   19|       |    case easeInQuad
   20|       |    case easeOutQuad
   21|       |    case easeInOutQuad
   22|       |    case easeInCubic
   23|       |    case easeOutCubic
   24|       |    case easeInOutCubic
   25|       |    case easeInQuart
   26|       |    case easeOutQuart
   27|       |    case easeInOutQuart
   28|       |    case easeInQuint
   29|       |    case easeOutQuint
   30|       |    case easeInOutQuint
   31|       |    case easeInSine
   32|       |    case easeOutSine
   33|       |    case easeInOutSine
   34|       |    case easeInExpo
   35|       |    case easeOutExpo
   36|       |    case easeInOutExpo
   37|       |    case easeInCirc
   38|       |    case easeOutCirc
   39|       |    case easeInOutCirc
   40|       |    case easeInElastic
   41|       |    case easeOutElastic
   42|       |    case easeInOutElastic
   43|       |    case easeInBack
   44|       |    case easeOutBack
   45|       |    case easeInOutBack
   46|       |    case easeInBounce
   47|       |    case easeOutBounce
   48|       |    case easeInOutBounce
   49|       |}
   50|       |
   51|       |public typealias ChartEasingFunctionBlock = ((_ elapsed: TimeInterval, _ duration: TimeInterval) -> Double)
   52|       |
   53|       |internal func easingFunctionFromOption(_ easing: ChartEasingOption) -> ChartEasingFunctionBlock
   54|      0|{
   55|      0|    switch easing
   56|      0|    {
   57|      0|    case .linear:
   58|      0|        return EasingFunctions.Linear
   59|      0|    case .easeInQuad:
   60|      0|        return EasingFunctions.EaseInQuad
   61|      0|    case .easeOutQuad:
   62|      0|        return EasingFunctions.EaseOutQuad
   63|      0|    case .easeInOutQuad:
   64|      0|        return EasingFunctions.EaseInOutQuad
   65|      0|    case .easeInCubic:
   66|      0|        return EasingFunctions.EaseInCubic
   67|      0|    case .easeOutCubic:
   68|      0|        return EasingFunctions.EaseOutCubic
   69|      0|    case .easeInOutCubic:
   70|      0|        return EasingFunctions.EaseInOutCubic
   71|      0|    case .easeInQuart:
   72|      0|        return EasingFunctions.EaseInQuart
   73|      0|    case .easeOutQuart:
   74|      0|        return EasingFunctions.EaseOutQuart
   75|      0|    case .easeInOutQuart:
   76|      0|        return EasingFunctions.EaseInOutQuart
   77|      0|    case .easeInQuint:
   78|      0|        return EasingFunctions.EaseInQuint
   79|      0|    case .easeOutQuint:
   80|      0|        return EasingFunctions.EaseOutQuint
   81|      0|    case .easeInOutQuint:
   82|      0|        return EasingFunctions.EaseInOutQuint
   83|      0|    case .easeInSine:
   84|      0|        return EasingFunctions.EaseInSine
   85|      0|    case .easeOutSine:
   86|      0|        return EasingFunctions.EaseOutSine
   87|      0|    case .easeInOutSine:
   88|      0|        return EasingFunctions.EaseInOutSine
   89|      0|    case .easeInExpo:
   90|      0|        return EasingFunctions.EaseInExpo
   91|      0|    case .easeOutExpo:
   92|      0|        return EasingFunctions.EaseOutExpo
   93|      0|    case .easeInOutExpo:
   94|      0|        return EasingFunctions.EaseInOutExpo
   95|      0|    case .easeInCirc:
   96|      0|        return EasingFunctions.EaseInCirc
   97|      0|    case .easeOutCirc:
   98|      0|        return EasingFunctions.EaseOutCirc
   99|      0|    case .easeInOutCirc:
  100|      0|        return EasingFunctions.EaseInOutCirc
  101|      0|    case .easeInElastic:
  102|      0|        return EasingFunctions.EaseInElastic
  103|      0|    case .easeOutElastic:
  104|      0|        return EasingFunctions.EaseOutElastic
  105|      0|    case .easeInOutElastic:
  106|      0|        return EasingFunctions.EaseInOutElastic
  107|      0|    case .easeInBack:
  108|      0|        return EasingFunctions.EaseInBack
  109|      0|    case .easeOutBack:
  110|      0|        return EasingFunctions.EaseOutBack
  111|      0|    case .easeInOutBack:
  112|      0|        return EasingFunctions.EaseInOutBack
  113|      0|    case .easeInBounce:
  114|      0|        return EasingFunctions.EaseInBounce
  115|      0|    case .easeOutBounce:
  116|      0|        return EasingFunctions.EaseOutBounce
  117|      0|    case .easeInOutBounce:
  118|      0|        return EasingFunctions.EaseInOutBounce
  119|      0|    }
  120|      0|}
  121|       |
  122|       |internal struct EasingFunctions
  123|       |{
  124|      0|    internal static let Linear = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in return Double(elapsed / duration) }
  125|       |    
  126|      0|    internal static let EaseInQuad = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  127|      0|        var position = Double(elapsed / duration)
  128|      0|        return position * position
  129|      0|    }
  130|       |    
  131|      0|    internal static let EaseOutQuad = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  132|      0|        var position = Double(elapsed / duration)
  133|      0|        return -position * (position - 2.0)
  134|      0|    }
  135|       |    
  136|      0|    internal static let EaseInOutQuad = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  137|      0|        var position = Double(elapsed / (duration / 2.0))
  138|      0|        if position < 1.0
  139|      0|        {
  140|      0|            return 0.5 * position * position
  141|      0|        }
  142|      0|        
  143|      0|        return -0.5 * ((position - 1.0) * (position - 3.0) - 1.0)
  144|      0|    }
  145|       |    
  146|      0|    internal static let EaseInCubic = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  147|      0|        var position = Double(elapsed / duration)
  148|      0|        return position * position * position
  149|      0|    }
  150|       |    
  151|      0|    internal static let EaseOutCubic = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  152|      0|        var position = Double(elapsed / duration)
  153|      0|        position -= 1.0
  154|      0|        return (position * position * position + 1.0)
  155|      0|    }
  156|       |    
  157|      0|    internal static let EaseInOutCubic = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  158|      0|        var position = Double(elapsed / (duration / 2.0))
  159|      0|        if position < 1.0
  160|      0|        {
  161|      0|            return 0.5 * position * position * position
  162|      0|        }
  163|      0|        position -= 2.0
  164|      0|        return 0.5 * (position * position * position + 2.0)
  165|      0|    }
  166|       |    
  167|      0|    internal static let EaseInQuart = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  168|      0|        var position = Double(elapsed / duration)
  169|      0|        return position * position * position * position
  170|      0|    }
  171|       |    
  172|      0|    internal static let EaseOutQuart = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  173|      0|        var position = Double(elapsed / duration)
  174|      0|        position -= 1.0
  175|      0|        return -(position * position * position * position - 1.0)
  176|      0|    }
  177|       |    
  178|      0|    internal static let EaseInOutQuart = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  179|      0|        var position = Double(elapsed / (duration / 2.0))
  180|      0|        if position < 1.0
  181|      0|        {
  182|      0|            return 0.5 * position * position * position * position
  183|      0|        }
  184|      0|        position -= 2.0
  185|      0|        return -0.5 * (position * position * position * position - 2.0)
  186|      0|    }
  187|       |    
  188|      0|    internal static let EaseInQuint = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  189|      0|        var position = Double(elapsed / duration)
  190|      0|        return position * position * position * position * position
  191|      0|    }
  192|       |    
  193|      0|    internal static let EaseOutQuint = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  194|      0|        var position = Double(elapsed / duration)
  195|      0|        position -= 1.0
  196|      0|        return (position * position * position * position * position + 1.0)
  197|      0|    }
  198|       |    
  199|      0|    internal static let EaseInOutQuint = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  200|      0|        var position = Double(elapsed / (duration / 2.0))
  201|      0|        if position < 1.0
  202|      0|        {
  203|      0|            return 0.5 * position * position * position * position * position
  204|      0|        }
  205|      0|        else
  206|      0|        {
  207|      0|            position -= 2.0
  208|      0|            return 0.5 * (position * position * position * position * position + 2.0)
  209|      0|        }
  210|      0|    }
  211|       |    
  212|      0|    internal static let EaseInSine = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  213|      0|        var position: TimeInterval = elapsed / duration
  214|      0|        return Double( -cos(position * Double.pi / 2) + 1.0 )
  215|      0|    }
  216|       |    
  217|      0|    internal static let EaseOutSine = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  218|      0|        var position: TimeInterval = elapsed / duration
  219|      0|        return Double( sin(position * Double.pi / 2) )
  220|      0|    }
  221|       |    
  222|      0|    internal static let EaseInOutSine = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  223|      0|        var position: TimeInterval = elapsed / duration
  224|      0|        return Double( -0.5 * (cos(Double.pi * position) - 1.0) )
  225|      0|    }
  226|       |    
  227|      0|    internal static let EaseInExpo = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  228|      0|        return (elapsed == 0) ? 0.0 : Double(pow(2.0, 10.0 * (elapsed / duration - 1.0)))
  229|      0|    }
  230|       |    
  231|      0|    internal static let EaseOutExpo = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  232|      0|        return (elapsed == duration) ? 1.0 : (-Double(pow(2.0, -10.0 * elapsed / duration)) + 1.0)
  233|      0|    }
  234|       |    
  235|      0|    internal static let EaseInOutExpo = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  236|      0|        if elapsed == 0
  237|      0|        {
  238|      0|            return 0.0
  239|      0|        }
  240|      0|        if elapsed == duration
  241|      0|        {
  242|      0|            return 1.0
  243|      0|        }
  244|      0|        
  245|      0|        var position: TimeInterval = elapsed / (duration / 2.0)
  246|      0|        if position < 1.0
  247|      0|        {
  248|      0|            return Double( 0.5 * pow(2.0, 10.0 * (position - 1.0)) )
  249|      0|        }
  250|      0|        
  251|      0|        position = position - 1.0
  252|      0|        return Double( 0.5 * (-pow(2.0, -10.0 * position) + 2.0) )
  253|      0|    }
  254|       |    
  255|      0|    internal static let EaseInCirc = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  256|      0|        var position = Double(elapsed / duration)
  257|      0|        return -(Double(sqrt(1.0 - position * position)) - 1.0)
  258|      0|    }
  259|       |    
  260|      0|    internal static let EaseOutCirc = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  261|      0|        var position = Double(elapsed / duration)
  262|      0|        position -= 1.0
  263|      0|        return Double( sqrt(1 - position * position) )
  264|      0|    }
  265|       |    
  266|      0|    internal static let EaseInOutCirc = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  267|      0|        var position: TimeInterval = elapsed / (duration / 2.0)
  268|      0|        if position < 1.0
  269|      0|        {
  270|      0|            return Double( -0.5 * (sqrt(1.0 - position * position) - 1.0) )
  271|      0|        }
  272|      0|        position -= 2.0
  273|      0|        return Double( 0.5 * (sqrt(1.0 - position * position) + 1.0) )
  274|      0|    }
  275|       |    
  276|      0|    internal static let EaseInElastic = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  277|      0|        if elapsed == 0.0
  278|      0|        {
  279|      0|            return 0.0
  280|      0|        }
  281|      0|        
  282|      0|        var position: TimeInterval = elapsed / duration
  283|      0|        if position == 1.0
  284|      0|        {
  285|      0|            return 1.0
  286|      0|        }
  287|      0|        
  288|      0|        var p = duration * 0.3
  289|      0|        var s = p / (2.0 * Double.pi) * asin(1.0)
  290|      0|        position -= 1.0
  291|      0|        return Double( -(pow(2.0, 10.0 * position) * sin((position * duration - s) * (2.0 * Double.pi) / p)) )
  292|      0|    }
  293|       |    
  294|      0|    internal static let EaseOutElastic = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  295|      0|        if elapsed == 0.0
  296|      0|        {
  297|      0|            return 0.0
  298|      0|        }
  299|      0|        
  300|      0|        var position: TimeInterval = elapsed / duration
  301|      0|        if position == 1.0
  302|      0|        {
  303|      0|            return 1.0
  304|      0|        }
  305|      0|        
  306|      0|        var p = duration * 0.3
  307|      0|        var s = p / (2.0 * Double.pi) * asin(1.0)
  308|      0|        return Double( pow(2.0, -10.0 * position) * sin((position * duration - s) * (2.0 * Double.pi) / p) + 1.0 )
  309|      0|    }
  310|       |    
  311|      0|    internal static let EaseInOutElastic = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  312|      0|        if elapsed == 0.0
  313|      0|        {
  314|      0|            return 0.0
  315|      0|        }
  316|      0|        
  317|      0|        var position: TimeInterval = elapsed / (duration / 2.0)
  318|      0|        if position == 2.0
  319|      0|        {
  320|      0|            return 1.0
  321|      0|        }
  322|      0|        
  323|      0|        var p = duration * (0.3 * 1.5)
  324|      0|        var s = p / (2.0 * Double.pi) * asin(1.0)
  325|      0|        if position < 1.0
  326|      0|        {
  327|      0|            position -= 1.0
  328|      0|            return Double( -0.5 * (pow(2.0, 10.0 * position) * sin((position * duration - s) * (2.0 * Double.pi) / p)) )
  329|      0|        }
  330|      0|        position -= 1.0
  331|      0|        return Double( pow(2.0, -10.0 * position) * sin((position * duration - s) * (2.0 * Double.pi) / p) * 0.5 + 1.0 )
  332|      0|    }
  333|       |    
  334|      0|    internal static let EaseInBack = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  335|      0|        let s: TimeInterval = 1.70158
  336|      0|        var position: TimeInterval = elapsed / duration
  337|      0|        return Double( position * position * ((s + 1.0) * position - s) )
  338|      0|    }
  339|       |    
  340|      0|    internal static let EaseOutBack = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  341|      0|        let s: TimeInterval = 1.70158
  342|      0|        var position: TimeInterval = elapsed / duration
  343|      0|        position -= 1.0
  344|      0|        return Double( position * position * ((s + 1.0) * position + s) + 1.0 )
  345|      0|    }
  346|       |    
  347|      0|    internal static let EaseInOutBack = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  348|      0|        var s: TimeInterval = 1.70158
  349|      0|        var position: TimeInterval = elapsed / (duration / 2.0)
  350|      0|        if position < 1.0
  351|      0|        {
  352|      0|            s *= 1.525
  353|      0|            return Double( 0.5 * (position * position * ((s + 1.0) * position - s)) )
  354|      0|        }
  355|      0|        s *= 1.525
  356|      0|        position -= 2.0
  357|      0|        return Double( 0.5 * (position * position * ((s + 1.0) * position + s) + 2.0) )
  358|      0|    }
  359|       |    
  360|      0|    internal static let EaseInBounce = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  361|      0|        return 1.0 - EaseOutBounce(duration - elapsed, duration)
  362|      0|    }
  363|       |    
  364|      0|    internal static let EaseOutBounce = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  365|      0|        var position: TimeInterval = elapsed / duration
  366|      0|        if position < (1.0 / 2.75)
  367|      0|        {
  368|      0|            return Double( 7.5625 * position * position )
  369|      0|        }
  370|      0|        else if position < (2.0 / 2.75)
  371|      0|        {
  372|      0|            position -= (1.5 / 2.75)
  373|      0|            return Double( 7.5625 * position * position + 0.75 )
  374|      0|        }
  375|      0|        else if position < (2.5 / 2.75)
  376|      0|        {
  377|      0|            position -= (2.25 / 2.75)
  378|      0|            return Double( 7.5625 * position * position + 0.9375 )
  379|      0|        }
  380|      0|        else
  381|      0|        {
  382|      0|            position -= (2.625 / 2.75)
  383|      0|            return Double( 7.5625 * position * position + 0.984375 )
  384|      0|        }
  385|      0|    }
  386|       |    
  387|      0|    internal static let EaseInOutBounce = { (elapsed: TimeInterval, duration: TimeInterval) -> Double in
  388|      0|        if elapsed < (duration / 2.0)
  389|      0|        {
  390|      0|            return EaseInBounce(elapsed * 2.0, duration) * 0.5
  391|      0|        }
  392|      0|        return EaseOutBounce(elapsed * 2.0 - duration, duration) * 0.5 + 0.5
  393|      0|    }
  394|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/BarChartView.swift:
    1|       |//
    2|       |//  BarChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// Chart that draws bars.
   16|       |open class BarChartView: BarLineChartViewBase, BarChartDataProvider
   17|       |{
   18|       |    /// if set to true, all values are drawn above their bars, instead of below their top
   19|       |    private var _drawValueAboveBarEnabled = true
   20|       |
   21|       |    /// if set to true, a grey area is drawn behind each bar that indicates the maximum value
   22|       |    private var _drawBarShadowEnabled = false
   23|       |    
   24|       |    internal override func initialize()
   25|      0|    {
   26|      0|        super.initialize()
   27|      0|        
   28|      0|        renderer = BarChartRenderer(dataProvider: self, animator: _animator, viewPortHandler: _viewPortHandler)
   29|      0|        
   30|      0|        self.highlighter = BarHighlighter(chart: self)
   31|      0|        
   32|      0|        self.xAxis.spaceMin = 0.5
   33|      0|        self.xAxis.spaceMax = 0.5
   34|      0|    }
   35|       |    
   36|       |    internal override func calcMinMax()
   37|      0|    {
   38|      0|        guard let data = self.data as? BarChartData
   39|      0|            else { return }
   40|      0|        
   41|      0|        if fitBars
   42|      0|        {
   43|      0|            _xAxis.calculate(
   44|      0|                min: data.xMin - data.barWidth / 2.0,
   45|      0|                max: data.xMax + data.barWidth / 2.0)
   46|      0|        }
   47|      0|        else
   48|      0|        {
   49|      0|            _xAxis.calculate(min: data.xMin, max: data.xMax)
   50|      0|        }
   51|      0|        
   52|      0|        // calculate axis range (min / max) according to provided data
   53|      0|        leftAxis.calculate(
   54|      0|            min: data.getYMin(axis: .left),
   55|      0|            max: data.getYMax(axis: .left))
   56|      0|        rightAxis.calculate(
   57|      0|            min: data.getYMin(axis: .right),
   58|      0|            max: data.getYMax(axis: .right))
   59|      0|    }
   60|       |    
   61|       |    /// - Returns: The Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
   62|       |    open override func getHighlightByTouchPoint(_ pt: CGPoint) -> Highlight?
   63|      0|    {
   64|      0|        if _data === nil
   65|      0|        {
   66|      0|            Swift.print("Can't select by touch. No data set.")
   67|      0|            return nil
   68|      0|        }
   69|      0|        
   70|      0|        guard let h = self.highlighter?.getHighlight(x: pt.x, y: pt.y)
   71|      0|            else { return nil }
   72|      0|        
   73|      0|        if !isHighlightFullBarEnabled { return h }
   74|      0|        
   75|      0|        // For isHighlightFullBarEnabled, remove stackIndex
   76|      0|        return Highlight(
   77|      0|            x: h.x, y: h.y,
   78|      0|            xPx: h.xPx, yPx: h.yPx,
   79|      0|            dataIndex: h.dataIndex,
   80|      0|            dataSetIndex: h.dataSetIndex,
   81|      0|            stackIndex: -1,
   82|      0|            axis: h.axis)
   83|      0|    }
   84|       |        
   85|       |    /// - Returns: The bounding box of the specified Entry in the specified DataSet. Returns null if the Entry could not be found in the charts data.
   86|       |    @objc open func getBarBounds(entry e: BarChartDataEntry) -> CGRect
   87|      0|    {
   88|      0|        guard let
   89|      0|            data = _data as? BarChartData,
   90|      0|            let set = data.getDataSetForEntry(e) as? IBarChartDataSet
   91|      0|            else { return CGRect.null }
   92|      0|        
   93|      0|        let y = e.y
   94|      0|        let x = e.x
   95|      0|        
   96|      0|        let barWidth = data.barWidth
   97|      0|        
   98|      0|        let left = x - barWidth / 2.0
   99|      0|        let right = x + barWidth / 2.0
  100|      0|        let top = y >= 0.0 ? y : 0.0
  101|      0|        let bottom = y <= 0.0 ? y : 0.0
  102|      0|        
  103|      0|        var bounds = CGRect(x: left, y: top, width: right - left, height: bottom - top)
  104|      0|        
  105|      0|        getTransformer(forAxis: set.axisDependency).rectValueToPixel(&bounds)
  106|      0|        
  107|      0|        return bounds
  108|      0|    }
  109|       |    
  110|       |    /// Groups all BarDataSet objects this data object holds together by modifying the x-value of their entries.
  111|       |    /// Previously set x-values of entries will be overwritten. Leaves space between bars and groups as specified by the parameters.
  112|       |    /// Calls `notifyDataSetChanged()` afterwards.
  113|       |    ///
  114|       |    /// - Parameters:
  115|       |    ///   - fromX: the starting point on the x-axis where the grouping should begin
  116|       |    ///   - groupSpace: the space between groups of bars in values (not pixels) e.g. 0.8f for bar width 1f
  117|       |    ///   - barSpace: the space between individual bars in values (not pixels) e.g. 0.1f for bar width 1f
  118|       |    @objc open func groupBars(fromX: Double, groupSpace: Double, barSpace: Double)
  119|      0|    {
  120|      0|        guard let barData = self.barData
  121|      0|            else
  122|      0|        {
  123|      0|            Swift.print("You need to set data for the chart before grouping bars.", terminator: "\n")
  124|      0|            return
  125|      0|        }
  126|      0|        
  127|      0|        barData.groupBars(fromX: fromX, groupSpace: groupSpace, barSpace: barSpace)
  128|      0|        notifyDataSetChanged()
  129|      0|    }
  130|       |    
  131|       |    /// Highlights the value at the given x-value in the given DataSet. Provide -1 as the dataSetIndex to undo all highlighting.
  132|       |    ///
  133|       |    /// - Parameters:
  134|       |    ///   - x:
  135|       |    ///   - dataSetIndex:
  136|       |    ///   - stackIndex: the index inside the stack - only relevant for stacked entries
  137|       |    @objc open func highlightValue(x: Double, dataSetIndex: Int, stackIndex: Int)
  138|      0|    {
  139|      0|        highlightValue(Highlight(x: x, dataSetIndex: dataSetIndex, stackIndex: stackIndex))
  140|      0|    }
  141|       |
  142|       |    // MARK: Accessors
  143|       |    
  144|       |    /// if set to true, all values are drawn above their bars, instead of below their top
  145|       |    @objc open var drawValueAboveBarEnabled: Bool
  146|       |    {
  147|      0|        get { return _drawValueAboveBarEnabled }
  148|       |        set
  149|      0|        {
  150|      0|            _drawValueAboveBarEnabled = newValue
  151|      0|            setNeedsDisplay()
  152|      0|        }
  153|       |    }
  154|       |    
  155|       |    /// if set to true, a grey area is drawn behind each bar that indicates the maximum value
  156|       |    @objc open var drawBarShadowEnabled: Bool
  157|       |    {
  158|      0|        get { return _drawBarShadowEnabled }
  159|       |        set
  160|      0|        {
  161|      0|            _drawBarShadowEnabled = newValue
  162|      0|            setNeedsDisplay()
  163|      0|        }
  164|       |    }
  165|       |    
  166|       |    /// Adds half of the bar width to each side of the x-axis range in order to allow the bars of the barchart to be fully displayed.
  167|       |    /// **default**: false
  168|       |    @objc open var fitBars = false
  169|       |    
  170|       |    /// Set this to `true` to make the highlight operation full-bar oriented, `false` to make it highlight single values (relevant only for stacked).
  171|       |    /// If enabled, highlighting operations will highlight the whole bar, even if only a single stack entry was tapped.
  172|       |    @objc open var highlightFullBarEnabled: Bool = false
  173|       |    
  174|       |    /// `true` the highlight is be full-bar oriented, `false` ifsingle-value
  175|      0|    open var isHighlightFullBarEnabled: Bool { return highlightFullBarEnabled }
  176|       |    
  177|       |    // MARK: - BarChartDataProvider
  178|       |    
  179|      0|    open var barData: BarChartData? { return _data as? BarChartData }
  180|       |    
  181|       |    /// `true` if drawing values above bars is enabled, `false` ifnot
  182|      0|    open var isDrawValueAboveBarEnabled: Bool { return drawValueAboveBarEnabled }
  183|       |    
  184|       |    /// `true` if drawing shadows (maxvalue) for each bar is enabled, `false` ifnot
  185|      0|    open var isDrawBarShadowEnabled: Bool { return drawBarShadowEnabled }
  186|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/BarLineChartViewBase.swift:
    1|       |//
    2|       |//  BarLineChartViewBase.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |/// Base-class of LineChart, BarChart, ScatterChart and CandleStickChart.
   24|       |open class BarLineChartViewBase: ChartViewBase, BarLineScatterCandleBubbleChartDataProvider, NSUIGestureRecognizerDelegate
   25|       |{
   26|       |    /// the maximum number of entries to which values will be drawn
   27|       |    /// (entry numbers greater than this value will cause value-labels to disappear)
   28|       |    internal var _maxVisibleCount = 100
   29|       |    
   30|       |    /// flag that indicates if auto scaling on the y axis is enabled
   31|       |    private var _autoScaleMinMaxEnabled = false
   32|       |    
   33|       |    private var _pinchZoomEnabled = false
   34|       |    private var _doubleTapToZoomEnabled = true
   35|       |    private var _dragXEnabled = true
   36|       |    private var _dragYEnabled = true
   37|       |    
   38|       |    private var _scaleXEnabled = true
   39|       |    private var _scaleYEnabled = true
   40|       |    
   41|       |    /// the color for the background of the chart-drawing area (everything behind the grid lines).
   42|      0|    @objc open var gridBackgroundColor = NSUIColor(red: 240/255.0, green: 240/255.0, blue: 240/255.0, alpha: 1.0)
   43|       |    
   44|      0|    @objc open var borderColor = NSUIColor.black
   45|       |    @objc open var borderLineWidth: CGFloat = 1.0
   46|       |    
   47|       |    /// flag indicating if the grid background should be drawn or not
   48|       |    @objc open var drawGridBackgroundEnabled = false
   49|       |    
   50|       |    /// When enabled, the borders rectangle will be rendered.
   51|       |    /// If this is enabled, there is no point drawing the axis-lines of x- and y-axis.
   52|       |    @objc open var drawBordersEnabled = false
   53|       |    
   54|       |    /// When enabled, the values will be clipped to contentRect, otherwise they can bleed outside the content rect.
   55|       |    @objc open var clipValuesToContentEnabled: Bool = false
   56|       |
   57|       |    /// When disabled, the data and/or highlights will not be clipped to contentRect. Disabling this option can
   58|       |    /// be useful, when the data lies fully within the content rect, but is drawn in such a way (such as thick lines)
   59|       |    /// that there is unwanted clipping.
   60|       |    @objc open var clipDataToContentEnabled: Bool = true
   61|       |
   62|       |    /// Sets the minimum offset (padding) around the chart, defaults to 10
   63|      0|    @objc open var minOffset = CGFloat(10.0)
   64|       |    
   65|       |    /// Sets whether the chart should keep its position (zoom / scroll) after a rotation (orientation change)
   66|       |    /// **default**: false
   67|       |    @objc open var keepPositionOnRotation: Bool = false
   68|       |    
   69|       |    /// The left y-axis object. In the horizontal bar-chart, this is the
   70|       |    /// top axis.
   71|      0|    @objc open internal(set) var leftAxis = YAxis(position: .left)
   72|       |    
   73|       |    /// The right y-axis object. In the horizontal bar-chart, this is the
   74|       |    /// bottom axis.
   75|      0|    @objc open internal(set) var rightAxis = YAxis(position: .right)
   76|       |
   77|       |    /// The left Y axis renderer. This is a read-write property so you can set your own custom renderer here.
   78|       |    /// **default**: An instance of YAxisRenderer
   79|       |    @objc open lazy var leftYAxisRenderer = YAxisRenderer(viewPortHandler: _viewPortHandler, yAxis: leftAxis, transformer: _leftAxisTransformer)
   80|       |
   81|       |    /// The right Y axis renderer. This is a read-write property so you can set your own custom renderer here.
   82|       |    /// **default**: An instance of YAxisRenderer
   83|       |    @objc open lazy var rightYAxisRenderer = YAxisRenderer(viewPortHandler: _viewPortHandler, yAxis: rightAxis, transformer: _rightAxisTransformer)
   84|       |    
   85|       |    internal var _leftAxisTransformer: Transformer!
   86|       |    internal var _rightAxisTransformer: Transformer!
   87|       |    
   88|       |    /// The X axis renderer. This is a read-write property so you can set your own custom renderer here.
   89|       |    /// **default**: An instance of XAxisRenderer
   90|       |    @objc open lazy var xAxisRenderer = XAxisRenderer(viewPortHandler: _viewPortHandler, xAxis: _xAxis, transformer: _leftAxisTransformer)
   91|       |    
   92|       |    internal var _tapGestureRecognizer: NSUITapGestureRecognizer!
   93|       |    internal var _doubleTapGestureRecognizer: NSUITapGestureRecognizer!
   94|       |    #if !os(tvOS)
   95|       |    internal var _pinchGestureRecognizer: NSUIPinchGestureRecognizer!
   96|       |    #endif
   97|       |    internal var _panGestureRecognizer: NSUIPanGestureRecognizer!
   98|       |    
   99|       |    /// flag that indicates if a custom viewport offset has been set
  100|       |    private var _customViewPortEnabled = false
  101|       |    
  102|       |    public override init(frame: CGRect)
  103|      0|    {
  104|      0|        super.init(frame: frame)
  105|      0|    }
  106|       |    
  107|       |    public required init?(coder aDecoder: NSCoder)
  108|      0|    {
  109|      0|        super.init(coder: aDecoder)
  110|      0|    }
  111|       |    
  112|       |    deinit
  113|      0|    {
  114|      0|        stopDeceleration()
  115|      0|    }
  116|       |    
  117|       |    internal override func initialize()
  118|      0|    {
  119|      0|        super.initialize()
  120|      0|
  121|      0|        _leftAxisTransformer = Transformer(viewPortHandler: _viewPortHandler)
  122|      0|        _rightAxisTransformer = Transformer(viewPortHandler: _viewPortHandler)
  123|      0|        
  124|      0|        self.highlighter = ChartHighlighter(chart: self)
  125|      0|        
  126|      0|        _tapGestureRecognizer = NSUITapGestureRecognizer(target: self, action: #selector(tapGestureRecognized(_:)))
  127|      0|        _doubleTapGestureRecognizer = NSUITapGestureRecognizer(target: self, action: #selector(doubleTapGestureRecognized(_:)))
  128|      0|        _doubleTapGestureRecognizer.nsuiNumberOfTapsRequired = 2
  129|      0|        _panGestureRecognizer = NSUIPanGestureRecognizer(target: self, action: #selector(panGestureRecognized(_:)))
  130|      0|        
  131|      0|        _panGestureRecognizer.delegate = self
  132|      0|        
  133|      0|        self.addGestureRecognizer(_tapGestureRecognizer)
  134|      0|        self.addGestureRecognizer(_doubleTapGestureRecognizer)
  135|      0|        self.addGestureRecognizer(_panGestureRecognizer)
  136|      0|        
  137|      0|        _doubleTapGestureRecognizer.isEnabled = _doubleTapToZoomEnabled
  138|      0|        _panGestureRecognizer.isEnabled = _dragXEnabled || _dragYEnabled
  139|      0|
  140|      0|        #if !os(tvOS)
  141|      0|        _pinchGestureRecognizer = NSUIPinchGestureRecognizer(target: self, action: #selector(BarLineChartViewBase.pinchGestureRecognized(_:)))
  142|      0|        _pinchGestureRecognizer.delegate = self
  143|      0|        self.addGestureRecognizer(_pinchGestureRecognizer)
  144|      0|        _pinchGestureRecognizer.isEnabled = _pinchZoomEnabled || _scaleXEnabled || _scaleYEnabled
  145|      0|        #endif
  146|      0|    }
  147|       |    
  148|       |    open override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)
  149|      0|    {
  150|      0|        // Saving current position of chart.
  151|      0|        var oldPoint: CGPoint?
  152|      0|        if (keepPositionOnRotation && (keyPath == "frame" || keyPath == "bounds"))
  153|      0|        {
  154|      0|            oldPoint = viewPortHandler.contentRect.origin
  155|      0|            getTransformer(forAxis: .left).pixelToValues(&oldPoint!)
  156|      0|        }
  157|      0|        
  158|      0|        // Superclass transforms chart.
  159|      0|        super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
  160|      0|        
  161|      0|        // Restoring old position of chart
  162|      0|        if var newPoint = oldPoint , keepPositionOnRotation
  163|      0|        {
  164|      0|            getTransformer(forAxis: .left).pointValueToPixel(&newPoint)
  165|      0|            viewPortHandler.centerViewPort(pt: newPoint, chart: self)
  166|      0|        }
  167|      0|        else
  168|      0|        {
  169|      0|            viewPortHandler.refresh(newMatrix: viewPortHandler.touchMatrix, chart: self, invalidate: true)
  170|      0|        }
  171|      0|    }
  172|       |    
  173|       |    open override func draw(_ rect: CGRect)
  174|      0|    {
  175|      0|        super.draw(rect)
  176|      0|
  177|      0|        guard data != nil, let renderer = renderer else { return }
  178|      0|        
  179|      0|        let optionalContext = NSUIGraphicsGetCurrentContext()
  180|      0|        guard let context = optionalContext else { return }
  181|      0|
  182|      0|        // execute all drawing commands
  183|      0|        drawGridBackground(context: context)
  184|      0|        
  185|      0|
  186|      0|        if _autoScaleMinMaxEnabled
  187|      0|        {
  188|      0|            autoScale()
  189|      0|        }
  190|      0|
  191|      0|        if leftAxis.isEnabled
  192|      0|        {
  193|      0|            leftYAxisRenderer.computeAxis(min: leftAxis._axisMinimum, max: leftAxis._axisMaximum, inverted: leftAxis.isInverted)
  194|      0|        }
  195|      0|        
  196|      0|        if rightAxis.isEnabled
  197|      0|        {
  198|      0|            rightYAxisRenderer.computeAxis(min: rightAxis._axisMinimum, max: rightAxis._axisMaximum, inverted: rightAxis.isInverted)
  199|      0|        }
  200|      0|        
  201|      0|        if _xAxis.isEnabled
  202|      0|        {
  203|      0|            xAxisRenderer.computeAxis(min: _xAxis._axisMinimum, max: _xAxis._axisMaximum, inverted: false)
  204|      0|        }
  205|      0|        
  206|      0|        xAxisRenderer.renderAxisLine(context: context)
  207|      0|        leftYAxisRenderer.renderAxisLine(context: context)
  208|      0|        rightYAxisRenderer.renderAxisLine(context: context)
  209|      0|
  210|      0|        // The renderers are responsible for clipping, to account for line-width center etc.
  211|      0|        if xAxis.drawGridLinesBehindDataEnabled
  212|      0|        {
  213|      0|            xAxisRenderer.renderGridLines(context: context)
  214|      0|            leftYAxisRenderer.renderGridLines(context: context)
  215|      0|            rightYAxisRenderer.renderGridLines(context: context)
  216|      0|        }
  217|      0|        
  218|      0|        if _xAxis.isEnabled && _xAxis.isDrawLimitLinesBehindDataEnabled
  219|      0|        {
  220|      0|            xAxisRenderer.renderLimitLines(context: context)
  221|      0|        }
  222|      0|        
  223|      0|        if leftAxis.isEnabled && leftAxis.isDrawLimitLinesBehindDataEnabled
  224|      0|        {
  225|      0|            leftYAxisRenderer.renderLimitLines(context: context)
  226|      0|        }
  227|      0|        
  228|      0|        if rightAxis.isEnabled && rightAxis.isDrawLimitLinesBehindDataEnabled
  229|      0|        {
  230|      0|            rightYAxisRenderer.renderLimitLines(context: context)
  231|      0|        }
  232|      0|        
  233|      0|        context.saveGState()
  234|      0|        // make sure the data cannot be drawn outside the content-rect
  235|      0|        if clipDataToContentEnabled {
  236|      0|            context.clip(to: _viewPortHandler.contentRect)
  237|      0|        }
  238|      0|        renderer.drawData(context: context)
  239|      0|        
  240|      0|        // The renderers are responsible for clipping, to account for line-width center etc.
  241|      0|        if !xAxis.drawGridLinesBehindDataEnabled
  242|      0|        {
  243|      0|            xAxisRenderer.renderGridLines(context: context)
  244|      0|            leftYAxisRenderer.renderGridLines(context: context)
  245|      0|            rightYAxisRenderer.renderGridLines(context: context)
  246|      0|        }
  247|      0|        
  248|      0|        // if highlighting is enabled
  249|      0|        if (valuesToHighlight())
  250|      0|        {
  251|      0|            renderer.drawHighlighted(context: context, indices: _indicesToHighlight)
  252|      0|        }
  253|      0|        
  254|      0|        context.restoreGState()
  255|      0|        
  256|      0|        renderer.drawExtras(context: context)
  257|      0|        
  258|      0|        if _xAxis.isEnabled && !_xAxis.isDrawLimitLinesBehindDataEnabled
  259|      0|        {
  260|      0|            xAxisRenderer.renderLimitLines(context: context)
  261|      0|        }
  262|      0|        
  263|      0|        if leftAxis.isEnabled && !leftAxis.isDrawLimitLinesBehindDataEnabled
  264|      0|        {
  265|      0|            leftYAxisRenderer.renderLimitLines(context: context)
  266|      0|        }
  267|      0|        
  268|      0|        if rightAxis.isEnabled && !rightAxis.isDrawLimitLinesBehindDataEnabled
  269|      0|        {
  270|      0|            rightYAxisRenderer.renderLimitLines(context: context)
  271|      0|        }
  272|      0|        
  273|      0|        xAxisRenderer.renderAxisLabels(context: context)
  274|      0|        leftYAxisRenderer.renderAxisLabels(context: context)
  275|      0|        rightYAxisRenderer.renderAxisLabels(context: context)
  276|      0|
  277|      0|        if clipValuesToContentEnabled
  278|      0|        {
  279|      0|            context.saveGState()
  280|      0|            context.clip(to: _viewPortHandler.contentRect)
  281|      0|            
  282|      0|            renderer.drawValues(context: context)
  283|      0|            
  284|      0|            context.restoreGState()
  285|      0|        }
  286|      0|        else
  287|      0|        {
  288|      0|            renderer.drawValues(context: context)
  289|      0|        }
  290|      0|
  291|      0|        _legendRenderer.renderLegend(context: context)
  292|      0|
  293|      0|        drawDescription(context: context)
  294|      0|        
  295|      0|        drawMarkers(context: context)
  296|      0|    }
  297|       |    
  298|       |    private var _autoScaleLastLowestVisibleX: Double?
  299|       |    private var _autoScaleLastHighestVisibleX: Double?
  300|       |    
  301|       |    /// Performs auto scaling of the axis by recalculating the minimum and maximum y-values based on the entries currently in view.
  302|       |    internal func autoScale()
  303|      0|    {
  304|      0|        guard let data = _data
  305|      0|            else { return }
  306|      0|        
  307|      0|        data.calcMinMaxY(fromX: self.lowestVisibleX, toX: self.highestVisibleX)
  308|      0|        
  309|      0|        _xAxis.calculate(min: data.xMin, max: data.xMax)
  310|      0|        
  311|      0|        // calculate axis range (min / max) according to provided data
  312|      0|        
  313|      0|        if leftAxis.isEnabled
  314|      0|        {
  315|      0|            leftAxis.calculate(min: data.getYMin(axis: .left), max: data.getYMax(axis: .left))
  316|      0|        }
  317|      0|        
  318|      0|        if rightAxis.isEnabled
  319|      0|        {
  320|      0|            rightAxis.calculate(min: data.getYMin(axis: .right), max: data.getYMax(axis: .right))
  321|      0|        }
  322|      0|        
  323|      0|        calculateOffsets()
  324|      0|    }
  325|       |    
  326|       |    internal func prepareValuePxMatrix()
  327|      0|    {
  328|      0|        _rightAxisTransformer.prepareMatrixValuePx(chartXMin: _xAxis._axisMinimum, deltaX: CGFloat(xAxis.axisRange), deltaY: CGFloat(rightAxis.axisRange), chartYMin: rightAxis._axisMinimum)
  329|      0|        _leftAxisTransformer.prepareMatrixValuePx(chartXMin: xAxis._axisMinimum, deltaX: CGFloat(xAxis.axisRange), deltaY: CGFloat(leftAxis.axisRange), chartYMin: leftAxis._axisMinimum)
  330|      0|    }
  331|       |    
  332|       |    internal func prepareOffsetMatrix()
  333|      0|    {
  334|      0|        _rightAxisTransformer.prepareMatrixOffset(inverted: rightAxis.isInverted)
  335|      0|        _leftAxisTransformer.prepareMatrixOffset(inverted: leftAxis.isInverted)
  336|      0|    }
  337|       |    
  338|       |    open override func notifyDataSetChanged()
  339|      0|    {
  340|      0|        renderer?.initBuffers()
  341|      0|        
  342|      0|        calcMinMax()
  343|      0|        
  344|      0|        leftYAxisRenderer.computeAxis(min: leftAxis._axisMinimum, max: leftAxis._axisMaximum, inverted: leftAxis.isInverted)
  345|      0|        rightYAxisRenderer.computeAxis(min: rightAxis._axisMinimum, max: rightAxis._axisMaximum, inverted: rightAxis.isInverted)
  346|      0|        
  347|      0|        if let data = _data
  348|      0|        {
  349|      0|            xAxisRenderer.computeAxis(
  350|      0|                min: _xAxis._axisMinimum,
  351|      0|                max: _xAxis._axisMaximum,
  352|      0|                inverted: false)
  353|      0|
  354|      0|            if _legend !== nil
  355|      0|            {
  356|      0|                legendRenderer?.computeLegend(data: data)
  357|      0|            }
  358|      0|        }
  359|      0|        
  360|      0|        calculateOffsets()
  361|      0|        
  362|      0|        setNeedsDisplay()
  363|      0|    }
  364|       |    
  365|       |    internal override func calcMinMax()
  366|      0|    {
  367|      0|        // calculate / set x-axis range
  368|      0|        _xAxis.calculate(min: _data?.xMin ?? 0.0, max: _data?.xMax ?? 0.0)
  369|      0|        
  370|      0|        // calculate axis range (min / max) according to provided data
  371|      0|        leftAxis.calculate(min: _data?.getYMin(axis: .left) ?? 0.0, max: _data?.getYMax(axis: .left) ?? 0.0)
  372|      0|        rightAxis.calculate(min: _data?.getYMin(axis: .right) ?? 0.0, max: _data?.getYMax(axis: .right) ?? 0.0)
  373|      0|    }
  374|       |    
  375|       |    internal func calculateLegendOffsets(offsetLeft: inout CGFloat, offsetTop: inout CGFloat, offsetRight: inout CGFloat, offsetBottom: inout CGFloat)
  376|      0|    {
  377|      0|        // setup offsets for legend
  378|      0|        if _legend !== nil && _legend.isEnabled && !_legend.drawInside
  379|      0|        {
  380|      0|            switch _legend.orientation
  381|      0|            {
  382|      0|            case .vertical:
  383|      0|                
  384|      0|                switch _legend.horizontalAlignment
  385|      0|                {
  386|      0|                case .left:
  387|      0|                    offsetLeft += min(_legend.neededWidth, _viewPortHandler.chartWidth * _legend.maxSizePercent) + _legend.xOffset
  388|      0|                    
  389|      0|                case .right:
  390|      0|                    offsetRight += min(_legend.neededWidth, _viewPortHandler.chartWidth * _legend.maxSizePercent) + _legend.xOffset
  391|      0|                    
  392|      0|                case .center:
  393|      0|                    
  394|      0|                    switch _legend.verticalAlignment
  395|      0|                    {
  396|      0|                    case .top:
  397|      0|                        offsetTop += min(_legend.neededHeight, _viewPortHandler.chartHeight * _legend.maxSizePercent) + _legend.yOffset
  398|      0|                        
  399|      0|                    case .bottom:
  400|      0|                        offsetBottom += min(_legend.neededHeight, _viewPortHandler.chartHeight * _legend.maxSizePercent) + _legend.yOffset
  401|      0|                        
  402|      0|                    default:
  403|      0|                        break
  404|      0|                    }
  405|      0|                }
  406|      0|                
  407|      0|            case .horizontal:
  408|      0|                
  409|      0|                switch _legend.verticalAlignment
  410|      0|                {
  411|      0|                case .top:
  412|      0|                    offsetTop += min(_legend.neededHeight, _viewPortHandler.chartHeight * _legend.maxSizePercent) + _legend.yOffset
  413|      0|                    
  414|      0|                case .bottom:
  415|      0|                    offsetBottom += min(_legend.neededHeight, _viewPortHandler.chartHeight * _legend.maxSizePercent) + _legend.yOffset
  416|      0|                    
  417|      0|                default:
  418|      0|                    break
  419|      0|                }
  420|      0|            }
  421|      0|        }
  422|      0|    }
  423|       |    
  424|       |    internal override func calculateOffsets()
  425|      0|    {
  426|      0|        if !_customViewPortEnabled
  427|      0|        {
  428|      0|            var offsetLeft = CGFloat(0.0)
  429|      0|            var offsetRight = CGFloat(0.0)
  430|      0|            var offsetTop = CGFloat(0.0)
  431|      0|            var offsetBottom = CGFloat(0.0)
  432|      0|            
  433|      0|            calculateLegendOffsets(offsetLeft: &offsetLeft,
  434|      0|                                   offsetTop: &offsetTop,
  435|      0|                                   offsetRight: &offsetRight,
  436|      0|                                   offsetBottom: &offsetBottom)
  437|      0|            
  438|      0|            // offsets for y-labels
  439|      0|            if leftAxis.needsOffset
  440|      0|            {
  441|      0|                offsetLeft += leftAxis.requiredSize().width
  442|      0|            }
  443|      0|            
  444|      0|            if rightAxis.needsOffset
  445|      0|            {
  446|      0|                offsetRight += rightAxis.requiredSize().width
  447|      0|            }
  448|      0|
  449|      0|            if xAxis.isEnabled && xAxis.isDrawLabelsEnabled
  450|      0|            {
  451|      0|                let xlabelheight = xAxis.labelRotatedHeight + xAxis.yOffset
  452|      0|                
  453|      0|                // offsets for x-labels
  454|      0|                if xAxis.labelPosition == .bottom
  455|      0|                {
  456|      0|                    offsetBottom += xlabelheight
  457|      0|                }
  458|      0|                else if xAxis.labelPosition == .top
  459|      0|                {
  460|      0|                    offsetTop += xlabelheight
  461|      0|                }
  462|      0|                else if xAxis.labelPosition == .bothSided
  463|      0|                {
  464|      0|                    offsetBottom += xlabelheight
  465|      0|                    offsetTop += xlabelheight
  466|      0|                }
  467|      0|            }
  468|      0|            
  469|      0|            offsetTop += self.extraTopOffset
  470|      0|            offsetRight += self.extraRightOffset
  471|      0|            offsetBottom += self.extraBottomOffset
  472|      0|            offsetLeft += self.extraLeftOffset
  473|      0|
  474|      0|            _viewPortHandler.restrainViewPort(
  475|      0|                offsetLeft: max(self.minOffset, offsetLeft),
  476|      0|                offsetTop: max(self.minOffset, offsetTop),
  477|      0|                offsetRight: max(self.minOffset, offsetRight),
  478|      0|                offsetBottom: max(self.minOffset, offsetBottom))
  479|      0|        }
  480|      0|        
  481|      0|        prepareOffsetMatrix()
  482|      0|        prepareValuePxMatrix()
  483|      0|    }
  484|       |    
  485|       |    /// draws the grid background
  486|       |    internal func drawGridBackground(context: CGContext)
  487|      0|    {
  488|      0|        if drawGridBackgroundEnabled || drawBordersEnabled
  489|      0|        {
  490|      0|            context.saveGState()
  491|      0|        }
  492|      0|        
  493|      0|        if drawGridBackgroundEnabled
  494|      0|        {
  495|      0|            // draw the grid background
  496|      0|            context.setFillColor(gridBackgroundColor.cgColor)
  497|      0|            context.fill(_viewPortHandler.contentRect)
  498|      0|        }
  499|      0|        
  500|      0|        if drawBordersEnabled
  501|      0|        {
  502|      0|            context.setLineWidth(borderLineWidth)
  503|      0|            context.setStrokeColor(borderColor.cgColor)
  504|      0|            context.stroke(_viewPortHandler.contentRect)
  505|      0|        }
  506|      0|        
  507|      0|        if drawGridBackgroundEnabled || drawBordersEnabled
  508|      0|        {
  509|      0|            context.restoreGState()
  510|      0|        }
  511|      0|    }
  512|       |    
  513|       |    // MARK: - Gestures
  514|       |    
  515|       |    private enum GestureScaleAxis
  516|       |    {
  517|       |        case both
  518|       |        case x
  519|       |        case y
  520|       |    }
  521|       |    
  522|       |    private var _isDragging = false
  523|       |    private var _isScaling = false
  524|      0|    private var _gestureScaleAxis = GestureScaleAxis.both
  525|       |    private var _closestDataSetToTouch: IChartDataSet!
  526|       |    private var _panGestureReachedEdge: Bool = false
  527|       |    private weak var _outerScrollView: NSUIScrollView?
  528|       |    
  529|      0|    private var _lastPanPoint = CGPoint() /// This is to prevent using setTranslation which resets velocity
  530|       |    
  531|       |    private var _decelerationLastTime: TimeInterval = 0.0
  532|       |    private var _decelerationDisplayLink: NSUIDisplayLink!
  533|      0|    private var _decelerationVelocity = CGPoint()
  534|       |    
  535|       |    @objc private func tapGestureRecognized(_ recognizer: NSUITapGestureRecognizer)
  536|      0|    {
  537|      0|        if _data === nil
  538|      0|        {
  539|      0|            return
  540|      0|        }
  541|      0|        
  542|      0|        if recognizer.state == NSUIGestureRecognizerState.ended
  543|      0|        {
  544|      0|            if !isHighLightPerTapEnabled { return }
  545|      0|            
  546|      0|            let h = getHighlightByTouchPoint(recognizer.location(in: self))
  547|      0|            
  548|      0|            if h === nil || h == self.lastHighlighted
  549|      0|            {
  550|      0|                lastHighlighted = nil
  551|      0|                highlightValue(nil, callDelegate: true)
  552|      0|            }
  553|      0|            else
  554|      0|            {
  555|      0|                lastHighlighted = h
  556|      0|                highlightValue(h, callDelegate: true)
  557|      0|            }
  558|      0|        }
  559|      0|    }
  560|       |    
  561|       |    @objc private func doubleTapGestureRecognized(_ recognizer: NSUITapGestureRecognizer)
  562|      0|    {
  563|      0|        if _data === nil
  564|      0|        {
  565|      0|            return
  566|      0|        }
  567|      0|        
  568|      0|        if recognizer.state == NSUIGestureRecognizerState.ended
  569|      0|        {
  570|      0|            if _data !== nil && _doubleTapToZoomEnabled && (data?.entryCount ?? 0) > 0
  571|      0|            {
  572|      0|                var location = recognizer.location(in: self)
  573|      0|                location.x = location.x - _viewPortHandler.offsetLeft
  574|      0|                
  575|      0|                if isTouchInverted()
  576|      0|                {
  577|      0|                    location.y = -(location.y - _viewPortHandler.offsetTop)
  578|      0|                }
  579|      0|                else
  580|      0|                {
  581|      0|                    location.y = -(self.bounds.size.height - location.y - _viewPortHandler.offsetBottom)
  582|      0|                }
  583|      0|
  584|      0|                let scaleX: CGFloat = isScaleXEnabled ? 1.4 : 1.0
  585|      0|                let scaleY: CGFloat = isScaleYEnabled ? 1.4 : 1.0
  586|      0|
  587|      0|                self.zoom(scaleX: scaleX, scaleY: scaleY, x: location.x, y: location.y)
  588|      0|                delegate?.chartScaled?(self, scaleX: scaleX, scaleY: scaleY)
  589|      0|            }
  590|      0|        }
  591|      0|    }
  592|       |    
  593|       |    #if !os(tvOS)
  594|       |    @objc private func pinchGestureRecognized(_ recognizer: NSUIPinchGestureRecognizer)
  595|      0|    {
  596|      0|        if recognizer.state == NSUIGestureRecognizerState.began
  597|      0|        {
  598|      0|            stopDeceleration()
  599|      0|            
  600|      0|            if _data !== nil &&
  601|      0|                (_pinchZoomEnabled || _scaleXEnabled || _scaleYEnabled)
  602|      0|            {
  603|      0|                _isScaling = true
  604|      0|                
  605|      0|                if _pinchZoomEnabled
  606|      0|                {
  607|      0|                    _gestureScaleAxis = .both
  608|      0|                }
  609|      0|                else
  610|      0|                {
  611|      0|                    let x = abs(recognizer.location(in: self).x - recognizer.nsuiLocationOfTouch(1, inView: self).x)
  612|      0|                    let y = abs(recognizer.location(in: self).y - recognizer.nsuiLocationOfTouch(1, inView: self).y)
  613|      0|                    
  614|      0|                    if _scaleXEnabled != _scaleYEnabled
  615|      0|                    {
  616|      0|                        _gestureScaleAxis = _scaleXEnabled ? .x : .y
  617|      0|                    }
  618|      0|                    else
  619|      0|                    {
  620|      0|                        _gestureScaleAxis = x > y ? .x : .y
  621|      0|                    }
  622|      0|                }
  623|      0|            }
  624|      0|        }
  625|      0|        else if recognizer.state == NSUIGestureRecognizerState.ended ||
  626|      0|            recognizer.state == NSUIGestureRecognizerState.cancelled
  627|      0|        {
  628|      0|            if _isScaling
  629|      0|            {
  630|      0|                _isScaling = false
  631|      0|                
  632|      0|                // Range might have changed, which means that Y-axis labels could have changed in size, affecting Y-axis size. So we need to recalculate offsets.
  633|      0|                calculateOffsets()
  634|      0|                setNeedsDisplay()
  635|      0|            }
  636|      0|        }
  637|      0|        else if recognizer.state == NSUIGestureRecognizerState.changed
  638|      0|        {
  639|      0|            let isZoomingOut = (recognizer.nsuiScale < 1)
  640|      0|            var canZoomMoreX = isZoomingOut ? _viewPortHandler.canZoomOutMoreX : _viewPortHandler.canZoomInMoreX
  641|      0|            var canZoomMoreY = isZoomingOut ? _viewPortHandler.canZoomOutMoreY : _viewPortHandler.canZoomInMoreY
  642|      0|            
  643|      0|            if _isScaling
  644|      0|            {
  645|      0|                canZoomMoreX = canZoomMoreX && _scaleXEnabled && (_gestureScaleAxis == .both || _gestureScaleAxis == .x)
  646|      0|                canZoomMoreY = canZoomMoreY && _scaleYEnabled && (_gestureScaleAxis == .both || _gestureScaleAxis == .y)
  647|      0|                if canZoomMoreX || canZoomMoreY
  648|      0|                {
  649|      0|                    var location = recognizer.location(in: self)
  650|      0|                    location.x = location.x - _viewPortHandler.offsetLeft
  651|      0|                    
  652|      0|                    if isTouchInverted()
  653|      0|                    {
  654|      0|                        location.y = -(location.y - _viewPortHandler.offsetTop)
  655|      0|                    }
  656|      0|                    else
  657|      0|                    {
  658|      0|                        location.y = -(_viewPortHandler.chartHeight - location.y - _viewPortHandler.offsetBottom)
  659|      0|                    }
  660|      0|                    
  661|      0|                    let scaleX = canZoomMoreX ? recognizer.nsuiScale : 1.0
  662|      0|                    let scaleY = canZoomMoreY ? recognizer.nsuiScale : 1.0
  663|      0|                    
  664|      0|                    var matrix = CGAffineTransform(translationX: location.x, y: location.y)
  665|      0|                    matrix = matrix.scaledBy(x: scaleX, y: scaleY)
  666|      0|                    matrix = matrix.translatedBy(x: -location.x, y: -location.y)
  667|      0|                    
  668|      0|                    matrix = _viewPortHandler.touchMatrix.concatenating(matrix)
  669|      0|                    
  670|      0|                    _viewPortHandler.refresh(newMatrix: matrix, chart: self, invalidate: true)
  671|      0|                    
  672|      0|                    if delegate !== nil
  673|      0|                    {
  674|      0|                        delegate?.chartScaled?(self, scaleX: scaleX, scaleY: scaleY)
  675|      0|                    }
  676|      0|                }
  677|      0|                
  678|      0|                recognizer.nsuiScale = 1.0
  679|      0|            }
  680|      0|        }
  681|      0|    }
  682|       |    #endif
  683|       |    
  684|       |    @objc private func panGestureRecognized(_ recognizer: NSUIPanGestureRecognizer)
  685|      0|    {
  686|      0|        if recognizer.state == NSUIGestureRecognizerState.began && recognizer.nsuiNumberOfTouches() > 0
  687|      0|        {
  688|      0|            stopDeceleration()
  689|      0|            
  690|      0|            if _data === nil || !self.isDragEnabled
  691|      0|            { // If we have no data, we have nothing to pan and no data to highlight
  692|      0|                return
  693|      0|            }
  694|      0|            
  695|      0|            // If drag is enabled and we are in a position where there's something to drag:
  696|      0|            //  * If we're zoomed in, then obviously we have something to drag.
  697|      0|            //  * If we have a drag offset - we always have something to drag
  698|      0|            if !self.hasNoDragOffset || !self.isFullyZoomedOut
  699|      0|            {
  700|      0|                _isDragging = true
  701|      0|                
  702|      0|                _closestDataSetToTouch = getDataSetByTouchPoint(point: recognizer.nsuiLocationOfTouch(0, inView: self))
  703|      0|                
  704|      0|                var translation = recognizer.translation(in: self)
  705|      0|                if !self.dragXEnabled
  706|      0|                {
  707|      0|                    translation.x = 0.0
  708|      0|                }
  709|      0|                else if !self.dragYEnabled
  710|      0|                {
  711|      0|                    translation.y = 0.0
  712|      0|                }
  713|      0|                
  714|      0|                let didUserDrag = translation.x != 0.0 || translation.y != 0.0
  715|      0|                
  716|      0|                // Check to see if user dragged at all and if so, can the chart be dragged by the given amount
  717|      0|                if didUserDrag && !performPanChange(translation: translation)
  718|      0|                {
  719|      0|                    if _outerScrollView !== nil
  720|      0|                    {
  721|      0|                        // We can stop dragging right now, and let the scroll view take control
  722|      0|                        _outerScrollView = nil
  723|      0|                        _isDragging = false
  724|      0|                    }
  725|      0|                }
  726|      0|                else
  727|      0|                {
  728|      0|                    if _outerScrollView !== nil
  729|      0|                    {
  730|      0|                        // Prevent the parent scroll view from scrolling
  731|      0|                        _outerScrollView?.nsuiIsScrollEnabled = false
  732|      0|                    }
  733|      0|                }
  734|      0|                
  735|      0|                _lastPanPoint = recognizer.translation(in: self)
  736|      0|            }
  737|      0|            else if self.isHighlightPerDragEnabled
  738|      0|            {
  739|      0|                // We will only handle highlights on NSUIGestureRecognizerState.Changed
  740|      0|                
  741|      0|                _isDragging = false
  742|      0|            }
  743|      0|        }
  744|      0|        else if recognizer.state == NSUIGestureRecognizerState.changed
  745|      0|        {
  746|      0|            if _isDragging
  747|      0|            {
  748|      0|                let originalTranslation = recognizer.translation(in: self)
  749|      0|                var translation = CGPoint(x: originalTranslation.x - _lastPanPoint.x, y: originalTranslation.y - _lastPanPoint.y)
  750|      0|                
  751|      0|                if !self.dragXEnabled
  752|      0|                {
  753|      0|                    translation.x = 0.0
  754|      0|                }
  755|      0|                else if !self.dragYEnabled
  756|      0|                {
  757|      0|                    translation.y = 0.0
  758|      0|                }
  759|      0|                
  760|      0|                let _ = performPanChange(translation: translation)
  761|      0|                
  762|      0|                _lastPanPoint = originalTranslation
  763|      0|            }
  764|      0|            else if isHighlightPerDragEnabled
  765|      0|            {
  766|      0|                let h = getHighlightByTouchPoint(recognizer.location(in: self))
  767|      0|                
  768|      0|                let lastHighlighted = self.lastHighlighted
  769|      0|                
  770|      0|                if h != lastHighlighted
  771|      0|                {
  772|      0|                    self.lastHighlighted = h
  773|      0|                    self.highlightValue(h, callDelegate: true)
  774|      0|                }
  775|      0|            }
  776|      0|        }
  777|      0|        else if recognizer.state == NSUIGestureRecognizerState.ended || recognizer.state == NSUIGestureRecognizerState.cancelled
  778|      0|        {
  779|      0|            if _isDragging
  780|      0|            {
  781|      0|                if recognizer.state == NSUIGestureRecognizerState.ended && isDragDecelerationEnabled
  782|      0|                {
  783|      0|                    stopDeceleration()
  784|      0|                    
  785|      0|                    _decelerationLastTime = CACurrentMediaTime()
  786|      0|                    _decelerationVelocity = recognizer.velocity(in: self)
  787|      0|                    
  788|      0|                    _decelerationDisplayLink = NSUIDisplayLink(target: self, selector: #selector(BarLineChartViewBase.decelerationLoop))
  789|      0|                    _decelerationDisplayLink.add(to: RunLoop.main, forMode: RunLoop.Mode.common)
  790|      0|                }
  791|      0|                
  792|      0|                _isDragging = false
  793|      0|                
  794|      0|                delegate?.chartViewDidEndPanning?(self)
  795|      0|            }
  796|      0|            
  797|      0|            if _outerScrollView !== nil
  798|      0|            {
  799|      0|                _outerScrollView?.nsuiIsScrollEnabled = true
  800|      0|                _outerScrollView = nil
  801|      0|            }
  802|      0|        }
  803|      0|    }
  804|       |    
  805|       |    private func performPanChange(translation: CGPoint) -> Bool
  806|      0|    {
  807|      0|        var translation = translation
  808|      0|        
  809|      0|        if isTouchInverted()
  810|      0|        {
  811|      0|            if self is HorizontalBarChartView
  812|      0|            {
  813|      0|                translation.x = -translation.x
  814|      0|            }
  815|      0|            else
  816|      0|            {
  817|      0|                translation.y = -translation.y
  818|      0|            }
  819|      0|        }
  820|      0|        
  821|      0|        let originalMatrix = _viewPortHandler.touchMatrix
  822|      0|        
  823|      0|        var matrix = CGAffineTransform(translationX: translation.x, y: translation.y)
  824|      0|        matrix = originalMatrix.concatenating(matrix)
  825|      0|        
  826|      0|        matrix = _viewPortHandler.refresh(newMatrix: matrix, chart: self, invalidate: true)
  827|      0|        
  828|      0|        if matrix != originalMatrix
  829|      0|        {
  830|      0|            delegate?.chartTranslated?(self, dX: translation.x, dY: translation.y)
  831|      0|        }
  832|      0|        
  833|      0|        // Did we managed to actually drag or did we reach the edge?
  834|      0|        return matrix.tx != originalMatrix.tx || matrix.ty != originalMatrix.ty
  835|      0|    }
  836|       |    
  837|       |    private func isTouchInverted() -> Bool
  838|      0|    {
  839|      0|        return isAnyAxisInverted &&
  840|      0|            _closestDataSetToTouch !== nil &&
  841|      0|            getAxis(_closestDataSetToTouch.axisDependency).isInverted
  842|      0|    }
  843|       |    
  844|       |    @objc open func stopDeceleration()
  845|      0|    {
  846|      0|        if _decelerationDisplayLink !== nil
  847|      0|        {
  848|      0|            _decelerationDisplayLink.remove(from: RunLoop.main, forMode: RunLoop.Mode.common)
  849|      0|            _decelerationDisplayLink = nil
  850|      0|        }
  851|      0|    }
  852|       |    
  853|       |    @objc private func decelerationLoop()
  854|      0|    {
  855|      0|        let currentTime = CACurrentMediaTime()
  856|      0|        
  857|      0|        _decelerationVelocity.x *= self.dragDecelerationFrictionCoef
  858|      0|        _decelerationVelocity.y *= self.dragDecelerationFrictionCoef
  859|      0|        
  860|      0|        let timeInterval = CGFloat(currentTime - _decelerationLastTime)
  861|      0|        
  862|      0|        let distance = CGPoint(
  863|      0|            x: _decelerationVelocity.x * timeInterval,
  864|      0|            y: _decelerationVelocity.y * timeInterval
  865|      0|        )
  866|      0|        
  867|      0|        if !performPanChange(translation: distance)
  868|      0|        {
  869|      0|            // We reached the edge, stop
  870|      0|            _decelerationVelocity.x = 0.0
  871|      0|            _decelerationVelocity.y = 0.0
  872|      0|        }
  873|      0|        
  874|      0|        _decelerationLastTime = currentTime
  875|      0|        
  876|      0|        if abs(_decelerationVelocity.x) < 0.001 && abs(_decelerationVelocity.y) < 0.001
  877|      0|        {
  878|      0|            stopDeceleration()
  879|      0|            
  880|      0|            // Range might have changed, which means that Y-axis labels could have changed in size, affecting Y-axis size. So we need to recalculate offsets.
  881|      0|            calculateOffsets()
  882|      0|            setNeedsDisplay()
  883|      0|        }
  884|      0|    }
  885|       |    
  886|       |    private func nsuiGestureRecognizerShouldBegin(_ gestureRecognizer: NSUIGestureRecognizer) -> Bool
  887|      0|    {
  888|      0|        if gestureRecognizer == _panGestureRecognizer
  889|      0|        {
  890|      0|            let velocity = _panGestureRecognizer.velocity(in: self)
  891|      0|            if _data === nil || !isDragEnabled ||
  892|      0|                (self.hasNoDragOffset && self.isFullyZoomedOut && !self.isHighlightPerDragEnabled) ||
  893|      0|                (!_dragYEnabled && abs(velocity.y) > abs(velocity.x)) ||
  894|      0|                (!_dragXEnabled && abs(velocity.y) < abs(velocity.x))
  895|      0|            {
  896|      0|                return false
  897|      0|            }
  898|      0|        }
  899|      0|        else
  900|      0|        {
  901|      0|            #if !os(tvOS)
  902|      0|            if gestureRecognizer == _pinchGestureRecognizer
  903|      0|            {
  904|      0|                if _data === nil || (!_pinchZoomEnabled && !_scaleXEnabled && !_scaleYEnabled)
  905|      0|                {
  906|      0|                    return false
  907|      0|                }
  908|      0|            }
  909|      0|            #endif
  910|      0|        }
  911|      0|        
  912|      0|        return true
  913|      0|    }
  914|       |    
  915|       |    #if !os(OSX)
  916|       |    open override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool
  917|      0|    {
  918|      0|        if !super.gestureRecognizerShouldBegin(gestureRecognizer)
  919|      0|        {
  920|      0|            return false
  921|      0|        }
  922|      0|        
  923|      0|        return nsuiGestureRecognizerShouldBegin(gestureRecognizer)
  924|      0|    }
  925|       |    #endif
  926|       |    
  927|       |    #if os(OSX)
  928|       |    public func gestureRecognizerShouldBegin(gestureRecognizer: NSGestureRecognizer) -> Bool
  929|       |    {
  930|       |        return nsuiGestureRecognizerShouldBegin(gestureRecognizer)
  931|       |    }
  932|       |    #endif
  933|       |    
  934|       |    open func gestureRecognizer(_ gestureRecognizer: NSUIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: NSUIGestureRecognizer) -> Bool
  935|      0|    {
  936|      0|        #if !os(tvOS)
  937|      0|        if ((gestureRecognizer is NSUIPinchGestureRecognizer && otherGestureRecognizer is NSUIPanGestureRecognizer) ||
  938|      0|            (gestureRecognizer is NSUIPanGestureRecognizer && otherGestureRecognizer is NSUIPinchGestureRecognizer))
  939|      0|        {
  940|      0|            return true
  941|      0|        }
  942|      0|        #endif
  943|      0|        
  944|      0|        if gestureRecognizer is NSUIPanGestureRecognizer,
  945|      0|            otherGestureRecognizer is NSUIPanGestureRecognizer,
  946|      0|            gestureRecognizer == _panGestureRecognizer
  947|      0|        {
  948|      0|            var scrollView = self.superview
  949|      0|            while scrollView != nil && !(scrollView is NSUIScrollView)
  950|      0|            {
  951|      0|                scrollView = scrollView?.superview
  952|      0|            }
  953|      0|            
  954|      0|            // If there is two scrollview together, we pick the superview of the inner scrollview.
  955|      0|            // In the case of UITableViewWrepperView, the superview will be UITableView
  956|      0|            if let superViewOfScrollView = scrollView?.superview,
  957|      0|                superViewOfScrollView is NSUIScrollView
  958|      0|            {
  959|      0|                scrollView = superViewOfScrollView
  960|      0|            }
  961|      0|
  962|      0|            var foundScrollView = scrollView as? NSUIScrollView
  963|      0|            
  964|      0|            if !(foundScrollView?.nsuiIsScrollEnabled ?? true)
  965|      0|            {
  966|      0|                foundScrollView = nil
  967|      0|            }
  968|      0|            
  969|      0|            let scrollViewPanGestureRecognizer = foundScrollView?.nsuiGestureRecognizers?.first {
  970|      0|                $0 is NSUIPanGestureRecognizer
  971|      0|            }
  972|      0|            
  973|      0|            if otherGestureRecognizer === scrollViewPanGestureRecognizer
  974|      0|            {
  975|      0|                _outerScrollView = foundScrollView
  976|      0|                
  977|      0|                return true
  978|      0|            }
  979|      0|        }
  980|      0|        
  981|      0|        return false
  982|      0|    }
  983|       |    
  984|       |    /// MARK: Viewport modifiers
  985|       |    
  986|       |    /// Zooms in by 1.4, into the charts center.
  987|       |    @objc open func zoomIn()
  988|      0|    {
  989|      0|        let center = _viewPortHandler.contentCenter
  990|      0|        
  991|      0|        let matrix = _viewPortHandler.zoomIn(x: center.x, y: -center.y)
  992|      0|        _viewPortHandler.refresh(newMatrix: matrix, chart: self, invalidate: false)
  993|      0|        
  994|      0|        // Range might have changed, which means that Y-axis labels could have changed in size, affecting Y-axis size. So we need to recalculate offsets.
  995|      0|        calculateOffsets()
  996|      0|        setNeedsDisplay()
  997|      0|    }
  998|       |
  999|       |    /// Zooms out by 0.7, from the charts center.
 1000|       |    @objc open func zoomOut()
 1001|      0|    {
 1002|      0|        let center = _viewPortHandler.contentCenter
 1003|      0|        
 1004|      0|        let matrix = _viewPortHandler.zoomOut(x: center.x, y: -center.y)
 1005|      0|        _viewPortHandler.refresh(newMatrix: matrix, chart: self, invalidate: false)
 1006|      0|
 1007|      0|        // Range might have changed, which means that Y-axis labels could have changed in size, affecting Y-axis size. So we need to recalculate offsets.
 1008|      0|        calculateOffsets()
 1009|      0|        setNeedsDisplay()
 1010|      0|    }
 1011|       |    
 1012|       |    /// Zooms out to original size.
 1013|       |    @objc open func resetZoom()
 1014|      0|    {
 1015|      0|        let matrix = _viewPortHandler.resetZoom()
 1016|      0|        _viewPortHandler.refresh(newMatrix: matrix, chart: self, invalidate: false)
 1017|      0|        
 1018|      0|        // Range might have changed, which means that Y-axis labels could have changed in size, affecting Y-axis size. So we need to recalculate offsets.
 1019|      0|        calculateOffsets()
 1020|      0|        setNeedsDisplay()
 1021|      0|    }
 1022|       |
 1023|       |    /// Zooms in or out by the given scale factor. x and y are the coordinates
 1024|       |    /// (in pixels) of the zoom center.
 1025|       |    ///
 1026|       |    /// - Parameters:
 1027|       |    ///   - scaleX: if < 1 --> zoom out, if > 1 --> zoom in
 1028|       |    ///   - scaleY: if < 1 --> zoom out, if > 1 --> zoom in
 1029|       |    ///   - x:
 1030|       |    ///   - y:
 1031|       |    @objc open func zoom(
 1032|       |        scaleX: CGFloat,
 1033|       |               scaleY: CGFloat,
 1034|       |               x: CGFloat,
 1035|       |               y: CGFloat)
 1036|      0|    {
 1037|      0|        let matrix = _viewPortHandler.zoom(scaleX: scaleX, scaleY: scaleY, x: x, y: -y)
 1038|      0|        _viewPortHandler.refresh(newMatrix: matrix, chart: self, invalidate: false)
 1039|      0|        
 1040|      0|        // Range might have changed, which means that Y-axis labels could have changed in size, affecting Y-axis size. So we need to recalculate offsets.
 1041|      0|        calculateOffsets()
 1042|      0|        setNeedsDisplay()
 1043|      0|    }
 1044|       |    
 1045|       |    /// Zooms in or out by the given scale factor.
 1046|       |    /// x and y are the values (**not pixels**) of the zoom center.
 1047|       |    ///
 1048|       |    /// - Parameters:
 1049|       |    ///   - scaleX: if < 1 --> zoom out, if > 1 --> zoom in
 1050|       |    ///   - scaleY: if < 1 --> zoom out, if > 1 --> zoom in
 1051|       |    ///   - xValue:
 1052|       |    ///   - yValue:
 1053|       |    ///   - axis:
 1054|       |    @objc open func zoom(
 1055|       |        scaleX: CGFloat,
 1056|       |               scaleY: CGFloat,
 1057|       |               xValue: Double,
 1058|       |               yValue: Double,
 1059|       |               axis: YAxis.AxisDependency)
 1060|      0|    {
 1061|      0|        let job = ZoomViewJob(
 1062|      0|            viewPortHandler: viewPortHandler,
 1063|      0|            scaleX: scaleX,
 1064|      0|            scaleY: scaleY,
 1065|      0|            xValue: xValue,
 1066|      0|            yValue: yValue,
 1067|      0|            transformer: getTransformer(forAxis: axis),
 1068|      0|            axis: axis,
 1069|      0|            view: self)
 1070|      0|        addViewportJob(job)
 1071|      0|    }
 1072|       |    
 1073|       |    /// Zooms to the center of the chart with the given scale factor.
 1074|       |    ///
 1075|       |    /// - Parameters:
 1076|       |    ///   - scaleX: if < 1 --> zoom out, if > 1 --> zoom in
 1077|       |    ///   - scaleY: if < 1 --> zoom out, if > 1 --> zoom in
 1078|       |    ///   - xValue:
 1079|       |    ///   - yValue:
 1080|       |    ///   - axis:
 1081|       |    @objc open func zoomToCenter(
 1082|       |        scaleX: CGFloat,
 1083|       |               scaleY: CGFloat)
 1084|      0|    {
 1085|      0|        let center = centerOffsets
 1086|      0|        let matrix = viewPortHandler.zoom(
 1087|      0|            scaleX: scaleX,
 1088|      0|            scaleY: scaleY,
 1089|      0|            x: center.x,
 1090|      0|            y: -center.y)
 1091|      0|        viewPortHandler.refresh(newMatrix: matrix, chart: self, invalidate: false)
 1092|      0|    }
 1093|       |    
 1094|       |    /// Zooms by the specified scale factor to the specified values on the specified axis.
 1095|       |    ///
 1096|       |    /// - Parameters:
 1097|       |    ///   - scaleX:
 1098|       |    ///   - scaleY:
 1099|       |    ///   - xValue:
 1100|       |    ///   - yValue:
 1101|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1102|       |    ///   - duration: the duration of the animation in seconds
 1103|       |    ///   - easing:
 1104|       |    @objc open func zoomAndCenterViewAnimated(
 1105|       |        scaleX: CGFloat,
 1106|       |        scaleY: CGFloat,
 1107|       |        xValue: Double,
 1108|       |        yValue: Double,
 1109|       |        axis: YAxis.AxisDependency,
 1110|       |        duration: TimeInterval,
 1111|       |        easing: ChartEasingFunctionBlock?)
 1112|      0|    {
 1113|      0|        let origin = valueForTouchPoint(
 1114|      0|            point: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop),
 1115|      0|            axis: axis)
 1116|      0|        
 1117|      0|        let job = AnimatedZoomViewJob(
 1118|      0|            viewPortHandler: viewPortHandler,
 1119|      0|            transformer: getTransformer(forAxis: axis),
 1120|      0|            view: self,
 1121|      0|            yAxis: getAxis(axis),
 1122|      0|            xAxisRange: _xAxis.axisRange,
 1123|      0|            scaleX: scaleX,
 1124|      0|            scaleY: scaleY,
 1125|      0|            xOrigin: viewPortHandler.scaleX,
 1126|      0|            yOrigin: viewPortHandler.scaleY,
 1127|      0|            zoomCenterX: CGFloat(xValue),
 1128|      0|            zoomCenterY: CGFloat(yValue),
 1129|      0|            zoomOriginX: origin.x,
 1130|      0|            zoomOriginY: origin.y,
 1131|      0|            duration: duration,
 1132|      0|            easing: easing)
 1133|      0|            
 1134|      0|        addViewportJob(job)
 1135|      0|    }
 1136|       |    
 1137|       |    /// Zooms by the specified scale factor to the specified values on the specified axis.
 1138|       |    ///
 1139|       |    /// - Parameters:
 1140|       |    ///   - scaleX:
 1141|       |    ///   - scaleY:
 1142|       |    ///   - xValue:
 1143|       |    ///   - yValue:
 1144|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1145|       |    ///   - duration: the duration of the animation in seconds
 1146|       |    ///   - easing:
 1147|       |    @objc open func zoomAndCenterViewAnimated(
 1148|       |        scaleX: CGFloat,
 1149|       |        scaleY: CGFloat,
 1150|       |        xValue: Double,
 1151|       |        yValue: Double,
 1152|       |        axis: YAxis.AxisDependency,
 1153|       |        duration: TimeInterval,
 1154|       |        easingOption: ChartEasingOption)
 1155|      0|    {
 1156|      0|        zoomAndCenterViewAnimated(scaleX: scaleX, scaleY: scaleY, xValue: xValue, yValue: yValue, axis: axis, duration: duration, easing: easingFunctionFromOption(easingOption))
 1157|      0|    }
 1158|       |    
 1159|       |    /// Zooms by the specified scale factor to the specified values on the specified axis.
 1160|       |    ///
 1161|       |    /// - Parameters:
 1162|       |    ///   - scaleX:
 1163|       |    ///   - scaleY:
 1164|       |    ///   - xValue:
 1165|       |    ///   - yValue:
 1166|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1167|       |    ///   - duration: the duration of the animation in seconds
 1168|       |    ///   - easing:
 1169|       |    @objc open func zoomAndCenterViewAnimated(
 1170|       |        scaleX: CGFloat,
 1171|       |        scaleY: CGFloat,
 1172|       |        xValue: Double,
 1173|       |        yValue: Double,
 1174|       |        axis: YAxis.AxisDependency,
 1175|       |        duration: TimeInterval)
 1176|      0|    {
 1177|      0|        zoomAndCenterViewAnimated(scaleX: scaleX, scaleY: scaleY, xValue: xValue, yValue: yValue, axis: axis, duration: duration, easingOption: .easeInOutSine)
 1178|      0|    }
 1179|       |    
 1180|       |    /// Resets all zooming and dragging and makes the chart fit exactly it's bounds.
 1181|       |    @objc open func fitScreen()
 1182|      0|    {
 1183|      0|        let matrix = _viewPortHandler.fitScreen()
 1184|      0|        _viewPortHandler.refresh(newMatrix: matrix, chart: self, invalidate: false)
 1185|      0|        
 1186|      0|        calculateOffsets()
 1187|      0|        setNeedsDisplay()
 1188|      0|    }
 1189|       |    
 1190|       |    /// Sets the minimum scale value to which can be zoomed out. 1 = fitScreen
 1191|       |    @objc open func setScaleMinima(_ scaleX: CGFloat, scaleY: CGFloat)
 1192|      0|    {
 1193|      0|        _viewPortHandler.setMinimumScaleX(scaleX)
 1194|      0|        _viewPortHandler.setMinimumScaleY(scaleY)
 1195|      0|    }
 1196|       |    
 1197|       |    @objc open var visibleXRange: Double
 1198|      0|    {
 1199|      0|        return abs(highestVisibleX - lowestVisibleX)
 1200|      0|    }
 1201|       |    
 1202|       |    /// Sets the size of the area (range on the x-axis) that should be maximum visible at once (no further zooming out allowed).
 1203|       |    ///
 1204|       |    /// If this is e.g. set to 10, no more than a range of 10 values on the x-axis can be viewed at once without scrolling.
 1205|       |    ///
 1206|       |    /// If you call this method, chart must have data or it has no effect.
 1207|       |    @objc open func setVisibleXRangeMaximum(_ maxXRange: Double)
 1208|      0|    {
 1209|      0|        let xScale = _xAxis.axisRange / maxXRange
 1210|      0|        _viewPortHandler.setMinimumScaleX(CGFloat(xScale))
 1211|      0|    }
 1212|       |    
 1213|       |    /// Sets the size of the area (range on the x-axis) that should be minimum visible at once (no further zooming in allowed).
 1214|       |    ///
 1215|       |    /// If this is e.g. set to 10, no less than a range of 10 values on the x-axis can be viewed at once without scrolling.
 1216|       |    ///
 1217|       |    /// If you call this method, chart must have data or it has no effect.
 1218|       |    @objc open func setVisibleXRangeMinimum(_ minXRange: Double)
 1219|      0|    {
 1220|      0|        let xScale = _xAxis.axisRange / minXRange
 1221|      0|        _viewPortHandler.setMaximumScaleX(CGFloat(xScale))
 1222|      0|    }
 1223|       |
 1224|       |    /// Limits the maximum and minimum value count that can be visible by pinching and zooming.
 1225|       |    ///
 1226|       |    /// e.g. minRange=10, maxRange=100 no less than 10 values and no more that 100 values can be viewed
 1227|       |    /// at once without scrolling.
 1228|       |    ///
 1229|       |    /// If you call this method, chart must have data or it has no effect.
 1230|       |    @objc open func setVisibleXRange(minXRange: Double, maxXRange: Double)
 1231|      0|    {
 1232|      0|        let minScale = _xAxis.axisRange / maxXRange
 1233|      0|        let maxScale = _xAxis.axisRange / minXRange
 1234|      0|        _viewPortHandler.setMinMaxScaleX(
 1235|      0|            minScaleX: CGFloat(minScale),
 1236|      0|            maxScaleX: CGFloat(maxScale))
 1237|      0|    }
 1238|       |    
 1239|       |    /// Sets the size of the area (range on the y-axis) that should be maximum visible at once.
 1240|       |    ///
 1241|       |    /// - Parameters:
 1242|       |    ///   - yRange:
 1243|       |    ///   - axis: - the axis for which this limit should apply
 1244|       |    @objc open func setVisibleYRangeMaximum(_ maxYRange: Double, axis: YAxis.AxisDependency)
 1245|      0|    {
 1246|      0|        let yScale = getAxisRange(axis: axis) / maxYRange
 1247|      0|        _viewPortHandler.setMinimumScaleY(CGFloat(yScale))
 1248|      0|    }
 1249|       |    
 1250|       |    /// Sets the size of the area (range on the y-axis) that should be minimum visible at once, no further zooming in possible.
 1251|       |    ///
 1252|       |    /// - Parameters:
 1253|       |    ///   - yRange:
 1254|       |    ///   - axis: - the axis for which this limit should apply
 1255|       |    @objc open func setVisibleYRangeMinimum(_ minYRange: Double, axis: YAxis.AxisDependency)
 1256|      0|    {
 1257|      0|        let yScale = getAxisRange(axis: axis) / minYRange
 1258|      0|        _viewPortHandler.setMaximumScaleY(CGFloat(yScale))
 1259|      0|    }
 1260|       |
 1261|       |    /// Limits the maximum and minimum y range that can be visible by pinching and zooming.
 1262|       |    ///
 1263|       |    /// - Parameters:
 1264|       |    ///   - minYRange:
 1265|       |    ///   - maxYRange:
 1266|       |    ///   - axis:
 1267|       |    @objc open func setVisibleYRange(minYRange: Double, maxYRange: Double, axis: YAxis.AxisDependency)
 1268|      0|    {
 1269|      0|        let minScale = getAxisRange(axis: axis) / minYRange
 1270|      0|        let maxScale = getAxisRange(axis: axis) / maxYRange
 1271|      0|        _viewPortHandler.setMinMaxScaleY(minScaleY: CGFloat(minScale), maxScaleY: CGFloat(maxScale))
 1272|      0|    }
 1273|       |    
 1274|       |    /// Moves the left side of the current viewport to the specified x-value.
 1275|       |    /// This also refreshes the chart by calling setNeedsDisplay().
 1276|       |    @objc open func moveViewToX(_ xValue: Double)
 1277|      0|    {
 1278|      0|        let job = MoveViewJob(
 1279|      0|            viewPortHandler: viewPortHandler,
 1280|      0|            xValue: xValue,
 1281|      0|            yValue: 0.0,
 1282|      0|            transformer: getTransformer(forAxis: .left),
 1283|      0|            view: self)
 1284|      0|        
 1285|      0|        addViewportJob(job)
 1286|      0|    }
 1287|       |
 1288|       |    /// Centers the viewport to the specified y-value on the y-axis.
 1289|       |    /// This also refreshes the chart by calling setNeedsDisplay().
 1290|       |    /// 
 1291|       |    /// - Parameters:
 1292|       |    ///   - yValue:
 1293|       |    ///   - axis: - which axis should be used as a reference for the y-axis
 1294|       |    @objc open func moveViewToY(_ yValue: Double, axis: YAxis.AxisDependency)
 1295|      0|    {
 1296|      0|        let yInView = getAxisRange(axis: axis) / Double(_viewPortHandler.scaleY)
 1297|      0|        
 1298|      0|        let job = MoveViewJob(
 1299|      0|            viewPortHandler: viewPortHandler,
 1300|      0|            xValue: 0.0,
 1301|      0|            yValue: yValue + yInView / 2.0,
 1302|      0|            transformer: getTransformer(forAxis: axis),
 1303|      0|            view: self)
 1304|      0|        
 1305|      0|        addViewportJob(job)
 1306|      0|    }
 1307|       |
 1308|       |    /// This will move the left side of the current viewport to the specified x-value on the x-axis, and center the viewport to the specified y-value on the y-axis.
 1309|       |    /// This also refreshes the chart by calling setNeedsDisplay().
 1310|       |    /// 
 1311|       |    /// - Parameters:
 1312|       |    ///   - xValue:
 1313|       |    ///   - yValue:
 1314|       |    ///   - axis: - which axis should be used as a reference for the y-axis
 1315|       |    @objc open func moveViewTo(xValue: Double, yValue: Double, axis: YAxis.AxisDependency)
 1316|      0|    {
 1317|      0|        let yInView = getAxisRange(axis: axis) / Double(_viewPortHandler.scaleY)
 1318|      0|        
 1319|      0|        let job = MoveViewJob(
 1320|      0|            viewPortHandler: viewPortHandler,
 1321|      0|            xValue: xValue,
 1322|      0|            yValue: yValue + yInView / 2.0,
 1323|      0|            transformer: getTransformer(forAxis: axis),
 1324|      0|            view: self)
 1325|      0|        
 1326|      0|        addViewportJob(job)
 1327|      0|    }
 1328|       |    
 1329|       |    /// This will move the left side of the current viewport to the specified x-position and center the viewport to the specified y-position animated.
 1330|       |    /// This also refreshes the chart by calling setNeedsDisplay().
 1331|       |    ///
 1332|       |    /// - Parameters:
 1333|       |    ///   - xValue:
 1334|       |    ///   - yValue:
 1335|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1336|       |    ///   - duration: the duration of the animation in seconds
 1337|       |    ///   - easing:
 1338|       |    @objc open func moveViewToAnimated(
 1339|       |        xValue: Double,
 1340|       |        yValue: Double,
 1341|       |        axis: YAxis.AxisDependency,
 1342|       |        duration: TimeInterval,
 1343|       |        easing: ChartEasingFunctionBlock?)
 1344|      0|    {
 1345|      0|        let bounds = valueForTouchPoint(
 1346|      0|            point: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop),
 1347|      0|            axis: axis)
 1348|      0|        
 1349|      0|        let yInView = getAxisRange(axis: axis) / Double(_viewPortHandler.scaleY)
 1350|      0|        
 1351|      0|        let job = AnimatedMoveViewJob(
 1352|      0|            viewPortHandler: viewPortHandler,
 1353|      0|            xValue: xValue,
 1354|      0|            yValue: yValue + yInView / 2.0,
 1355|      0|            transformer: getTransformer(forAxis: axis),
 1356|      0|            view: self,
 1357|      0|            xOrigin: bounds.x,
 1358|      0|            yOrigin: bounds.y,
 1359|      0|            duration: duration,
 1360|      0|            easing: easing)
 1361|      0|        
 1362|      0|        addViewportJob(job)
 1363|      0|    }
 1364|       |    
 1365|       |    /// This will move the left side of the current viewport to the specified x-position and center the viewport to the specified y-position animated.
 1366|       |    /// This also refreshes the chart by calling setNeedsDisplay().
 1367|       |    ///
 1368|       |    /// - Parameters:
 1369|       |    ///   - xValue:
 1370|       |    ///   - yValue:
 1371|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1372|       |    ///   - duration: the duration of the animation in seconds
 1373|       |    ///   - easing:
 1374|       |    @objc open func moveViewToAnimated(
 1375|       |        xValue: Double,
 1376|       |        yValue: Double,
 1377|       |        axis: YAxis.AxisDependency,
 1378|       |        duration: TimeInterval,
 1379|       |        easingOption: ChartEasingOption)
 1380|      0|    {
 1381|      0|        moveViewToAnimated(xValue: xValue, yValue: yValue, axis: axis, duration: duration, easing: easingFunctionFromOption(easingOption))
 1382|      0|    }
 1383|       |    
 1384|       |    /// This will move the left side of the current viewport to the specified x-position and center the viewport to the specified y-position animated.
 1385|       |    /// This also refreshes the chart by calling setNeedsDisplay().
 1386|       |    ///
 1387|       |    /// - Parameters:
 1388|       |    ///   - xValue:
 1389|       |    ///   - yValue:
 1390|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1391|       |    ///   - duration: the duration of the animation in seconds
 1392|       |    ///   - easing:
 1393|       |    @objc open func moveViewToAnimated(
 1394|       |        xValue: Double,
 1395|       |        yValue: Double,
 1396|       |        axis: YAxis.AxisDependency,
 1397|       |        duration: TimeInterval)
 1398|      0|    {
 1399|      0|        moveViewToAnimated(xValue: xValue, yValue: yValue, axis: axis, duration: duration, easingOption: .easeInOutSine)
 1400|      0|    }
 1401|       |    
 1402|       |    /// This will move the center of the current viewport to the specified x-value and y-value.
 1403|       |    /// This also refreshes the chart by calling setNeedsDisplay().
 1404|       |    ///
 1405|       |    /// - Parameters:
 1406|       |    ///   - xValue:
 1407|       |    ///   - yValue:
 1408|       |    ///   - axis: - which axis should be used as a reference for the y-axis
 1409|       |    @objc open func centerViewTo(
 1410|       |        xValue: Double,
 1411|       |        yValue: Double,
 1412|       |        axis: YAxis.AxisDependency)
 1413|      0|    {
 1414|      0|        let yInView = getAxisRange(axis: axis) / Double(_viewPortHandler.scaleY)
 1415|      0|        let xInView = xAxis.axisRange / Double(_viewPortHandler.scaleX)
 1416|      0|        
 1417|      0|        let job = MoveViewJob(
 1418|      0|            viewPortHandler: viewPortHandler,
 1419|      0|            xValue: xValue - xInView / 2.0,
 1420|      0|            yValue: yValue + yInView / 2.0,
 1421|      0|            transformer: getTransformer(forAxis: axis),
 1422|      0|            view: self)
 1423|      0|        
 1424|      0|        addViewportJob(job)
 1425|      0|    }
 1426|       |    
 1427|       |    /// This will move the center of the current viewport to the specified x-value and y-value animated.
 1428|       |    ///
 1429|       |    /// - Parameters:
 1430|       |    ///   - xValue:
 1431|       |    ///   - yValue:
 1432|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1433|       |    ///   - duration: the duration of the animation in seconds
 1434|       |    ///   - easing:
 1435|       |    @objc open func centerViewToAnimated(
 1436|       |        xValue: Double,
 1437|       |        yValue: Double,
 1438|       |        axis: YAxis.AxisDependency,
 1439|       |        duration: TimeInterval,
 1440|       |        easing: ChartEasingFunctionBlock?)
 1441|      0|    {
 1442|      0|        let bounds = valueForTouchPoint(
 1443|      0|            point: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop),
 1444|      0|            axis: axis)
 1445|      0|        
 1446|      0|        let yInView = getAxisRange(axis: axis) / Double(_viewPortHandler.scaleY)
 1447|      0|        let xInView = xAxis.axisRange / Double(_viewPortHandler.scaleX)
 1448|      0|        
 1449|      0|        let job = AnimatedMoveViewJob(
 1450|      0|            viewPortHandler: viewPortHandler,
 1451|      0|            xValue: xValue - xInView / 2.0,
 1452|      0|            yValue: yValue + yInView / 2.0,
 1453|      0|            transformer: getTransformer(forAxis: axis),
 1454|      0|            view: self,
 1455|      0|            xOrigin: bounds.x,
 1456|      0|            yOrigin: bounds.y,
 1457|      0|            duration: duration,
 1458|      0|            easing: easing)
 1459|      0|        
 1460|      0|        addViewportJob(job)
 1461|      0|    }
 1462|       |    
 1463|       |    /// This will move the center of the current viewport to the specified x-value and y-value animated.
 1464|       |    ///
 1465|       |    /// - Parameters:
 1466|       |    ///   - xValue:
 1467|       |    ///   - yValue:
 1468|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1469|       |    ///   - duration: the duration of the animation in seconds
 1470|       |    ///   - easing:
 1471|       |    @objc open func centerViewToAnimated(
 1472|       |        xValue: Double,
 1473|       |        yValue: Double,
 1474|       |        axis: YAxis.AxisDependency,
 1475|       |        duration: TimeInterval,
 1476|       |        easingOption: ChartEasingOption)
 1477|      0|    {
 1478|      0|        centerViewToAnimated(xValue: xValue, yValue: yValue, axis: axis, duration: duration, easing: easingFunctionFromOption(easingOption))
 1479|      0|    }
 1480|       |    
 1481|       |    /// This will move the center of the current viewport to the specified x-value and y-value animated.
 1482|       |    ///
 1483|       |    /// - Parameters:
 1484|       |    ///   - xValue:
 1485|       |    ///   - yValue:
 1486|       |    ///   - axis: which axis should be used as a reference for the y-axis
 1487|       |    ///   - duration: the duration of the animation in seconds
 1488|       |    ///   - easing:
 1489|       |    @objc open func centerViewToAnimated(
 1490|       |        xValue: Double,
 1491|       |        yValue: Double,
 1492|       |        axis: YAxis.AxisDependency,
 1493|       |        duration: TimeInterval)
 1494|      0|    {
 1495|      0|        centerViewToAnimated(xValue: xValue, yValue: yValue, axis: axis, duration: duration, easingOption: .easeInOutSine)
 1496|      0|    }
 1497|       |
 1498|       |    /// Sets custom offsets for the current `ChartViewPort` (the offsets on the sides of the actual chart window). Setting this will prevent the chart from automatically calculating it's offsets. Use `resetViewPortOffsets()` to undo this.
 1499|       |    /// ONLY USE THIS WHEN YOU KNOW WHAT YOU ARE DOING, else use `setExtraOffsets(...)`.
 1500|       |    @objc open func setViewPortOffsets(left: CGFloat, top: CGFloat, right: CGFloat, bottom: CGFloat)
 1501|      0|    {
 1502|      0|        _customViewPortEnabled = true
 1503|      0|        
 1504|      0|        if Thread.isMainThread
 1505|      0|        {
 1506|      0|            self._viewPortHandler.restrainViewPort(offsetLeft: left, offsetTop: top, offsetRight: right, offsetBottom: bottom)
 1507|      0|            prepareOffsetMatrix()
 1508|      0|            prepareValuePxMatrix()
 1509|      0|        }
 1510|      0|        else
 1511|      0|        {
 1512|      0|            DispatchQueue.main.async(execute: {
 1513|      0|                self.setViewPortOffsets(left: left, top: top, right: right, bottom: bottom)
 1514|      0|            })
 1515|      0|        }
 1516|      0|    }
 1517|       |
 1518|       |    /// Resets all custom offsets set via `setViewPortOffsets(...)` method. Allows the chart to again calculate all offsets automatically.
 1519|       |    @objc open func resetViewPortOffsets()
 1520|      0|    {
 1521|      0|        _customViewPortEnabled = false
 1522|      0|        calculateOffsets()
 1523|      0|    }
 1524|       |
 1525|       |    // MARK: - Accessors
 1526|       |    
 1527|       |    /// - Returns: The range of the specified axis.
 1528|       |    @objc open func getAxisRange(axis: YAxis.AxisDependency) -> Double
 1529|      0|    {
 1530|      0|        if axis == .left
 1531|      0|        {
 1532|      0|            return leftAxis.axisRange
 1533|      0|        }
 1534|      0|        else
 1535|      0|        {
 1536|      0|            return rightAxis.axisRange
 1537|      0|        }
 1538|      0|    }
 1539|       |
 1540|       |    /// - Returns: The position (in pixels) the provided Entry has inside the chart view
 1541|       |    @objc open func getPosition(entry e: ChartDataEntry, axis: YAxis.AxisDependency) -> CGPoint
 1542|      0|    {
 1543|      0|        var vals = CGPoint(x: CGFloat(e.x), y: CGFloat(e.y))
 1544|      0|
 1545|      0|        getTransformer(forAxis: axis).pointValueToPixel(&vals)
 1546|      0|
 1547|      0|        return vals
 1548|      0|    }
 1549|       |
 1550|       |    /// is dragging enabled? (moving the chart with the finger) for the chart (this does not affect scaling).
 1551|       |    @objc open var dragEnabled: Bool
 1552|       |    {
 1553|       |        get
 1554|      0|        {
 1555|      0|            return _dragXEnabled || _dragYEnabled
 1556|      0|        }
 1557|       |        set
 1558|      0|        {
 1559|      0|            _dragYEnabled = newValue
 1560|      0|            _dragXEnabled = newValue
 1561|      0|        }
 1562|       |    }
 1563|       |    
 1564|       |    /// is dragging enabled? (moving the chart with the finger) for the chart (this does not affect scaling).
 1565|       |    @objc open var isDragEnabled: Bool
 1566|      0|    {
 1567|      0|        return dragEnabled
 1568|      0|    }
 1569|       |    
 1570|       |    /// is dragging on the X axis enabled?
 1571|       |    @objc open var dragXEnabled: Bool
 1572|       |    {
 1573|       |        get
 1574|      0|        {
 1575|      0|            return _dragXEnabled
 1576|      0|        }
 1577|       |        set
 1578|      0|        {
 1579|      0|            _dragXEnabled = newValue
 1580|      0|        }
 1581|       |    }
 1582|       |    
 1583|       |    /// is dragging on the Y axis enabled?
 1584|       |    @objc open var dragYEnabled: Bool
 1585|       |    {
 1586|       |        get
 1587|      0|        {
 1588|      0|            return _dragYEnabled
 1589|      0|        }
 1590|       |        set
 1591|      0|        {
 1592|      0|            _dragYEnabled = newValue
 1593|      0|        }
 1594|       |    }
 1595|       |    
 1596|       |    /// is scaling enabled? (zooming in and out by gesture) for the chart (this does not affect dragging).
 1597|       |    @objc open func setScaleEnabled(_ enabled: Bool)
 1598|      0|    {
 1599|      0|        if _scaleXEnabled != enabled || _scaleYEnabled != enabled
 1600|      0|        {
 1601|      0|            _scaleXEnabled = enabled
 1602|      0|            _scaleYEnabled = enabled
 1603|      0|            #if !os(tvOS)
 1604|      0|            _pinchGestureRecognizer.isEnabled = _pinchZoomEnabled || _scaleXEnabled || _scaleYEnabled
 1605|      0|            #endif
 1606|      0|        }
 1607|      0|    }
 1608|       |    
 1609|       |    @objc open var scaleXEnabled: Bool
 1610|       |    {
 1611|       |        get
 1612|      0|        {
 1613|      0|            return _scaleXEnabled
 1614|      0|        }
 1615|       |        set
 1616|      0|        {
 1617|      0|            if _scaleXEnabled != newValue
 1618|      0|            {
 1619|      0|                _scaleXEnabled = newValue
 1620|      0|                #if !os(tvOS)
 1621|      0|                _pinchGestureRecognizer.isEnabled = _pinchZoomEnabled || _scaleXEnabled || _scaleYEnabled
 1622|      0|                #endif
 1623|      0|            }
 1624|      0|        }
 1625|       |    }
 1626|       |    
 1627|       |    @objc open var scaleYEnabled: Bool
 1628|       |    {
 1629|       |        get
 1630|      0|        {
 1631|      0|            return _scaleYEnabled
 1632|      0|        }
 1633|       |        set
 1634|      0|        {
 1635|      0|            if _scaleYEnabled != newValue
 1636|      0|            {
 1637|      0|                _scaleYEnabled = newValue
 1638|      0|                #if !os(tvOS)
 1639|      0|                _pinchGestureRecognizer.isEnabled = _pinchZoomEnabled || _scaleXEnabled || _scaleYEnabled
 1640|      0|                #endif
 1641|      0|            }
 1642|      0|        }
 1643|       |    }
 1644|       |    
 1645|      0|    @objc open var isScaleXEnabled: Bool { return scaleXEnabled }
 1646|      0|    @objc open var isScaleYEnabled: Bool { return scaleYEnabled }
 1647|       |    
 1648|       |    /// flag that indicates if double tap zoom is enabled or not
 1649|       |    @objc open var doubleTapToZoomEnabled: Bool
 1650|       |    {
 1651|       |        get
 1652|      0|        {
 1653|      0|            return _doubleTapToZoomEnabled
 1654|      0|        }
 1655|       |        set
 1656|      0|        {
 1657|      0|            if _doubleTapToZoomEnabled != newValue
 1658|      0|            {
 1659|      0|                _doubleTapToZoomEnabled = newValue
 1660|      0|                _doubleTapGestureRecognizer.isEnabled = _doubleTapToZoomEnabled
 1661|      0|            }
 1662|      0|        }
 1663|       |    }
 1664|       |    
 1665|       |    /// **default**: true
 1666|       |    /// `true` if zooming via double-tap is enabled `false` ifnot.
 1667|       |    @objc open var isDoubleTapToZoomEnabled: Bool
 1668|      0|    {
 1669|      0|        return doubleTapToZoomEnabled
 1670|      0|    }
 1671|       |    
 1672|       |    /// flag that indicates if highlighting per dragging over a fully zoomed out chart is enabled
 1673|       |    @objc open var highlightPerDragEnabled = true
 1674|       |    
 1675|       |    /// If set to true, highlighting per dragging over a fully zoomed out chart is enabled
 1676|       |    /// You might want to disable this when using inside a `NSUIScrollView`
 1677|       |    /// 
 1678|       |    /// **default**: true
 1679|       |    @objc open var isHighlightPerDragEnabled: Bool
 1680|      0|    {
 1681|      0|        return highlightPerDragEnabled
 1682|      0|    }
 1683|       |    
 1684|       |    /// **default**: true
 1685|       |    /// `true` if drawing the grid background is enabled, `false` ifnot.
 1686|       |    @objc open var isDrawGridBackgroundEnabled: Bool
 1687|      0|    {
 1688|      0|        return drawGridBackgroundEnabled
 1689|      0|    }
 1690|       |    
 1691|       |    /// **default**: false
 1692|       |    /// `true` if drawing the borders rectangle is enabled, `false` ifnot.
 1693|       |    @objc open var isDrawBordersEnabled: Bool
 1694|      0|    {
 1695|      0|        return drawBordersEnabled
 1696|      0|    }
 1697|       |
 1698|       |    /// - Returns: The x and y values in the chart at the given touch point
 1699|       |    /// (encapsulated in a `CGPoint`). This method transforms pixel coordinates to
 1700|       |    /// coordinates / values in the chart. This is the opposite method to
 1701|       |    /// `getPixelsForValues(...)`.
 1702|       |    @objc open func valueForTouchPoint(point pt: CGPoint, axis: YAxis.AxisDependency) -> CGPoint
 1703|      0|    {
 1704|      0|        return getTransformer(forAxis: axis).valueForTouchPoint(pt)
 1705|      0|    }
 1706|       |
 1707|       |    /// Transforms the given chart values into pixels. This is the opposite
 1708|       |    /// method to `valueForTouchPoint(...)`.
 1709|       |    @objc open func pixelForValues(x: Double, y: Double, axis: YAxis.AxisDependency) -> CGPoint
 1710|      0|    {
 1711|      0|        return getTransformer(forAxis: axis).pixelForValues(x: x, y: y)
 1712|      0|    }
 1713|       |    
 1714|       |    /// - Returns: The Entry object displayed at the touched position of the chart
 1715|       |    @objc open func getEntryByTouchPoint(point pt: CGPoint) -> ChartDataEntry!
 1716|      0|    {
 1717|      0|        if let h = getHighlightByTouchPoint(pt)
 1718|      0|        {
 1719|      0|            return _data!.entryForHighlight(h)
 1720|      0|        }
 1721|      0|        return nil
 1722|      0|    }
 1723|       |    
 1724|       |    /// - Returns: The DataSet object displayed at the touched position of the chart
 1725|       |    @objc open func getDataSetByTouchPoint(point pt: CGPoint) -> IBarLineScatterCandleBubbleChartDataSet?
 1726|      0|    {
 1727|      0|        let h = getHighlightByTouchPoint(pt)
 1728|      0|        if h !== nil
 1729|      0|        {
 1730|      0|            return _data?.getDataSetByIndex(h!.dataSetIndex) as? IBarLineScatterCandleBubbleChartDataSet
 1731|      0|        }
 1732|      0|        return nil
 1733|      0|    }
 1734|       |
 1735|       |    /// The current x-scale factor
 1736|       |    @objc open var scaleX: CGFloat
 1737|      0|    {
 1738|      0|        if _viewPortHandler === nil
 1739|      0|        {
 1740|      0|            return 1.0
 1741|      0|        }
 1742|      0|        return _viewPortHandler.scaleX
 1743|      0|    }
 1744|       |
 1745|       |    /// The current y-scale factor
 1746|       |    @objc open var scaleY: CGFloat
 1747|      0|    {
 1748|      0|        if _viewPortHandler === nil
 1749|      0|        {
 1750|      0|            return 1.0
 1751|      0|        }
 1752|      0|        return _viewPortHandler.scaleY
 1753|      0|    }
 1754|       |
 1755|       |    /// if the chart is fully zoomed out, return true
 1756|      0|    @objc open var isFullyZoomedOut: Bool { return _viewPortHandler.isFullyZoomedOut }
 1757|       |
 1758|       |    /// - Returns: The y-axis object to the corresponding AxisDependency. In the
 1759|       |    /// horizontal bar-chart, LEFT == top, RIGHT == BOTTOM
 1760|       |    @objc open func getAxis(_ axis: YAxis.AxisDependency) -> YAxis
 1761|      0|    {
 1762|      0|        if axis == .left
 1763|      0|        {
 1764|      0|            return leftAxis
 1765|      0|        }
 1766|      0|        else
 1767|      0|        {
 1768|      0|            return rightAxis
 1769|      0|        }
 1770|      0|    }
 1771|       |    
 1772|       |    /// flag that indicates if pinch-zoom is enabled. if true, both x and y axis can be scaled simultaneously with 2 fingers, if false, x and y axis can be scaled separately
 1773|       |    @objc open var pinchZoomEnabled: Bool
 1774|       |    {
 1775|       |        get
 1776|      0|        {
 1777|      0|            return _pinchZoomEnabled
 1778|      0|        }
 1779|       |        set
 1780|      0|        {
 1781|      0|            if _pinchZoomEnabled != newValue
 1782|      0|            {
 1783|      0|                _pinchZoomEnabled = newValue
 1784|      0|                #if !os(tvOS)
 1785|      0|                _pinchGestureRecognizer.isEnabled = _pinchZoomEnabled || _scaleXEnabled || _scaleYEnabled
 1786|      0|                #endif
 1787|      0|            }
 1788|      0|        }
 1789|       |    }
 1790|       |
 1791|       |    /// **default**: false
 1792|       |    /// `true` if pinch-zoom is enabled, `false` ifnot
 1793|      0|    @objc open var isPinchZoomEnabled: Bool { return pinchZoomEnabled }
 1794|       |
 1795|       |    /// Set an offset in dp that allows the user to drag the chart over it's
 1796|       |    /// bounds on the x-axis.
 1797|       |    @objc open func setDragOffsetX(_ offset: CGFloat)
 1798|      0|    {
 1799|      0|        _viewPortHandler.setDragOffsetX(offset)
 1800|      0|    }
 1801|       |
 1802|       |    /// Set an offset in dp that allows the user to drag the chart over it's
 1803|       |    /// bounds on the y-axis.
 1804|       |    @objc open func setDragOffsetY(_ offset: CGFloat)
 1805|      0|    {
 1806|      0|        _viewPortHandler.setDragOffsetY(offset)
 1807|      0|    }
 1808|       |
 1809|       |    /// `true` if both drag offsets (x and y) are zero or smaller.
 1810|      0|    @objc open var hasNoDragOffset: Bool { return _viewPortHandler.hasNoDragOffset }
 1811|       |
 1812|       |    open override var chartYMax: Double
 1813|      0|    {
 1814|      0|        return max(leftAxis._axisMaximum, rightAxis._axisMaximum)
 1815|      0|    }
 1816|       |
 1817|       |    open override var chartYMin: Double
 1818|      0|    {
 1819|      0|        return min(leftAxis._axisMinimum, rightAxis._axisMinimum)
 1820|      0|    }
 1821|       |    
 1822|       |    /// `true` if either the left or the right or both axes are inverted.
 1823|       |    @objc open var isAnyAxisInverted: Bool
 1824|      0|    {
 1825|      0|        return leftAxis.isInverted || rightAxis.isInverted
 1826|      0|    }
 1827|       |    
 1828|       |    /// flag that indicates if auto scaling on the y axis is enabled.
 1829|       |    /// if yes, the y axis automatically adjusts to the min and max y values of the current x axis range whenever the viewport changes
 1830|       |    @objc open var autoScaleMinMaxEnabled: Bool
 1831|       |    {
 1832|      0|        get { return _autoScaleMinMaxEnabled }
 1833|      0|        set { _autoScaleMinMaxEnabled = newValue }
 1834|       |    }
 1835|       |    
 1836|       |    /// **default**: false
 1837|       |    /// `true` if auto scaling on the y axis is enabled.
 1838|      0|    @objc open var isAutoScaleMinMaxEnabled : Bool { return autoScaleMinMaxEnabled }
 1839|       |    
 1840|       |    /// Sets a minimum width to the specified y axis.
 1841|       |    @objc open func setYAxisMinWidth(_ axis: YAxis.AxisDependency, width: CGFloat)
 1842|      0|    {
 1843|      0|        if axis == .left
 1844|      0|        {
 1845|      0|            leftAxis.minWidth = width
 1846|      0|        }
 1847|      0|        else
 1848|      0|        {
 1849|      0|            rightAxis.minWidth = width
 1850|      0|        }
 1851|      0|    }
 1852|       |    
 1853|       |    /// **default**: 0.0
 1854|       |    ///
 1855|       |    /// - Returns: The (custom) minimum width of the specified Y axis.
 1856|       |    @objc open func getYAxisMinWidth(_ axis: YAxis.AxisDependency) -> CGFloat
 1857|      0|    {
 1858|      0|        if axis == .left
 1859|      0|        {
 1860|      0|            return leftAxis.minWidth
 1861|      0|        }
 1862|      0|        else
 1863|      0|        {
 1864|      0|            return rightAxis.minWidth
 1865|      0|        }
 1866|      0|    }
 1867|       |    /// Sets a maximum width to the specified y axis.
 1868|       |    /// Zero (0.0) means there's no maximum width
 1869|       |    @objc open func setYAxisMaxWidth(_ axis: YAxis.AxisDependency, width: CGFloat)
 1870|      0|    {
 1871|      0|        if axis == .left
 1872|      0|        {
 1873|      0|            leftAxis.maxWidth = width
 1874|      0|        }
 1875|      0|        else
 1876|      0|        {
 1877|      0|            rightAxis.maxWidth = width
 1878|      0|        }
 1879|      0|    }
 1880|       |    
 1881|       |    /// Zero (0.0) means there's no maximum width
 1882|       |    ///
 1883|       |    /// **default**: 0.0 (no maximum specified)
 1884|       |    ///
 1885|       |    /// - Returns: The (custom) maximum width of the specified Y axis.
 1886|       |    @objc open func getYAxisMaxWidth(_ axis: YAxis.AxisDependency) -> CGFloat
 1887|      0|    {
 1888|      0|        if axis == .left
 1889|      0|        {
 1890|      0|            return leftAxis.maxWidth
 1891|      0|        }
 1892|      0|        else
 1893|      0|        {
 1894|      0|            return rightAxis.maxWidth
 1895|      0|        }
 1896|      0|    }
 1897|       |
 1898|       |    /// - Returns the width of the specified y axis.
 1899|       |    @objc open func getYAxisWidth(_ axis: YAxis.AxisDependency) -> CGFloat
 1900|      0|    {
 1901|      0|        if axis == .left
 1902|      0|        {
 1903|      0|            return leftAxis.requiredSize().width
 1904|      0|        }
 1905|      0|        else
 1906|      0|        {
 1907|      0|            return rightAxis.requiredSize().width
 1908|      0|        }
 1909|      0|    }
 1910|       |    
 1911|       |    // MARK: - BarLineScatterCandleBubbleChartDataProvider
 1912|       |    
 1913|       |    /// - Returns: The Transformer class that contains all matrices and is
 1914|       |    /// responsible for transforming values into pixels on the screen and
 1915|       |    /// backwards.
 1916|       |    open func getTransformer(forAxis axis: YAxis.AxisDependency) -> Transformer
 1917|      0|    {
 1918|      0|        if axis == .left
 1919|      0|        {
 1920|      0|            return _leftAxisTransformer
 1921|      0|        }
 1922|      0|        else
 1923|      0|        {
 1924|      0|            return _rightAxisTransformer
 1925|      0|        }
 1926|      0|    }
 1927|       |    
 1928|       |    /// the number of maximum visible drawn values on the chart only active when `drawValuesEnabled` is enabled
 1929|       |    open override var maxVisibleCount: Int
 1930|       |    {
 1931|       |        get
 1932|      0|        {
 1933|      0|            return _maxVisibleCount
 1934|      0|        }
 1935|       |        set
 1936|      0|        {
 1937|      0|            _maxVisibleCount = newValue
 1938|      0|        }
 1939|       |    }
 1940|       |    
 1941|       |    open func isInverted(axis: YAxis.AxisDependency) -> Bool
 1942|      0|    {
 1943|      0|        return getAxis(axis).isInverted
 1944|      0|    }
 1945|       |    
 1946|       |    /// The lowest x-index (value on the x-axis) that is still visible on he chart.
 1947|       |    open var lowestVisibleX: Double
 1948|      0|    {
 1949|      0|        var pt = CGPoint(
 1950|      0|            x: viewPortHandler.contentLeft,
 1951|      0|            y: viewPortHandler.contentBottom)
 1952|      0|        
 1953|      0|        getTransformer(forAxis: .left).pixelToValues(&pt)
 1954|      0|        
 1955|      0|        return max(xAxis._axisMinimum, Double(pt.x))
 1956|      0|    }
 1957|       |    
 1958|       |    /// The highest x-index (value on the x-axis) that is still visible on the chart.
 1959|       |    open var highestVisibleX: Double
 1960|      0|    {
 1961|      0|        var pt = CGPoint(
 1962|      0|            x: viewPortHandler.contentRight,
 1963|      0|            y: viewPortHandler.contentBottom)
 1964|      0|        
 1965|      0|        getTransformer(forAxis: .left).pixelToValues(&pt)
 1966|      0|
 1967|      0|        return min(xAxis._axisMaximum, Double(pt.x))
 1968|      0|    }
 1969|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/BubbleChartView.swift:
    1|       |//
    2|       |//  BubbleChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Bubble chart implementation:
    6|       |//    Copyright 2015 Pierre-Marc Airoldi
    7|       |//    Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class BubbleChartView: BarLineChartViewBase, BubbleChartDataProvider
   16|       |{
   17|       |    open override func initialize()
   18|      0|    {
   19|      0|        super.initialize()
   20|      0|        
   21|      0|        renderer = BubbleChartRenderer(dataProvider: self, animator: _animator, viewPortHandler: _viewPortHandler)
   22|      0|    }
   23|       |    
   24|       |    // MARK: - BubbleChartDataProvider
   25|       |    
   26|      0|    open var bubbleData: BubbleChartData? { return _data as? BubbleChartData }
   27|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/CandleStickChartView.swift:
    1|       |//
    2|       |//  CandleStickChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// Financial chart type that draws candle-sticks.
   16|       |open class CandleStickChartView: BarLineChartViewBase, CandleChartDataProvider
   17|       |{
   18|       |    internal override func initialize()
   19|      0|    {
   20|      0|        super.initialize()
   21|      0|        
   22|      0|        renderer = CandleStickChartRenderer(dataProvider: self, animator: _animator, viewPortHandler: _viewPortHandler)
   23|      0|        
   24|      0|        self.xAxis.spaceMin = 0.5
   25|      0|        self.xAxis.spaceMax = 0.5
   26|      0|    }
   27|       |    
   28|       |    // MARK: - CandleChartDataProvider
   29|       |    
   30|       |    open var candleData: CandleChartData?
   31|      0|    {
   32|      0|        return _data as? CandleChartData
   33|      0|    }
   34|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/ChartViewBase.swift:
    1|       |//
    2|       |//  ChartViewBase.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |//  Based on https://github.com/PhilJay/MPAndroidChart/commit/c42b880
   12|       |
   13|       |import Foundation
   14|       |import CoreGraphics
   15|       |
   16|       |#if canImport(UIKit)
   17|       |    import UIKit
   18|       |#endif
   19|       |
   20|       |#if canImport(Cocoa)
   21|       |import Cocoa
   22|       |#endif
   23|       |
   24|       |@objc
   25|       |public protocol ChartViewDelegate
   26|       |{
   27|       |    /// Called when a value has been selected inside the chart.
   28|       |    ///
   29|       |    /// - Parameters:
   30|       |    ///   - entry: The selected Entry.
   31|       |    ///   - highlight: The corresponding highlight object that contains information about the highlighted position such as dataSetIndex etc.
   32|       |    @objc optional func chartValueSelected(_ chartView: ChartViewBase, entry: ChartDataEntry, highlight: Highlight)
   33|       |    
   34|       |    /// Called when a user stops panning between values on the chart
   35|       |    @objc optional func chartViewDidEndPanning(_ chartView: ChartViewBase)
   36|       |    
   37|       |    // Called when nothing has been selected or an "un-select" has been made.
   38|       |    @objc optional func chartValueNothingSelected(_ chartView: ChartViewBase)
   39|       |    
   40|       |    // Callbacks when the chart is scaled / zoomed via pinch zoom gesture.
   41|       |    @objc optional func chartScaled(_ chartView: ChartViewBase, scaleX: CGFloat, scaleY: CGFloat)
   42|       |    
   43|       |    // Callbacks when the chart is moved / translated via drag gesture.
   44|       |    @objc optional func chartTranslated(_ chartView: ChartViewBase, dX: CGFloat, dY: CGFloat)
   45|       |
   46|       |    // Callbacks when Animator stops animating
   47|       |    @objc optional func chartView(_ chartView: ChartViewBase, animatorDidStop animator: Animator)
   48|       |}
   49|       |
   50|       |open class ChartViewBase: NSUIView, ChartDataProvider, AnimatorDelegate
   51|       |{
   52|       |    // MARK: - Properties
   53|       |    
   54|       |    /// - Returns: The object representing all x-labels, this method can be used to
   55|       |    /// acquire the XAxis object and modify it (e.g. change the position of the
   56|       |    /// labels)
   57|       |    @objc open var xAxis: XAxis
   58|      0|    {
   59|      0|        return _xAxis
   60|      0|    }
   61|       |    
   62|       |    /// The default IValueFormatter that has been determined by the chart considering the provided minimum and maximum values.
   63|      0|    internal var _defaultValueFormatter: IValueFormatter? = DefaultValueFormatter(decimals: 0)
   64|       |    
   65|       |    /// object that holds all data that was originally set for the chart, before it was modified or any filtering algorithms had been applied
   66|       |    internal var _data: ChartData?
   67|       |    
   68|       |    /// Flag that indicates if highlighting per tap (touch) is enabled
   69|       |    private var _highlightPerTapEnabled = true
   70|       |    
   71|       |    /// If set to true, chart continues to scroll after touch up
   72|       |    @objc open var dragDecelerationEnabled = true
   73|       |    
   74|       |    /// Deceleration friction coefficient in [0 ; 1] interval, higher values indicate that speed will decrease slowly, for example if it set to 0, it will stop immediately.
   75|       |    /// 1 is an invalid value, and will be converted to 0.999 automatically.
   76|       |    private var _dragDecelerationFrictionCoef: CGFloat = 0.9
   77|       |    
   78|       |    /// if true, units are drawn next to the values in the chart
   79|       |    internal var _drawUnitInChart = false
   80|       |    
   81|       |    /// The object representing the labels on the x-axis
   82|       |    internal var _xAxis: XAxis!
   83|       |    
   84|       |    /// The `Description` object of the chart.
   85|       |    /// This should have been called just "description", but
   86|       |    @objc open var chartDescription: Description?
   87|       |        
   88|       |    /// The legend object containing all data associated with the legend
   89|       |    internal var _legend: Legend!
   90|       |    
   91|       |    /// delegate to receive chart events
   92|       |    @objc open weak var delegate: ChartViewDelegate?
   93|       |    
   94|       |    /// text that is displayed when the chart is empty
   95|       |    @objc open var noDataText = "No chart data available."
   96|       |    
   97|       |    /// Font to be used for the no data text.
   98|      0|    @objc open var noDataFont = NSUIFont.systemFont(ofSize: 12)
   99|       |    
  100|       |    /// color of the no data text
  101|      0|    @objc open var noDataTextColor: NSUIColor = .labelOrBlack
  102|       |
  103|       |    /// alignment of the no data text
  104|      0|    @objc open var noDataTextAlignment: NSTextAlignment = .left
  105|       |
  106|       |    internal var _legendRenderer: LegendRenderer!
  107|       |    
  108|       |    /// object responsible for rendering the data
  109|       |    @objc open var renderer: DataRenderer?
  110|       |    
  111|       |    @objc open var highlighter: IHighlighter?
  112|       |    
  113|       |    /// object that manages the bounds and drawing constraints of the chart
  114|       |    internal var _viewPortHandler: ViewPortHandler!
  115|       |    
  116|       |    /// object responsible for animations
  117|       |    internal var _animator: Animator!
  118|       |    
  119|       |    /// flag that indicates if offsets calculation has already been done or not
  120|       |    private var _offsetsCalculated = false
  121|       |    
  122|       |    /// array of Highlight objects that reference the highlighted slices in the chart
  123|      0|    internal var _indicesToHighlight = [Highlight]()
  124|       |    
  125|       |    /// `true` if drawing the marker is enabled when tapping on values
  126|       |    /// (use the `marker` property to specify a marker)
  127|       |    @objc open var drawMarkers = true
  128|       |    
  129|       |    /// - Returns: `true` if drawing the marker is enabled when tapping on values
  130|       |    /// (use the `marker` property to specify a marker)
  131|      0|    @objc open var isDrawMarkersEnabled: Bool { return drawMarkers }
  132|       |    
  133|       |    /// The marker that is displayed when a value is clicked on the chart
  134|       |    @objc open var marker: IMarker?
  135|       |    
  136|       |    private var _interceptTouchEvents = false
  137|       |    
  138|       |    /// An extra offset to be appended to the viewport's top
  139|       |    @objc open var extraTopOffset: CGFloat = 0.0
  140|       |    
  141|       |    /// An extra offset to be appended to the viewport's right
  142|       |    @objc open var extraRightOffset: CGFloat = 0.0
  143|       |    
  144|       |    /// An extra offset to be appended to the viewport's bottom
  145|       |    @objc open var extraBottomOffset: CGFloat = 0.0
  146|       |    
  147|       |    /// An extra offset to be appended to the viewport's left
  148|       |    @objc open var extraLeftOffset: CGFloat = 0.0
  149|       |    
  150|       |    @objc open func setExtraOffsets(left: CGFloat, top: CGFloat, right: CGFloat, bottom: CGFloat)
  151|      0|    {
  152|      0|        extraLeftOffset = left
  153|      0|        extraTopOffset = top
  154|      0|        extraRightOffset = right
  155|      0|        extraBottomOffset = bottom
  156|      0|    }
  157|       |    
  158|       |    // MARK: - Initializers
  159|       |    
  160|       |    public override init(frame: CGRect)
  161|      0|    {
  162|      0|        super.init(frame: frame)
  163|      0|        initialize()
  164|      0|    }
  165|       |    
  166|       |    public required init?(coder aDecoder: NSCoder)
  167|      0|    {
  168|      0|        super.init(coder: aDecoder)
  169|      0|        initialize()
  170|      0|    }
  171|       |    
  172|       |    deinit
  173|      0|    {
  174|      0|        self.removeObserver(self, forKeyPath: "bounds")
  175|      0|        self.removeObserver(self, forKeyPath: "frame")
  176|      0|    }
  177|       |    
  178|       |    internal func initialize()
  179|      0|    {
  180|      0|        #if os(iOS)
  181|      0|        self.backgroundColor = NSUIColor.clear
  182|      0|        #endif
  183|      0|
  184|      0|        _animator = Animator()
  185|      0|        _animator.delegate = self
  186|      0|
  187|      0|        _viewPortHandler = ViewPortHandler(width: bounds.size.width, height: bounds.size.height)
  188|      0|        
  189|      0|        chartDescription = Description()
  190|      0|        
  191|      0|        _legend = Legend()
  192|      0|        _legendRenderer = LegendRenderer(viewPortHandler: _viewPortHandler, legend: _legend)
  193|      0|        
  194|      0|        _xAxis = XAxis()
  195|      0|        
  196|      0|        self.addObserver(self, forKeyPath: "bounds", options: .new, context: nil)
  197|      0|        self.addObserver(self, forKeyPath: "frame", options: .new, context: nil)
  198|      0|    }
  199|       |    
  200|       |    // MARK: - ChartViewBase
  201|       |    
  202|       |    /// The data for the chart
  203|       |    open var data: ChartData?
  204|       |    {
  205|       |        get
  206|      0|        {
  207|      0|            return _data
  208|      0|        }
  209|       |        set
  210|      0|        {
  211|      0|            _data = newValue
  212|      0|            _offsetsCalculated = false
  213|      0|            
  214|      0|            guard let _data = _data else
  215|      0|            {
  216|      0|                setNeedsDisplay()
  217|      0|                return
  218|      0|            }
  219|      0|            
  220|      0|            // calculate how many digits are needed
  221|      0|            setupDefaultFormatter(min: _data.getYMin(), max: _data.getYMax())
  222|      0|            
  223|      0|            for set in _data.dataSets
  224|      0|            {
  225|      0|                if set.needsFormatter || set.valueFormatter === _defaultValueFormatter
  226|      0|                {
  227|      0|                    set.valueFormatter = _defaultValueFormatter
  228|      0|                }
  229|      0|            }
  230|      0|            
  231|      0|            // let the chart know there is new data
  232|      0|            notifyDataSetChanged()
  233|      0|        }
  234|       |    }
  235|       |    
  236|       |    /// Clears the chart from all data (sets it to null) and refreshes it (by calling setNeedsDisplay()).
  237|       |    @objc open func clear()
  238|      0|    {
  239|      0|        _data = nil
  240|      0|        _offsetsCalculated = false
  241|      0|        _indicesToHighlight.removeAll()
  242|      0|        lastHighlighted = nil
  243|      0|    
  244|      0|        setNeedsDisplay()
  245|      0|    }
  246|       |    
  247|       |    /// Removes all DataSets (and thereby Entries) from the chart. Does not set the data object to nil. Also refreshes the chart by calling setNeedsDisplay().
  248|       |    @objc open func clearValues()
  249|      0|    {
  250|      0|        _data?.clearValues()
  251|      0|        setNeedsDisplay()
  252|      0|    }
  253|       |
  254|       |    /// - Returns: `true` if the chart is empty (meaning it's data object is either null or contains no entries).
  255|       |    @objc open func isEmpty() -> Bool
  256|      0|    {
  257|      0|        guard let data = _data else { return true }
  258|      0|
  259|      0|        if data.entryCount <= 0
  260|      0|        {
  261|      0|            return true
  262|      0|        }
  263|      0|        else
  264|      0|        {
  265|      0|            return false
  266|      0|        }
  267|      0|    }
  268|       |    
  269|       |    /// Lets the chart know its underlying data has changed and should perform all necessary recalculations.
  270|       |    /// It is crucial that this method is called everytime data is changed dynamically. Not calling this method can lead to crashes or unexpected behaviour.
  271|       |    @objc open func notifyDataSetChanged()
  272|      0|    {
  273|      0|        fatalError("notifyDataSetChanged() cannot be called on ChartViewBase")
  274|      0|    }
  275|       |    
  276|       |    /// Calculates the offsets of the chart to the border depending on the position of an eventual legend or depending on the length of the y-axis and x-axis labels and their position
  277|       |    internal func calculateOffsets()
  278|      0|    {
  279|      0|        fatalError("calculateOffsets() cannot be called on ChartViewBase")
  280|      0|    }
  281|       |    
  282|       |    /// calcualtes the y-min and y-max value and the y-delta and x-delta value
  283|       |    internal func calcMinMax()
  284|      0|    {
  285|      0|        fatalError("calcMinMax() cannot be called on ChartViewBase")
  286|      0|    }
  287|       |    
  288|       |    /// calculates the required number of digits for the values that might be drawn in the chart (if enabled), and creates the default value formatter
  289|       |    internal func setupDefaultFormatter(min: Double, max: Double)
  290|      0|    {
  291|      0|        // check if a custom formatter is set or not
  292|      0|        var reference = Double(0.0)
  293|      0|        
  294|      0|        if let data = _data , data.entryCount >= 2
  295|      0|        {
  296|      0|            reference = fabs(max - min)
  297|      0|        }
  298|      0|        else
  299|      0|        {
  300|      0|            let absMin = fabs(min)
  301|      0|            let absMax = fabs(max)
  302|      0|            reference = absMin > absMax ? absMin : absMax
  303|      0|        }
  304|      0|        
  305|      0|    
  306|      0|        if _defaultValueFormatter is DefaultValueFormatter
  307|      0|        {
  308|      0|            // setup the formatter with a new number of digits
  309|      0|            let digits = reference.decimalPlaces
  310|      0|            
  311|      0|            (_defaultValueFormatter as? DefaultValueFormatter)?.decimals
  312|      0|             = digits
  313|      0|        }
  314|      0|    }
  315|       |    
  316|       |    open override func draw(_ rect: CGRect)
  317|      0|    {
  318|      0|        let optionalContext = NSUIGraphicsGetCurrentContext()
  319|      0|        guard let context = optionalContext else { return }
  320|      0|        
  321|      0|        let frame = self.bounds
  322|      0|
  323|      0|        if _data === nil && noDataText.count > 0
  324|      0|        {
  325|      0|            context.saveGState()
  326|      0|            defer { context.restoreGState() }
  327|      0|
  328|      0|            let paragraphStyle = NSMutableParagraphStyle.default.mutableCopy() as! NSMutableParagraphStyle
  329|      0|            paragraphStyle.minimumLineHeight = noDataFont.lineHeight
  330|      0|            paragraphStyle.lineBreakMode = .byWordWrapping
  331|      0|            paragraphStyle.alignment = noDataTextAlignment
  332|      0|
  333|      0|            ChartUtils.drawMultilineText(
  334|      0|                context: context,
  335|      0|                text: noDataText,
  336|      0|                point: CGPoint(x: frame.width / 2.0, y: frame.height / 2.0),
  337|      0|                attributes:
  338|      0|                [.font: noDataFont,
  339|      0|                 .foregroundColor: noDataTextColor,
  340|      0|                 .paragraphStyle: paragraphStyle],
  341|      0|                constrainedToSize: self.bounds.size,
  342|      0|                anchor: CGPoint(x: 0.5, y: 0.5),
  343|      0|                angleRadians: 0.0)
  344|      0|            
  345|      0|            return
  346|      0|        }
  347|      0|        
  348|      0|        if !_offsetsCalculated
  349|      0|        {
  350|      0|            calculateOffsets()
  351|      0|            _offsetsCalculated = true
  352|      0|        }
  353|      0|    }
  354|       |    
  355|       |    /// Draws the description text in the bottom right corner of the chart (per default)
  356|       |    internal func drawDescription(context: CGContext)
  357|      0|    {
  358|      0|        // check if description should be drawn
  359|      0|        guard
  360|      0|            let description = chartDescription,
  361|      0|            description.isEnabled,
  362|      0|            let descriptionText = description.text,
  363|      0|            descriptionText.count > 0
  364|      0|            else { return }
  365|      0|        
  366|      0|        let position = description.position ?? CGPoint(x: bounds.width - _viewPortHandler.offsetRight - description.xOffset,
  367|      0|                                                       y: bounds.height - _viewPortHandler.offsetBottom - description.yOffset - description.font.lineHeight)
  368|      0|        
  369|      0|        var attrs = [NSAttributedString.Key : Any]()
  370|      0|        
  371|      0|        attrs[NSAttributedString.Key.font] = description.font
  372|      0|        attrs[NSAttributedString.Key.foregroundColor] = description.textColor
  373|      0|
  374|      0|        ChartUtils.drawText(
  375|      0|            context: context,
  376|      0|            text: descriptionText,
  377|      0|            point: position,
  378|      0|            align: description.textAlign,
  379|      0|            attributes: attrs)
  380|      0|    }
  381|       |    
  382|       |    // MARK: - Accessibility
  383|       |
  384|      0|    open override func accessibilityChildren() -> [Any]? {
  385|      0|        return renderer?.accessibleChartElements
  386|      0|    }
  387|       |
  388|       |    // MARK: - Highlighting
  389|       |    
  390|       |    /// The array of currently highlighted values. This might an empty if nothing is highlighted.
  391|       |    @objc open var highlighted: [Highlight]
  392|      0|    {
  393|      0|        return _indicesToHighlight
  394|      0|    }
  395|       |    
  396|       |    /// Set this to false to prevent values from being highlighted by tap gesture.
  397|       |    /// Values can still be highlighted via drag or programmatically.
  398|       |    /// **default**: true
  399|       |    @objc open var highlightPerTapEnabled: Bool
  400|       |    {
  401|      0|        get { return _highlightPerTapEnabled }
  402|      0|        set { _highlightPerTapEnabled = newValue }
  403|       |    }
  404|       |    
  405|       |    /// `true` if values can be highlighted via tap gesture, `false` ifnot.
  406|       |    @objc open var isHighLightPerTapEnabled: Bool
  407|      0|    {
  408|      0|        return highlightPerTapEnabled
  409|      0|    }
  410|       |    
  411|       |    /// Checks if the highlight array is null, has a length of zero or if the first object is null.
  412|       |    ///
  413|       |    /// - Returns: `true` if there are values to highlight, `false` ifthere are no values to highlight.
  414|       |    @objc open func valuesToHighlight() -> Bool
  415|      0|    {
  416|      0|        return !_indicesToHighlight.isEmpty
  417|      0|    }
  418|       |
  419|       |    /// Highlights the values at the given indices in the given DataSets. Provide
  420|       |    /// null or an empty array to undo all highlighting. 
  421|       |    /// This should be used to programmatically highlight values.
  422|       |    /// This method *will not* call the delegate.
  423|       |    @objc open func highlightValues(_ highs: [Highlight]?)
  424|      0|    {
  425|      0|        // set the indices to highlight
  426|      0|        _indicesToHighlight = highs ?? [Highlight]()
  427|      0|        
  428|      0|        if _indicesToHighlight.isEmpty
  429|      0|        {
  430|      0|            self.lastHighlighted = nil
  431|      0|        }
  432|      0|        else
  433|      0|        {
  434|      0|            self.lastHighlighted = _indicesToHighlight[0]
  435|      0|        }
  436|      0|
  437|      0|        // redraw the chart
  438|      0|        setNeedsDisplay()
  439|      0|    }
  440|       |    
  441|       |    /// Highlights any y-value at the given x-value in the given DataSet.
  442|       |    /// Provide -1 as the dataSetIndex to undo all highlighting.
  443|       |    /// This method will call the delegate.
  444|       |    ///
  445|       |    /// - Parameters:
  446|       |    ///   - x: The x-value to highlight
  447|       |    ///   - dataSetIndex: The dataset index to search in
  448|       |    ///   - dataIndex: The data index to search in (only used in CombinedChartView currently)
  449|       |    @objc open func highlightValue(x: Double, dataSetIndex: Int, dataIndex: Int = -1)
  450|      0|    {
  451|      0|        highlightValue(x: x, dataSetIndex: dataSetIndex, dataIndex: dataIndex, callDelegate: true)
  452|      0|    }
  453|       |    
  454|       |    /// Highlights the value at the given x-value and y-value in the given DataSet.
  455|       |    /// Provide -1 as the dataSetIndex to undo all highlighting.
  456|       |    /// This method will call the delegate.
  457|       |    ///
  458|       |    /// - Parameters:
  459|       |    ///   - x: The x-value to highlight
  460|       |    ///   - y: The y-value to highlight. Supply `NaN` for "any"
  461|       |    ///   - dataSetIndex: The dataset index to search in
  462|       |    ///   - dataIndex: The data index to search in (only used in CombinedChartView currently)
  463|       |    @objc open func highlightValue(x: Double, y: Double, dataSetIndex: Int, dataIndex: Int = -1)
  464|      0|    {
  465|      0|        highlightValue(x: x, y: y, dataSetIndex: dataSetIndex, dataIndex: dataIndex, callDelegate: true)
  466|      0|    }
  467|       |    
  468|       |    /// Highlights any y-value at the given x-value in the given DataSet.
  469|       |    /// Provide -1 as the dataSetIndex to undo all highlighting.
  470|       |    ///
  471|       |    /// - Parameters:
  472|       |    ///   - x: The x-value to highlight
  473|       |    ///   - dataSetIndex: The dataset index to search in
  474|       |    ///   - dataIndex: The data index to search in (only used in CombinedChartView currently)
  475|       |    ///   - callDelegate: Should the delegate be called for this change
  476|       |    @objc open func highlightValue(x: Double, dataSetIndex: Int, dataIndex: Int = -1, callDelegate: Bool)
  477|      0|    {
  478|      0|        highlightValue(x: x, y: .nan, dataSetIndex: dataSetIndex, dataIndex: dataIndex, callDelegate: callDelegate)
  479|      0|    }
  480|       |    
  481|       |    /// Highlights the value at the given x-value and y-value in the given DataSet.
  482|       |    /// Provide -1 as the dataSetIndex to undo all highlighting.
  483|       |    ///
  484|       |    /// - Parameters:
  485|       |    ///   - x: The x-value to highlight
  486|       |    ///   - y: The y-value to highlight. Supply `NaN` for "any"
  487|       |    ///   - dataSetIndex: The dataset index to search in
  488|       |    ///   - dataIndex: The data index to search in (only used in CombinedChartView currently)
  489|       |    ///   - callDelegate: Should the delegate be called for this change
  490|       |    @objc open func highlightValue(x: Double, y: Double, dataSetIndex: Int, dataIndex: Int = -1, callDelegate: Bool)
  491|      0|    {
  492|      0|        guard let data = _data else
  493|      0|        {
  494|      0|            Swift.print("Value not highlighted because data is nil")
  495|      0|            return
  496|      0|        }
  497|      0|        
  498|      0|        if dataSetIndex < 0 || dataSetIndex >= data.dataSetCount
  499|      0|        {
  500|      0|            highlightValue(nil, callDelegate: callDelegate)
  501|      0|        }
  502|      0|        else
  503|      0|        {
  504|      0|            highlightValue(Highlight(x: x, y: y, dataSetIndex: dataSetIndex, dataIndex: dataIndex), callDelegate: callDelegate)
  505|      0|        }
  506|      0|    }
  507|       |    
  508|       |    /// Highlights the values represented by the provided Highlight object
  509|       |    /// This method *will not* call the delegate.
  510|       |    ///
  511|       |    /// - Parameters:
  512|       |    ///   - highlight: contains information about which entry should be highlighted
  513|       |    @objc open func highlightValue(_ highlight: Highlight?)
  514|      0|    {
  515|      0|        highlightValue(highlight, callDelegate: false)
  516|      0|    }
  517|       |
  518|       |    /// Highlights the value selected by touch gesture.
  519|       |    @objc open func highlightValue(_ highlight: Highlight?, callDelegate: Bool)
  520|      0|    {
  521|      0|        var entry: ChartDataEntry?
  522|      0|        var h = highlight
  523|      0|        
  524|      0|        if h == nil
  525|      0|        {
  526|      0|            self.lastHighlighted = nil
  527|      0|            _indicesToHighlight.removeAll(keepingCapacity: false)
  528|      0|        }
  529|      0|        else
  530|      0|        {
  531|      0|            // set the indices to highlight
  532|      0|            entry = _data?.entryForHighlight(h!)
  533|      0|            if entry == nil
  534|      0|            {
  535|      0|                h = nil
  536|      0|                _indicesToHighlight.removeAll(keepingCapacity: false)
  537|      0|            }
  538|      0|            else
  539|      0|            {
  540|      0|                _indicesToHighlight = [h!]
  541|      0|            }
  542|      0|        }
  543|      0|        
  544|      0|        if callDelegate, let delegate = delegate
  545|      0|        {
  546|      0|            if let h = h
  547|      0|            {
  548|      0|                // notify the listener
  549|      0|                delegate.chartValueSelected?(self, entry: entry!, highlight: h)
  550|      0|            }
  551|      0|            else
  552|      0|            {
  553|      0|                delegate.chartValueNothingSelected?(self)
  554|      0|            }
  555|      0|        }
  556|      0|        
  557|      0|        // redraw the chart
  558|      0|        setNeedsDisplay()
  559|      0|    }
  560|       |    
  561|       |    /// - Returns: The Highlight object (contains x-index and DataSet index) of the
  562|       |    /// selected value at the given touch point inside the Line-, Scatter-, or
  563|       |    /// CandleStick-Chart.
  564|       |    @objc open func getHighlightByTouchPoint(_ pt: CGPoint) -> Highlight?
  565|      0|    {
  566|      0|        if _data === nil
  567|      0|        {
  568|      0|            Swift.print("Can't select by touch. No data set.")
  569|      0|            return nil
  570|      0|        }
  571|      0|        
  572|      0|        return self.highlighter?.getHighlight(x: pt.x, y: pt.y)
  573|      0|    }
  574|       |
  575|       |    /// The last value that was highlighted via touch.
  576|       |    @objc open var lastHighlighted: Highlight?
  577|       |  
  578|       |    // MARK: - Markers
  579|       |
  580|       |    /// draws all MarkerViews on the highlighted positions
  581|       |    internal func drawMarkers(context: CGContext)
  582|      0|    {
  583|      0|        // if there is no marker view or drawing marker is disabled
  584|      0|        guard
  585|      0|            let marker = marker
  586|      0|            , isDrawMarkersEnabled &&
  587|      0|                valuesToHighlight()
  588|      0|            else { return }
  589|      0|        
  590|      0|        for i in 0 ..< _indicesToHighlight.count
  591|      0|        {
  592|      0|            let highlight = _indicesToHighlight[i]
  593|      0|            
  594|      0|            guard let
  595|      0|                set = data?.getDataSetByIndex(highlight.dataSetIndex),
  596|      0|                let e = _data?.entryForHighlight(highlight)
  597|      0|                else { continue }
  598|      0|            
  599|      0|            let entryIndex = set.entryIndex(entry: e)
  600|      0|            if entryIndex > Int(Double(set.entryCount) * _animator.phaseX)
  601|      0|            {
  602|      0|                continue
  603|      0|            }
  604|      0|
  605|      0|            let pos = getMarkerPosition(highlight: highlight)
  606|      0|
  607|      0|            // check bounds
  608|      0|            if !_viewPortHandler.isInBounds(x: pos.x, y: pos.y)
  609|      0|            {
  610|      0|                continue
  611|      0|            }
  612|      0|
  613|      0|            // callbacks to update the content
  614|      0|            marker.refreshContent(entry: e, highlight: highlight)
  615|      0|            
  616|      0|            // draw the marker
  617|      0|            marker.draw(context: context, point: pos)
  618|      0|        }
  619|      0|    }
  620|       |    
  621|       |    /// - Returns: The actual position in pixels of the MarkerView for the given Entry in the given DataSet.
  622|       |    @objc open func getMarkerPosition(highlight: Highlight) -> CGPoint
  623|      0|    {
  624|      0|        return CGPoint(x: highlight.drawX, y: highlight.drawY)
  625|      0|    }
  626|       |    
  627|       |    // MARK: - Animation
  628|       |    
  629|       |    /// The animator responsible for animating chart values.
  630|       |    @objc open var chartAnimator: Animator!
  631|      0|    {
  632|      0|        return _animator
  633|      0|    }
  634|       |    
  635|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  636|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  637|       |    ///
  638|       |    /// - Parameters:
  639|       |    ///   - xAxisDuration: duration for animating the x axis
  640|       |    ///   - yAxisDuration: duration for animating the y axis
  641|       |    ///   - easingX: an easing function for the animation on the x axis
  642|       |    ///   - easingY: an easing function for the animation on the y axis
  643|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easingX: ChartEasingFunctionBlock?, easingY: ChartEasingFunctionBlock?)
  644|      0|    {
  645|      0|        _animator.animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration, easingX: easingX, easingY: easingY)
  646|      0|    }
  647|       |    
  648|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  649|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  650|       |    ///
  651|       |    /// - Parameters:
  652|       |    ///   - xAxisDuration: duration for animating the x axis
  653|       |    ///   - yAxisDuration: duration for animating the y axis
  654|       |    ///   - easingOptionX: the easing function for the animation on the x axis
  655|       |    ///   - easingOptionY: the easing function for the animation on the y axis
  656|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easingOptionX: ChartEasingOption, easingOptionY: ChartEasingOption)
  657|      0|    {
  658|      0|        _animator.animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration, easingOptionX: easingOptionX, easingOptionY: easingOptionY)
  659|      0|    }
  660|       |    
  661|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  662|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  663|       |    ///
  664|       |    /// - Parameters:
  665|       |    ///   - xAxisDuration: duration for animating the x axis
  666|       |    ///   - yAxisDuration: duration for animating the y axis
  667|       |    ///   - easing: an easing function for the animation
  668|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easing: ChartEasingFunctionBlock?)
  669|      0|    {
  670|      0|        _animator.animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration, easing: easing)
  671|      0|    }
  672|       |    
  673|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  674|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  675|       |    ///
  676|       |    /// - Parameters:
  677|       |    ///   - xAxisDuration: duration for animating the x axis
  678|       |    ///   - yAxisDuration: duration for animating the y axis
  679|       |    ///   - easingOption: the easing function for the animation
  680|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easingOption: ChartEasingOption)
  681|      0|    {
  682|      0|        _animator.animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration, easingOption: easingOption)
  683|      0|    }
  684|       |    
  685|       |    /// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time.
  686|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  687|       |    ///
  688|       |    /// - Parameters:
  689|       |    ///   - xAxisDuration: duration for animating the x axis
  690|       |    ///   - yAxisDuration: duration for animating the y axis
  691|       |    @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval)
  692|      0|    {
  693|      0|        _animator.animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration)
  694|      0|    }
  695|       |    
  696|       |    /// Animates the drawing / rendering of the chart the x-axis with the specified animation time.
  697|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  698|       |    ///
  699|       |    /// - Parameters:
  700|       |    ///   - xAxisDuration: duration for animating the x axis
  701|       |    ///   - easing: an easing function for the animation
  702|       |    @objc open func animate(xAxisDuration: TimeInterval, easing: ChartEasingFunctionBlock?)
  703|      0|    {
  704|      0|        _animator.animate(xAxisDuration: xAxisDuration, easing: easing)
  705|      0|    }
  706|       |    
  707|       |    /// Animates the drawing / rendering of the chart the x-axis with the specified animation time.
  708|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  709|       |    ///
  710|       |    /// - Parameters:
  711|       |    ///   - xAxisDuration: duration for animating the x axis
  712|       |    ///   - easingOption: the easing function for the animation
  713|       |    @objc open func animate(xAxisDuration: TimeInterval, easingOption: ChartEasingOption)
  714|      0|    {
  715|      0|        _animator.animate(xAxisDuration: xAxisDuration, easingOption: easingOption)
  716|      0|    }
  717|       |    
  718|       |    /// Animates the drawing / rendering of the chart the x-axis with the specified animation time.
  719|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  720|       |    ///
  721|       |    /// - Parameters:
  722|       |    ///   - xAxisDuration: duration for animating the x axis
  723|       |    @objc open func animate(xAxisDuration: TimeInterval)
  724|      0|    {
  725|      0|        _animator.animate(xAxisDuration: xAxisDuration)
  726|      0|    }
  727|       |    
  728|       |    /// Animates the drawing / rendering of the chart the y-axis with the specified animation time.
  729|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  730|       |    ///
  731|       |    /// - Parameters:
  732|       |    ///   - yAxisDuration: duration for animating the y axis
  733|       |    ///   - easing: an easing function for the animation
  734|       |    @objc open func animate(yAxisDuration: TimeInterval, easing: ChartEasingFunctionBlock?)
  735|      0|    {
  736|      0|        _animator.animate(yAxisDuration: yAxisDuration, easing: easing)
  737|      0|    }
  738|       |    
  739|       |    /// Animates the drawing / rendering of the chart the y-axis with the specified animation time.
  740|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  741|       |    ///
  742|       |    /// - Parameters:
  743|       |    ///   - yAxisDuration: duration for animating the y axis
  744|       |    ///   - easingOption: the easing function for the animation
  745|       |    @objc open func animate(yAxisDuration: TimeInterval, easingOption: ChartEasingOption)
  746|      0|    {
  747|      0|        _animator.animate(yAxisDuration: yAxisDuration, easingOption: easingOption)
  748|      0|    }
  749|       |    
  750|       |    /// Animates the drawing / rendering of the chart the y-axis with the specified animation time.
  751|       |    /// If `animate(...)` is called, no further calling of `invalidate()` is necessary to refresh the chart.
  752|       |    ///
  753|       |    /// - Parameters:
  754|       |    ///   - yAxisDuration: duration for animating the y axis
  755|       |    @objc open func animate(yAxisDuration: TimeInterval)
  756|      0|    {
  757|      0|        _animator.animate(yAxisDuration: yAxisDuration)
  758|      0|    }
  759|       |    
  760|       |    // MARK: - Accessors
  761|       |
  762|       |    /// The current y-max value across all DataSets
  763|       |    open var chartYMax: Double
  764|      0|    {
  765|      0|        return _data?.yMax ?? 0.0
  766|      0|    }
  767|       |
  768|       |    /// The current y-min value across all DataSets
  769|       |    open var chartYMin: Double
  770|      0|    {
  771|      0|        return _data?.yMin ?? 0.0
  772|      0|    }
  773|       |    
  774|       |    open var chartXMax: Double
  775|      0|    {
  776|      0|        return _xAxis._axisMaximum
  777|      0|    }
  778|       |    
  779|       |    open var chartXMin: Double
  780|      0|    {
  781|      0|        return _xAxis._axisMinimum
  782|      0|    }
  783|       |    
  784|       |    open var xRange: Double
  785|      0|    {
  786|      0|        return _xAxis.axisRange
  787|      0|    }
  788|       |    
  789|       |    /// - Note: (Equivalent of getCenter() in MPAndroidChart, as center is already a standard in iOS that returns the center point relative to superview, and MPAndroidChart returns relative to self)*
  790|       |    /// The center point of the chart (the whole View) in pixels.
  791|       |    @objc open var midPoint: CGPoint
  792|      0|    {
  793|      0|        let bounds = self.bounds
  794|      0|        return CGPoint(x: bounds.origin.x + bounds.size.width / 2.0, y: bounds.origin.y + bounds.size.height / 2.0)
  795|      0|    }
  796|       |    
  797|       |    /// The center of the chart taking offsets under consideration. (returns the center of the content rectangle)
  798|       |    open var centerOffsets: CGPoint
  799|      0|    {
  800|      0|        return _viewPortHandler.contentCenter
  801|      0|    }
  802|       |    
  803|       |    /// The Legend object of the chart. This method can be used to get an instance of the legend in order to customize the automatically generated Legend.
  804|       |    @objc open var legend: Legend
  805|      0|    {
  806|      0|        return _legend
  807|      0|    }
  808|       |    
  809|       |    /// The renderer object responsible for rendering / drawing the Legend.
  810|       |    @objc open var legendRenderer: LegendRenderer!
  811|      0|    {
  812|      0|        return _legendRenderer
  813|      0|    }
  814|       |    
  815|       |    /// The rectangle that defines the borders of the chart-value surface (into which the actual values are drawn).
  816|       |    @objc open var contentRect: CGRect
  817|      0|    {
  818|      0|        return _viewPortHandler.contentRect
  819|      0|    }
  820|       |    
  821|       |    /// - Returns: The ViewPortHandler of the chart that is responsible for the
  822|       |    /// content area of the chart and its offsets and dimensions.
  823|       |    @objc open var viewPortHandler: ViewPortHandler!
  824|      0|    {
  825|      0|        return _viewPortHandler
  826|      0|    }
  827|       |    
  828|       |    /// - Returns: The bitmap that represents the chart.
  829|       |    @objc open func getChartImage(transparent: Bool) -> NSUIImage?
  830|      0|    {
  831|      0|        NSUIGraphicsBeginImageContextWithOptions(bounds.size, isOpaque || !transparent, NSUIScreen.nsuiMain?.nsuiScale ?? 1.0)
  832|      0|        
  833|      0|        guard let context = NSUIGraphicsGetCurrentContext()
  834|      0|            else { return nil }
  835|      0|        
  836|      0|        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: bounds.size)
  837|      0|        
  838|      0|        if isOpaque || !transparent
  839|      0|        {
  840|      0|            // Background color may be partially transparent, we must fill with white if we want to output an opaque image
  841|      0|            context.setFillColor(NSUIColor.white.cgColor)
  842|      0|            context.fill(rect)
  843|      0|            
  844|      0|            if let backgroundColor = self.backgroundColor
  845|      0|            {
  846|      0|                context.setFillColor(backgroundColor.cgColor)
  847|      0|                context.fill(rect)
  848|      0|            }
  849|      0|        }
  850|      0|        
  851|      0|        nsuiLayer?.render(in: context)
  852|      0|        
  853|      0|        let image = NSUIGraphicsGetImageFromCurrentImageContext()
  854|      0|        
  855|      0|        NSUIGraphicsEndImageContext()
  856|      0|        
  857|      0|        return image
  858|      0|    }
  859|       |    
  860|       |    public enum ImageFormat
  861|       |    {
  862|       |        case jpeg
  863|       |        case png
  864|       |    }
  865|       |    
  866|       |    /// Saves the current chart state with the given name to the given path on
  867|       |    /// the sdcard leaving the path empty "" will put the saved file directly on
  868|       |    /// the SD card chart is saved as a PNG image, example:
  869|       |    /// saveToPath("myfilename", "foldername1/foldername2")
  870|       |    ///
  871|       |    /// - Parameters:
  872|       |    ///   - to: path to the image to save
  873|       |    ///   - format: the format to save
  874|       |    ///   - compressionQuality: compression quality for lossless formats (JPEG)
  875|       |    /// - Returns: `true` if the image was saved successfully
  876|       |    open func save(to path: String, format: ImageFormat, compressionQuality: Double) -> Bool
  877|      0|    {
  878|      0|        guard let image = getChartImage(transparent: format != .jpeg) else { return false }
  879|      0|        
  880|      0|        let imageData: Data?
  881|      0|        switch (format)
  882|      0|        {
  883|      0|        case .png: imageData = NSUIImagePNGRepresentation(image)
  884|      0|        case .jpeg: imageData = NSUIImageJPEGRepresentation(image, CGFloat(compressionQuality))
  885|      0|        }
  886|      0|        
  887|      0|        guard let data = imageData else { return false }
  888|      0|        
  889|      0|        do
  890|      0|        {
  891|      0|            try data.write(to: URL(fileURLWithPath: path), options: .atomic)
  892|      0|        }
  893|      0|        catch
  894|      0|        {
  895|      0|            return false
  896|      0|        }
  897|      0|        
  898|      0|        return true
  899|      0|    }
  900|       |    
  901|      0|    internal var _viewportJobs = [ViewPortJob]()
  902|       |    
  903|       |    open override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)
  904|      0|    {
  905|      0|        if keyPath == "bounds" || keyPath == "frame"
  906|      0|        {
  907|      0|            let bounds = self.bounds
  908|      0|            
  909|      0|            if (_viewPortHandler !== nil &&
  910|      0|                (bounds.size.width != _viewPortHandler.chartWidth ||
  911|      0|                bounds.size.height != _viewPortHandler.chartHeight))
  912|      0|            {
  913|      0|                _viewPortHandler.setChartDimens(width: bounds.size.width, height: bounds.size.height)
  914|      0|                
  915|      0|                // This may cause the chart view to mutate properties affecting the view port -- lets do this
  916|      0|                // before we try to run any pending jobs on the view port itself
  917|      0|                notifyDataSetChanged()
  918|      0|
  919|      0|                // Finish any pending viewport changes
  920|      0|                while (!_viewportJobs.isEmpty)
  921|      0|                {
  922|      0|                    let job = _viewportJobs.remove(at: 0)
  923|      0|                    job.doJob()
  924|      0|                }
  925|      0|            }
  926|      0|        }
  927|      0|    }
  928|       |    
  929|       |    @objc open func removeViewportJob(_ job: ViewPortJob)
  930|      0|    {
  931|      0|        if let index = _viewportJobs.firstIndex(where: { $0 === job })
  932|      0|        {
  933|      0|            _viewportJobs.remove(at: index)
  934|      0|        }
  935|      0|    }
  936|       |    
  937|       |    @objc open func clearAllViewportJobs()
  938|      0|    {
  939|      0|        _viewportJobs.removeAll(keepingCapacity: false)
  940|      0|    }
  941|       |    
  942|       |    @objc open func addViewportJob(_ job: ViewPortJob)
  943|      0|    {
  944|      0|        if _viewPortHandler.hasChartDimens
  945|      0|        {
  946|      0|            job.doJob()
  947|      0|        }
  948|      0|        else
  949|      0|        {
  950|      0|            _viewportJobs.append(job)
  951|      0|        }
  952|      0|    }
  953|       |    
  954|       |    /// **default**: true
  955|       |    /// `true` if chart continues to scroll after touch up, `false` ifnot.
  956|       |    @objc open var isDragDecelerationEnabled: Bool
  957|      0|        {
  958|      0|            return dragDecelerationEnabled
  959|      0|    }
  960|       |    
  961|       |    /// Deceleration friction coefficient in [0 ; 1] interval, higher values indicate that speed will decrease slowly, for example if it set to 0, it will stop immediately.
  962|       |    /// 1 is an invalid value, and will be converted to 0.999 automatically.
  963|       |    /// 
  964|       |    /// **default**: true
  965|       |    @objc open var dragDecelerationFrictionCoef: CGFloat
  966|       |    {
  967|       |        get
  968|      0|        {
  969|      0|            return _dragDecelerationFrictionCoef
  970|      0|        }
  971|       |        set
  972|      0|        {
  973|      0|            var val = newValue
  974|      0|            if val < 0.0
  975|      0|            {
  976|      0|                val = 0.0
  977|      0|            }
  978|      0|            if val >= 1.0
  979|      0|            {
  980|      0|                val = 0.999
  981|      0|            }
  982|      0|            
  983|      0|            _dragDecelerationFrictionCoef = val
  984|      0|        }
  985|       |    }
  986|       |    
  987|       |    /// The maximum distance in screen pixels away from an entry causing it to highlight.
  988|       |    /// **default**: 500.0
  989|       |    open var maxHighlightDistance: CGFloat = 500.0
  990|       |    
  991|       |    /// the number of maximum visible drawn values on the chart only active when `drawValuesEnabled` is enabled
  992|       |    open var maxVisibleCount: Int
  993|      0|    {
  994|      0|        return Int(INT_MAX)
  995|      0|    }
  996|       |    
  997|       |    // MARK: - AnimatorDelegate
  998|       |    
  999|       |    open func animatorUpdated(_ chartAnimator: Animator)
 1000|      0|    {
 1001|      0|        setNeedsDisplay()
 1002|      0|    }
 1003|       |    
 1004|       |    open func animatorStopped(_ chartAnimator: Animator)
 1005|      0|    {
 1006|      0|        delegate?.chartView?(self, animatorDidStop: chartAnimator)
 1007|      0|    }
 1008|       |    
 1009|       |    // MARK: - Touches
 1010|       |    
 1011|       |    open override func nsuiTouchesBegan(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
 1012|      0|    {
 1013|      0|        if !_interceptTouchEvents
 1014|      0|        {
 1015|      0|            super.nsuiTouchesBegan(touches, withEvent: event)
 1016|      0|        }
 1017|      0|    }
 1018|       |    
 1019|       |    open override func nsuiTouchesMoved(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
 1020|      0|    {
 1021|      0|        if !_interceptTouchEvents
 1022|      0|        {
 1023|      0|            super.nsuiTouchesMoved(touches, withEvent: event)
 1024|      0|        }
 1025|      0|    }
 1026|       |    
 1027|       |    open override func nsuiTouchesEnded(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
 1028|      0|    {
 1029|      0|        if !_interceptTouchEvents
 1030|      0|        {
 1031|      0|            super.nsuiTouchesEnded(touches, withEvent: event)
 1032|      0|        }
 1033|      0|    }
 1034|       |    
 1035|       |    open override func nsuiTouchesCancelled(_ touches: Set<NSUITouch>?, withEvent event: NSUIEvent?)
 1036|      0|    {
 1037|      0|        if !_interceptTouchEvents
 1038|      0|        {
 1039|      0|            super.nsuiTouchesCancelled(touches, withEvent: event)
 1040|      0|        }
 1041|      0|    }
 1042|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/CombinedChartView.swift:
    1|       |//
    2|       |//  CombinedChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// This chart class allows the combination of lines, bars, scatter and candle data all displayed in one chart area.
   16|       |open class CombinedChartView: BarLineChartViewBase, CombinedChartDataProvider
   17|       |{
   18|       |    /// the fill-formatter used for determining the position of the fill-line
   19|       |    internal var _fillFormatter: IFillFormatter!
   20|       |    
   21|       |    /// enum that allows to specify the order in which the different data objects for the combined-chart are drawn
   22|       |    @objc(CombinedChartDrawOrder)
   23|       |    public enum DrawOrder: Int
   24|       |    {
   25|       |        case bar
   26|       |        case bubble
   27|       |        case line
   28|       |        case candle
   29|       |        case scatter
   30|       |    }
   31|       |    
   32|       |    open override func initialize()
   33|      0|    {
   34|      0|        super.initialize()
   35|      0|        
   36|      0|        self.highlighter = CombinedHighlighter(chart: self, barDataProvider: self)
   37|      0|        
   38|      0|        // Old default behaviour
   39|      0|        self.highlightFullBarEnabled = true
   40|      0|        
   41|      0|        _fillFormatter = DefaultFillFormatter()
   42|      0|        
   43|      0|        renderer = CombinedChartRenderer(chart: self, animator: _animator, viewPortHandler: _viewPortHandler)
   44|      0|    }
   45|       |    
   46|       |    open override var data: ChartData?
   47|       |    {
   48|       |        get
   49|      0|        {
   50|      0|            return super.data
   51|      0|        }
   52|       |        set
   53|      0|        {
   54|      0|            super.data = newValue
   55|      0|            
   56|      0|            self.highlighter = CombinedHighlighter(chart: self, barDataProvider: self)
   57|      0|            
   58|      0|            (renderer as? CombinedChartRenderer)?.createRenderers()
   59|      0|            renderer?.initBuffers()
   60|      0|        }
   61|       |    }
   62|       |    
   63|       |    @objc open var fillFormatter: IFillFormatter
   64|       |    {
   65|       |        get
   66|      0|        {
   67|      0|            return _fillFormatter
   68|      0|        }
   69|       |        set
   70|      0|        {
   71|      0|            _fillFormatter = newValue
   72|      0|            if _fillFormatter == nil
   73|      0|            {
   74|      0|                _fillFormatter = DefaultFillFormatter()
   75|      0|            }
   76|      0|        }
   77|       |    }
   78|       |    
   79|       |    /// - Returns: The Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the CombinedChart.
   80|       |    open override func getHighlightByTouchPoint(_ pt: CGPoint) -> Highlight?
   81|      0|    {
   82|      0|        if _data === nil
   83|      0|        {
   84|      0|            Swift.print("Can't select by touch. No data set.")
   85|      0|            return nil
   86|      0|        }
   87|      0|        
   88|      0|        guard let h = self.highlighter?.getHighlight(x: pt.x, y: pt.y)
   89|      0|            else { return nil }
   90|      0|        
   91|      0|        if !isHighlightFullBarEnabled { return h }
   92|      0|        
   93|      0|        // For isHighlightFullBarEnabled, remove stackIndex
   94|      0|        return Highlight(
   95|      0|            x: h.x, y: h.y,
   96|      0|            xPx: h.xPx, yPx: h.yPx,
   97|      0|            dataIndex: h.dataIndex,
   98|      0|            dataSetIndex: h.dataSetIndex,
   99|      0|            stackIndex: -1,
  100|      0|            axis: h.axis)
  101|      0|    }
  102|       |    
  103|       |    // MARK: - CombinedChartDataProvider
  104|       |    
  105|       |    open var combinedData: CombinedChartData?
  106|       |    {
  107|       |        get
  108|      0|        {
  109|      0|            return _data as? CombinedChartData
  110|      0|        }
  111|       |    }
  112|       |    
  113|       |    // MARK: - LineChartDataProvider
  114|       |    
  115|       |    open var lineData: LineChartData?
  116|       |    {
  117|       |        get
  118|      0|        {
  119|      0|            return combinedData?.lineData
  120|      0|        }
  121|       |    }
  122|       |    
  123|       |    // MARK: - BarChartDataProvider
  124|       |    
  125|       |    open var barData: BarChartData?
  126|       |    {
  127|       |        get
  128|      0|        {
  129|      0|            return combinedData?.barData
  130|      0|        }
  131|       |    }
  132|       |    
  133|       |    // MARK: - ScatterChartDataProvider
  134|       |    
  135|       |    open var scatterData: ScatterChartData?
  136|       |    {
  137|       |        get
  138|      0|        {
  139|      0|            return combinedData?.scatterData
  140|      0|        }
  141|       |    }
  142|       |    
  143|       |    // MARK: - CandleChartDataProvider
  144|       |    
  145|       |    open var candleData: CandleChartData?
  146|       |    {
  147|       |        get
  148|      0|        {
  149|      0|            return combinedData?.candleData
  150|      0|        }
  151|       |    }
  152|       |    
  153|       |    // MARK: - BubbleChartDataProvider
  154|       |    
  155|       |    open var bubbleData: BubbleChartData?
  156|       |    {
  157|       |        get
  158|      0|        {
  159|      0|            return combinedData?.bubbleData
  160|      0|        }
  161|       |    }
  162|       |    
  163|       |    // MARK: - Accessors
  164|       |    
  165|       |    /// if set to true, all values are drawn above their bars, instead of below their top
  166|       |    @objc open var drawValueAboveBarEnabled: Bool
  167|       |        {
  168|      0|        get { return (renderer as! CombinedChartRenderer).drawValueAboveBarEnabled }
  169|      0|        set { (renderer as! CombinedChartRenderer).drawValueAboveBarEnabled = newValue }
  170|       |    }
  171|       |    
  172|       |    /// if set to true, a grey area is drawn behind each bar that indicates the maximum value
  173|       |    @objc open var drawBarShadowEnabled: Bool
  174|       |    {
  175|      0|        get { return (renderer as! CombinedChartRenderer).drawBarShadowEnabled }
  176|      0|        set { (renderer as! CombinedChartRenderer).drawBarShadowEnabled = newValue }
  177|       |    }
  178|       |    
  179|       |    /// `true` if drawing values above bars is enabled, `false` ifnot
  180|      0|    open var isDrawValueAboveBarEnabled: Bool { return (renderer as! CombinedChartRenderer).drawValueAboveBarEnabled }
  181|       |    
  182|       |    /// `true` if drawing shadows (maxvalue) for each bar is enabled, `false` ifnot
  183|      0|    open var isDrawBarShadowEnabled: Bool { return (renderer as! CombinedChartRenderer).drawBarShadowEnabled }
  184|       |    
  185|       |    /// the order in which the provided data objects should be drawn.
  186|       |    /// The earlier you place them in the provided array, the further they will be in the background. 
  187|       |    /// e.g. if you provide [DrawOrder.Bar, DrawOrder.Line], the bars will be drawn behind the lines.
  188|       |    @objc open var drawOrder: [Int]
  189|       |    {
  190|       |        get
  191|      0|        {
  192|      0|            return (renderer as! CombinedChartRenderer).drawOrder.map { $0.rawValue }
  193|      0|        }
  194|       |        set
  195|      0|        {
  196|      0|            (renderer as! CombinedChartRenderer).drawOrder = newValue.map { DrawOrder(rawValue: $0)! }
  197|      0|        }
  198|       |    }
  199|       |    
  200|       |    /// Set this to `true` to make the highlight operation full-bar oriented, `false` to make it highlight single values
  201|       |    @objc open var highlightFullBarEnabled: Bool = false
  202|       |    
  203|       |    /// `true` the highlight is be full-bar oriented, `false` ifsingle-value
  204|      0|    open var isHighlightFullBarEnabled: Bool { return highlightFullBarEnabled }
  205|       |    
  206|       |    // MARK: - ChartViewBase
  207|       |    
  208|       |    /// draws all MarkerViews on the highlighted positions
  209|       |    override func drawMarkers(context: CGContext)
  210|      0|    {
  211|      0|        guard
  212|      0|            let marker = marker, 
  213|      0|            isDrawMarkersEnabled && valuesToHighlight()
  214|      0|            else { return }
  215|      0|        
  216|      0|        for i in 0 ..< _indicesToHighlight.count
  217|      0|        {
  218|      0|            let highlight = _indicesToHighlight[i]
  219|      0|            
  220|      0|            guard 
  221|      0|                let set = combinedData?.getDataSetByHighlight(highlight),
  222|      0|                let e = _data?.entryForHighlight(highlight)
  223|      0|                else { continue }
  224|      0|            
  225|      0|            let entryIndex = set.entryIndex(entry: e)
  226|      0|            if entryIndex > Int(Double(set.entryCount) * _animator.phaseX)
  227|      0|            {
  228|      0|                continue
  229|      0|            }
  230|      0|            
  231|      0|            let pos = getMarkerPosition(highlight: highlight)
  232|      0|            
  233|      0|            // check bounds
  234|      0|            if !_viewPortHandler.isInBounds(x: pos.x, y: pos.y)
  235|      0|            {
  236|      0|                continue
  237|      0|            }
  238|      0|            
  239|      0|            // callbacks to update the content
  240|      0|            marker.refreshContent(entry: e, highlight: highlight)
  241|      0|            
  242|      0|            // draw the marker
  243|      0|            marker.draw(context: context, point: pos)
  244|      0|        }
  245|      0|    }
  246|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/HorizontalBarChartView.swift:
    1|       |//
    2|       |//  HorizontalBarChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// BarChart with horizontal bar orientation. In this implementation, x- and y-axis are switched.
   16|       |open class HorizontalBarChartView: BarChartView
   17|       |{
   18|       |    internal override func initialize()
   19|      0|    {
   20|      0|        super.initialize()
   21|      0|        
   22|      0|        _leftAxisTransformer = TransformerHorizontalBarChart(viewPortHandler: _viewPortHandler)
   23|      0|        _rightAxisTransformer = TransformerHorizontalBarChart(viewPortHandler: _viewPortHandler)
   24|      0|        
   25|      0|        renderer = HorizontalBarChartRenderer(dataProvider: self, animator: _animator, viewPortHandler: _viewPortHandler)
   26|      0|        leftYAxisRenderer = YAxisRendererHorizontalBarChart(viewPortHandler: _viewPortHandler, yAxis: leftAxis, transformer: _leftAxisTransformer)
   27|      0|        rightYAxisRenderer = YAxisRendererHorizontalBarChart(viewPortHandler: _viewPortHandler, yAxis: rightAxis, transformer: _rightAxisTransformer)
   28|      0|        xAxisRenderer = XAxisRendererHorizontalBarChart(viewPortHandler: _viewPortHandler, xAxis: _xAxis, transformer: _leftAxisTransformer, chart: self)
   29|      0|        
   30|      0|        self.highlighter = HorizontalBarHighlighter(chart: self)
   31|      0|    }
   32|       |    
   33|       |    internal override func calculateLegendOffsets(offsetLeft: inout CGFloat, offsetTop: inout CGFloat, offsetRight: inout CGFloat, offsetBottom: inout CGFloat)
   34|      0|    {
   35|      0|        guard
   36|      0|            let legend = _legend,
   37|      0|            legend.isEnabled,
   38|      0|            !legend.drawInside
   39|      0|        else { return }
   40|      0|        
   41|      0|        // setup offsets for legend
   42|      0|        switch legend.orientation
   43|      0|        {
   44|      0|        case .vertical:
   45|      0|            switch legend.horizontalAlignment
   46|      0|            {
   47|      0|            case .left:
   48|      0|                offsetLeft += min(legend.neededWidth, _viewPortHandler.chartWidth * legend.maxSizePercent) + legend.xOffset
   49|      0|                
   50|      0|            case .right:
   51|      0|                offsetRight += min(legend.neededWidth, _viewPortHandler.chartWidth * legend.maxSizePercent) + legend.xOffset
   52|      0|                
   53|      0|            case .center:
   54|      0|                
   55|      0|                switch legend.verticalAlignment
   56|      0|                {
   57|      0|                case .top:
   58|      0|                    offsetTop += min(legend.neededHeight, _viewPortHandler.chartHeight * legend.maxSizePercent) + legend.yOffset
   59|      0|                    
   60|      0|                case .bottom:
   61|      0|                    offsetBottom += min(legend.neededHeight, _viewPortHandler.chartHeight * legend.maxSizePercent) + legend.yOffset
   62|      0|                    
   63|      0|                default:
   64|      0|                    break
   65|      0|                }
   66|      0|            }
   67|      0|            
   68|      0|        case .horizontal:
   69|      0|            switch legend.verticalAlignment
   70|      0|            {
   71|      0|            case .top:
   72|      0|                offsetTop += min(legend.neededHeight, _viewPortHandler.chartHeight * legend.maxSizePercent) + legend.yOffset
   73|      0|                
   74|      0|                // left axis equals the top x-axis in a horizontal chart
   75|      0|                if leftAxis.isEnabled && leftAxis.isDrawLabelsEnabled
   76|      0|                {
   77|      0|                    offsetTop += leftAxis.getRequiredHeightSpace()
   78|      0|                }
   79|      0|                
   80|      0|            case .bottom:
   81|      0|                offsetBottom += min(legend.neededHeight, _viewPortHandler.chartHeight * legend.maxSizePercent) + legend.yOffset
   82|      0|
   83|      0|                // right axis equals the bottom x-axis in a horizontal chart
   84|      0|                if rightAxis.isEnabled && rightAxis.isDrawLabelsEnabled
   85|      0|                {
   86|      0|                    offsetBottom += rightAxis.getRequiredHeightSpace()
   87|      0|                }
   88|      0|            default:
   89|      0|                break
   90|      0|            }
   91|      0|        }
   92|      0|    }
   93|       |    
   94|       |    internal override func calculateOffsets()
   95|      0|    {
   96|      0|        var offsetLeft: CGFloat = 0.0,
   97|      0|        offsetRight: CGFloat = 0.0,
   98|      0|        offsetTop: CGFloat = 0.0,
   99|      0|        offsetBottom: CGFloat = 0.0
  100|      0|        
  101|      0|        calculateLegendOffsets(offsetLeft: &offsetLeft,
  102|      0|                               offsetTop: &offsetTop,
  103|      0|                               offsetRight: &offsetRight,
  104|      0|                               offsetBottom: &offsetBottom)
  105|      0|        
  106|      0|        // offsets for y-labels
  107|      0|        if leftAxis.needsOffset
  108|      0|        {
  109|      0|            offsetTop += leftAxis.getRequiredHeightSpace()
  110|      0|        }
  111|      0|        
  112|      0|        if rightAxis.needsOffset
  113|      0|        {
  114|      0|            offsetBottom += rightAxis.getRequiredHeightSpace()
  115|      0|        }
  116|      0|        
  117|      0|        let xlabelwidth = _xAxis.labelRotatedWidth
  118|      0|        
  119|      0|        if _xAxis.isEnabled
  120|      0|        {
  121|      0|            // offsets for x-labels
  122|      0|            if _xAxis.labelPosition == .bottom
  123|      0|            {
  124|      0|                offsetLeft += xlabelwidth
  125|      0|            }
  126|      0|            else if _xAxis.labelPosition == .top
  127|      0|            {
  128|      0|                offsetRight += xlabelwidth
  129|      0|            }
  130|      0|            else if _xAxis.labelPosition == .bothSided
  131|      0|            {
  132|      0|                offsetLeft += xlabelwidth
  133|      0|                offsetRight += xlabelwidth
  134|      0|            }
  135|      0|        }
  136|      0|        
  137|      0|        offsetTop += self.extraTopOffset
  138|      0|        offsetRight += self.extraRightOffset
  139|      0|        offsetBottom += self.extraBottomOffset
  140|      0|        offsetLeft += self.extraLeftOffset
  141|      0|
  142|      0|        _viewPortHandler.restrainViewPort(
  143|      0|            offsetLeft: max(self.minOffset, offsetLeft),
  144|      0|            offsetTop: max(self.minOffset, offsetTop),
  145|      0|            offsetRight: max(self.minOffset, offsetRight),
  146|      0|            offsetBottom: max(self.minOffset, offsetBottom))
  147|      0|        
  148|      0|        prepareOffsetMatrix()
  149|      0|        prepareValuePxMatrix()
  150|      0|    }
  151|       |    
  152|       |    internal override func prepareValuePxMatrix()
  153|      0|    {
  154|      0|        _rightAxisTransformer.prepareMatrixValuePx(chartXMin: rightAxis._axisMinimum, deltaX: CGFloat(rightAxis.axisRange), deltaY: CGFloat(_xAxis.axisRange), chartYMin: _xAxis._axisMinimum)
  155|      0|        _leftAxisTransformer.prepareMatrixValuePx(chartXMin: leftAxis._axisMinimum, deltaX: CGFloat(leftAxis.axisRange), deltaY: CGFloat(_xAxis.axisRange), chartYMin: _xAxis._axisMinimum)
  156|      0|    }
  157|       |    
  158|       |    open override func getMarkerPosition(highlight: Highlight) -> CGPoint
  159|      0|    {
  160|      0|        return CGPoint(x: highlight.drawY, y: highlight.drawX)
  161|      0|    }
  162|       |    
  163|       |    open override func getBarBounds(entry e: BarChartDataEntry) -> CGRect
  164|      0|    {
  165|      0|        guard
  166|      0|            let data = _data as? BarChartData,
  167|      0|            let set = data.getDataSetForEntry(e) as? IBarChartDataSet
  168|      0|            else { return CGRect.null }
  169|      0|        
  170|      0|        let y = e.y
  171|      0|        let x = e.x
  172|      0|        
  173|      0|        let barWidth = data.barWidth
  174|      0|        
  175|      0|        let top = x - 0.5 + barWidth / 2.0
  176|      0|        let bottom = x + 0.5 - barWidth / 2.0
  177|      0|        let left = y >= 0.0 ? y : 0.0
  178|      0|        let right = y <= 0.0 ? y : 0.0
  179|      0|        
  180|      0|        var bounds = CGRect(x: left, y: top, width: right - left, height: bottom - top)
  181|      0|        
  182|      0|        getTransformer(forAxis: set.axisDependency).rectValueToPixel(&bounds)
  183|      0|        
  184|      0|        return bounds
  185|      0|    }
  186|       |    
  187|       |    open override func getPosition(entry e: ChartDataEntry, axis: YAxis.AxisDependency) -> CGPoint
  188|      0|    {
  189|      0|        var vals = CGPoint(x: CGFloat(e.y), y: CGFloat(e.x))
  190|      0|        
  191|      0|        getTransformer(forAxis: axis).pointValueToPixel(&vals)
  192|      0|        
  193|      0|        return vals
  194|      0|    }
  195|       |
  196|       |    open override func getHighlightByTouchPoint(_ pt: CGPoint) -> Highlight?
  197|      0|    {
  198|      0|        if _data === nil
  199|      0|        {
  200|      0|            Swift.print("Can't select by touch. No data set.", terminator: "\n")
  201|      0|            return nil
  202|      0|        }
  203|      0|        
  204|      0|        return self.highlighter?.getHighlight(x: pt.y, y: pt.x)
  205|      0|    }
  206|       |    
  207|       |    /// The lowest x-index (value on the x-axis) that is still visible on he chart.
  208|       |    open override var lowestVisibleX: Double
  209|      0|    {
  210|      0|        var pt = CGPoint(
  211|      0|            x: viewPortHandler.contentLeft,
  212|      0|            y: viewPortHandler.contentBottom)
  213|      0|        
  214|      0|        getTransformer(forAxis: .left).pixelToValues(&pt)
  215|      0|        
  216|      0|        return max(xAxis._axisMinimum, Double(pt.y))
  217|      0|    }
  218|       |    
  219|       |    /// The highest x-index (value on the x-axis) that is still visible on the chart.
  220|       |    open override var highestVisibleX: Double
  221|      0|    {
  222|      0|        var pt = CGPoint(
  223|      0|            x: viewPortHandler.contentLeft,
  224|      0|            y: viewPortHandler.contentTop)
  225|      0|        
  226|      0|        getTransformer(forAxis: .left).pixelToValues(&pt)
  227|      0|        
  228|      0|        return min(xAxis._axisMaximum, Double(pt.y))
  229|      0|    }
  230|       |    
  231|       |    // MARK: - Viewport
  232|       |    
  233|       |    open override func setVisibleXRangeMaximum(_ maxXRange: Double)
  234|      0|    {
  235|      0|        let xScale = xAxis.axisRange / maxXRange
  236|      0|        viewPortHandler.setMinimumScaleY(CGFloat(xScale))
  237|      0|    }
  238|       |    
  239|       |    open override func setVisibleXRangeMinimum(_ minXRange: Double)
  240|      0|    {
  241|      0|        let xScale = xAxis.axisRange / minXRange
  242|      0|        viewPortHandler.setMaximumScaleY(CGFloat(xScale))
  243|      0|    }
  244|       |    
  245|       |    open override func setVisibleXRange(minXRange: Double, maxXRange: Double)
  246|      0|    {
  247|      0|        let minScale = xAxis.axisRange / minXRange
  248|      0|        let maxScale = xAxis.axisRange / maxXRange
  249|      0|        viewPortHandler.setMinMaxScaleY(minScaleY: CGFloat(minScale), maxScaleY: CGFloat(maxScale))
  250|      0|    }
  251|       |    
  252|       |    open override func setVisibleYRangeMaximum(_ maxYRange: Double, axis: YAxis.AxisDependency)
  253|      0|    {
  254|      0|        let yScale = getAxisRange(axis: axis) / maxYRange
  255|      0|        viewPortHandler.setMinimumScaleX(CGFloat(yScale))
  256|      0|    }
  257|       |    
  258|       |    open override func setVisibleYRangeMinimum(_ minYRange: Double, axis: YAxis.AxisDependency)
  259|      0|    {
  260|      0|        let yScale = getAxisRange(axis: axis) / minYRange
  261|      0|        viewPortHandler.setMaximumScaleX(CGFloat(yScale))
  262|      0|    }
  263|       |    
  264|       |    open override func setVisibleYRange(minYRange: Double, maxYRange: Double, axis: YAxis.AxisDependency)
  265|      0|    {
  266|      0|        let minScale = getAxisRange(axis: axis) / minYRange
  267|      0|        let maxScale = getAxisRange(axis: axis) / maxYRange
  268|      0|        viewPortHandler.setMinMaxScaleX(minScaleX: CGFloat(minScale), maxScaleX: CGFloat(maxScale))
  269|      0|    }
  270|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/LineChartView.swift:
    1|       |//
    2|       |//  LineChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// Chart that draws lines, surfaces, circles, ...
   16|       |open class LineChartView: BarLineChartViewBase, LineChartDataProvider
   17|       |{
   18|       |    internal override func initialize()
   19|      0|    {
   20|      0|        super.initialize()
   21|      0|        
   22|      0|        renderer = LineChartRenderer(dataProvider: self, animator: _animator, viewPortHandler: _viewPortHandler)
   23|      0|    }
   24|       |    
   25|       |    // MARK: - LineChartDataProvider
   26|       |    
   27|      0|    open var lineData: LineChartData? { return _data as? LineChartData }
   28|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/PieChartView.swift:
    1|       |//
    2|       |//  PieChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |/// View that represents a pie chart. Draws cake like slices.
   24|       |open class PieChartView: PieRadarChartViewBase
   25|       |{
   26|       |    /// rect object that represents the bounds of the piechart, needed for drawing the circle
   27|      0|    private var _circleBox = CGRect()
   28|       |    
   29|       |    /// flag indicating if entry labels should be drawn or not
   30|       |    private var _drawEntryLabelsEnabled = true
   31|       |    
   32|       |    /// array that holds the width of each pie-slice in degrees
   33|      0|    private var _drawAngles = [CGFloat]()
   34|       |    
   35|       |    /// array that holds the absolute angle in degrees of each slice
   36|      0|    private var _absoluteAngles = [CGFloat]()
   37|       |    
   38|       |    /// if true, the hole inside the chart will be drawn
   39|       |    private var _drawHoleEnabled = true
   40|       |    
   41|      0|    private var _holeColor: NSUIColor? = NSUIColor.white
   42|       |    
   43|       |    /// Sets the color the entry labels are drawn with.
   44|      0|    private var _entryLabelColor: NSUIColor? = NSUIColor.white
   45|       |    
   46|       |    /// Sets the font the entry labels are drawn with.
   47|      0|    private var _entryLabelFont: NSUIFont? = NSUIFont(name: "HelveticaNeue", size: 13.0)
   48|       |    
   49|       |    /// if true, the hole will see-through to the inner tips of the slices
   50|       |    private var _drawSlicesUnderHoleEnabled = false
   51|       |    
   52|       |    /// if true, the values inside the piechart are drawn as percent values
   53|       |    private var _usePercentValuesEnabled = false
   54|       |    
   55|       |    /// variable for the text that is drawn in the center of the pie-chart
   56|       |    private var _centerAttributedText: NSAttributedString?
   57|       |    
   58|       |    /// the offset on the x- and y-axis the center text has in dp.
   59|      0|    private var _centerTextOffset: CGPoint = CGPoint()
   60|       |    
   61|       |    /// indicates the size of the hole in the center of the piechart
   62|       |    ///
   63|       |    /// **default**: `0.5`
   64|      0|    private var _holeRadiusPercent = CGFloat(0.5)
   65|       |    
   66|      0|    private var _transparentCircleColor: NSUIColor? = NSUIColor(white: 1.0, alpha: 105.0/255.0)
   67|       |    
   68|       |    /// the radius of the transparent circle next to the chart-hole in the center
   69|      0|    private var _transparentCircleRadiusPercent = CGFloat(0.55)
   70|       |    
   71|       |    /// if enabled, centertext is drawn
   72|       |    private var _drawCenterTextEnabled = true
   73|       |    
   74|       |    private var _centerTextRadiusPercent: CGFloat = 1.0
   75|       |    
   76|       |    /// maximum angle for this pie
   77|       |    private var _maxAngle: CGFloat = 360.0
   78|       |
   79|       |    public override init(frame: CGRect)
   80|      0|    {
   81|      0|        super.init(frame: frame)
   82|      0|    }
   83|       |    
   84|       |    public required init?(coder aDecoder: NSCoder)
   85|      0|    {
   86|      0|        super.init(coder: aDecoder)
   87|      0|    }
   88|       |    
   89|       |    internal override func initialize()
   90|      0|    {
   91|      0|        super.initialize()
   92|      0|        
   93|      0|        renderer = PieChartRenderer(chart: self, animator: _animator, viewPortHandler: _viewPortHandler)
   94|      0|        _xAxis = nil
   95|      0|        
   96|      0|        self.highlighter = PieHighlighter(chart: self)
   97|      0|    }
   98|       |    
   99|       |    open override func draw(_ rect: CGRect)
  100|      0|    {
  101|      0|        super.draw(rect)
  102|      0|        
  103|      0|        if _data === nil
  104|      0|        {
  105|      0|            return
  106|      0|        }
  107|      0|        
  108|      0|        let optionalContext = NSUIGraphicsGetCurrentContext()
  109|      0|        guard let context = optionalContext, let renderer = renderer else
  110|      0|        {
  111|      0|            return
  112|      0|        }
  113|      0|        
  114|      0|        renderer.drawData(context: context)
  115|      0|        
  116|      0|        if (valuesToHighlight())
  117|      0|        {
  118|      0|            renderer.drawHighlighted(context: context, indices: _indicesToHighlight)
  119|      0|        }
  120|      0|        
  121|      0|        renderer.drawExtras(context: context)
  122|      0|        
  123|      0|        renderer.drawValues(context: context)
  124|      0|        
  125|      0|        legendRenderer.renderLegend(context: context)
  126|      0|        
  127|      0|        drawDescription(context: context)
  128|      0|        
  129|      0|        drawMarkers(context: context)
  130|      0|    }
  131|       |
  132|       |    /// if width is larger than height
  133|       |    private var widthLarger: Bool
  134|      0|    {
  135|      0|        return _viewPortHandler.contentRect.orientation == .landscape
  136|      0|    }
  137|       |
  138|       |    /// adjusted radius. Use diameter when it's half pie and width is larger
  139|       |    private var adjustedRadius: CGFloat
  140|      0|    {
  141|      0|        return maxAngle <= 180 && widthLarger ? diameter : diameter / 2.0
  142|      0|    }
  143|       |
  144|       |    /// true centerOffsets considering half pie & width is larger
  145|       |    private func adjustedCenterOffsets() -> CGPoint
  146|      0|    {
  147|      0|        var c = self.centerOffsets
  148|      0|        c.y = maxAngle <= 180 && widthLarger ? c.y + adjustedRadius / 2 : c.y
  149|      0|        return c
  150|      0|    }
  151|       |    
  152|       |    internal override func calculateOffsets()
  153|      0|    {
  154|      0|        super.calculateOffsets()
  155|      0|        
  156|      0|        // prevent nullpointer when no data set
  157|      0|        if _data === nil
  158|      0|        {
  159|      0|            return
  160|      0|        }
  161|      0|
  162|      0|        let radius = adjustedRadius
  163|      0|        
  164|      0|        let c = adjustedCenterOffsets()
  165|      0|        
  166|      0|        let shift = (data as? PieChartData)?.dataSet?.selectionShift ?? 0.0
  167|      0|        
  168|      0|        // create the circle box that will contain the pie-chart (the bounds of the pie-chart)
  169|      0|        _circleBox.origin.x = (c.x - radius) + shift
  170|      0|        _circleBox.origin.y = (c.y - radius) + shift
  171|      0|        _circleBox.size.width = radius * 2 - shift * 2.0
  172|      0|        _circleBox.size.height = radius * 2 - shift * 2.0
  173|      0|
  174|      0|    }
  175|       |
  176|       |    internal override func calcMinMax()
  177|      0|    {
  178|      0|        calcAngles()
  179|      0|    }
  180|       |
  181|       |    @objc open override func angleForPoint(x: CGFloat, y: CGFloat) -> CGFloat
  182|      0|    {
  183|      0|        let c = adjustedCenterOffsets()
  184|      0|
  185|      0|        let tx = Double(x - c.x)
  186|      0|        let ty = Double(y - c.y)
  187|      0|        let length = sqrt(tx * tx + ty * ty)
  188|      0|        let r = acos(ty / length)
  189|      0|
  190|      0|        var angle = r.RAD2DEG
  191|      0|
  192|      0|        if x > c.x
  193|      0|        {
  194|      0|            angle = 360.0 - angle
  195|      0|        }
  196|      0|
  197|      0|        // add 90° because chart starts EAST
  198|      0|        angle = angle + 90.0
  199|      0|
  200|      0|        // neutralize overflow
  201|      0|        if angle > 360.0
  202|      0|        {
  203|      0|            angle = angle - 360.0
  204|      0|        }
  205|      0|
  206|      0|        return CGFloat(angle)
  207|      0|    }
  208|       |
  209|       |    /// - Returns: The distance of a certain point on the chart to the center of the chart.
  210|       |    @objc open override func distanceToCenter(x: CGFloat, y: CGFloat) -> CGFloat
  211|      0|    {
  212|      0|        let c = adjustedCenterOffsets()
  213|      0|
  214|      0|        var dist = CGFloat(0.0)
  215|      0|
  216|      0|        var xDist = CGFloat(0.0)
  217|      0|        var yDist = CGFloat(0.0)
  218|      0|
  219|      0|        if x > c.x
  220|      0|        {
  221|      0|            xDist = x - c.x
  222|      0|        }
  223|      0|        else
  224|      0|        {
  225|      0|            xDist = c.x - x
  226|      0|        }
  227|      0|
  228|      0|        if y > c.y
  229|      0|        {
  230|      0|            yDist = y - c.y
  231|      0|        }
  232|      0|        else
  233|      0|        {
  234|      0|            yDist = c.y - y
  235|      0|        }
  236|      0|
  237|      0|        // pythagoras
  238|      0|        dist = sqrt(pow(xDist, 2.0) + pow(yDist, 2.0))
  239|      0|
  240|      0|        return dist
  241|      0|    }
  242|       |
  243|       |    open override func getMarkerPosition(highlight: Highlight) -> CGPoint
  244|      0|    {
  245|      0|        let center = self.centerCircleBox
  246|      0|        var r = self.radius
  247|      0|        
  248|      0|        var off = r / 10.0 * 3.6
  249|      0|        
  250|      0|        if self.isDrawHoleEnabled
  251|      0|        {
  252|      0|            off = (r - (r * self.holeRadiusPercent)) / 2.0
  253|      0|        }
  254|      0|        
  255|      0|        r -= off // offset to keep things inside the chart
  256|      0|        
  257|      0|        let rotationAngle = self.rotationAngle
  258|      0|        
  259|      0|        let entryIndex = Int(highlight.x)
  260|      0|        
  261|      0|        // offset needed to center the drawn text in the slice
  262|      0|        let offset = drawAngles[entryIndex] / 2.0
  263|      0|        
  264|      0|        // calculate the text position
  265|      0|        let x: CGFloat = (r * cos(((rotationAngle + absoluteAngles[entryIndex] - offset) * CGFloat(_animator.phaseY)).DEG2RAD) + center.x)
  266|      0|        let y: CGFloat = (r * sin(((rotationAngle + absoluteAngles[entryIndex] - offset) * CGFloat(_animator.phaseY)).DEG2RAD) + center.y)
  267|      0|        
  268|      0|        return CGPoint(x: x, y: y)
  269|      0|    }
  270|       |    
  271|       |    /// calculates the needed angles for the chart slices
  272|       |    private func calcAngles()
  273|      0|    {
  274|      0|        _drawAngles = [CGFloat]()
  275|      0|        _absoluteAngles = [CGFloat]()
  276|      0|        
  277|      0|        guard let data = _data else { return }
  278|      0|
  279|      0|        let entryCount = data.entryCount
  280|      0|        
  281|      0|        _drawAngles.reserveCapacity(entryCount)
  282|      0|        _absoluteAngles.reserveCapacity(entryCount)
  283|      0|        
  284|      0|        let yValueSum = (_data as! PieChartData).yValueSum
  285|      0|
  286|      0|        var cnt = 0
  287|      0|
  288|      0|        for set in data.dataSets
  289|      0|        {
  290|      0|            for j in 0 ..< set.entryCount
  291|      0|            {
  292|      0|                guard let e = set.entryForIndex(j) else { continue }
  293|      0|                
  294|      0|                _drawAngles.append(calcAngle(value: abs(e.y), yValueSum: yValueSum))
  295|      0|
  296|      0|                if cnt == 0
  297|      0|                {
  298|      0|                    _absoluteAngles.append(_drawAngles[cnt])
  299|      0|                }
  300|      0|                else
  301|      0|                {
  302|      0|                    _absoluteAngles.append(_absoluteAngles[cnt - 1] + _drawAngles[cnt])
  303|      0|                }
  304|      0|
  305|      0|                cnt += 1
  306|      0|            }
  307|      0|        }
  308|      0|    }
  309|       |    
  310|       |    /// Checks if the given index is set to be highlighted.
  311|       |    @objc open func needsHighlight(index: Int) -> Bool
  312|      0|    {
  313|      0|        return _indicesToHighlight.contains { Int($0.x) == index }
  314|      0|    }
  315|       |    
  316|       |    /// calculates the needed angle for a given value
  317|       |    private func calcAngle(_ value: Double) -> CGFloat
  318|      0|    {
  319|      0|        return calcAngle(value: value, yValueSum: (_data as! PieChartData).yValueSum)
  320|      0|    }
  321|       |    
  322|       |    /// calculates the needed angle for a given value
  323|       |    private func calcAngle(value: Double, yValueSum: Double) -> CGFloat
  324|      0|    {
  325|      0|        return CGFloat(value) / CGFloat(yValueSum) * _maxAngle
  326|      0|    }
  327|       |    
  328|       |    /// This will throw an exception, PieChart has no XAxis object.
  329|       |    open override var xAxis: XAxis
  330|      0|    {
  331|      0|        fatalError("PieChart has no XAxis")
  332|      0|    }
  333|       |
  334|       |    open override func indexForAngle(_ angle: CGFloat) -> Int
  335|      0|    {
  336|      0|        // TODO: Return nil instead of -1
  337|      0|        // take the current angle of the chart into consideration
  338|      0|        let a = (angle - self.rotationAngle).normalizedAngle
  339|      0|        return _absoluteAngles.firstIndex { $0 > a } ?? -1
  340|      0|    }
  341|       |    
  342|       |    /// - Returns: The index of the DataSet this x-index belongs to.
  343|       |    @objc open func dataSetIndexForIndex(_ xValue: Double) -> Int
  344|      0|    {
  345|      0|        // TODO: Return nil instead of -1
  346|      0|        return _data?.dataSets.firstIndex {
  347|      0|            $0.entryForXValue(xValue, closestToY: .nan) != nil
  348|      0|        } ?? -1
  349|      0|    }
  350|       |    
  351|       |    /// - Returns: An integer array of all the different angles the chart slices
  352|       |    /// have the angles in the returned array determine how much space (of 360°)
  353|       |    /// each slice takes
  354|       |    @objc open var drawAngles: [CGFloat]
  355|      0|    {
  356|      0|        return _drawAngles
  357|      0|    }
  358|       |
  359|       |    /// - Returns: The absolute angles of the different chart slices (where the
  360|       |    /// slices end)
  361|       |    @objc open var absoluteAngles: [CGFloat]
  362|      0|    {
  363|      0|        return _absoluteAngles
  364|      0|    }
  365|       |    
  366|       |    /// The color for the hole that is drawn in the center of the PieChart (if enabled).
  367|       |    /// 
  368|       |    /// - Note: Use holeTransparent with holeColor = nil to make the hole transparent.*
  369|       |    @objc open var holeColor: NSUIColor?
  370|       |    {
  371|       |        get
  372|      0|        {
  373|      0|            return _holeColor
  374|      0|        }
  375|       |        set
  376|      0|        {
  377|      0|            _holeColor = newValue
  378|      0|            setNeedsDisplay()
  379|      0|        }
  380|       |    }
  381|       |    
  382|       |    /// if true, the hole will see-through to the inner tips of the slices
  383|       |    ///
  384|       |    /// **default**: `false`
  385|       |    @objc open var drawSlicesUnderHoleEnabled: Bool
  386|       |    {
  387|       |        get
  388|      0|        {
  389|      0|            return _drawSlicesUnderHoleEnabled
  390|      0|        }
  391|       |        set
  392|      0|        {
  393|      0|            _drawSlicesUnderHoleEnabled = newValue
  394|      0|            setNeedsDisplay()
  395|      0|        }
  396|       |    }
  397|       |    
  398|       |    /// `true` if the inner tips of the slices are visible behind the hole, `false` if not.
  399|       |    @objc open var isDrawSlicesUnderHoleEnabled: Bool
  400|      0|    {
  401|      0|        return drawSlicesUnderHoleEnabled
  402|      0|    }
  403|       |    
  404|       |    /// `true` if the hole in the center of the pie-chart is set to be visible, `false` ifnot
  405|       |    @objc open var drawHoleEnabled: Bool
  406|       |    {
  407|       |        get
  408|      0|        {
  409|      0|            return _drawHoleEnabled
  410|      0|        }
  411|       |        set
  412|      0|        {
  413|      0|            _drawHoleEnabled = newValue
  414|      0|            setNeedsDisplay()
  415|      0|        }
  416|       |    }
  417|       |    
  418|       |    /// `true` if the hole in the center of the pie-chart is set to be visible, `false` ifnot
  419|       |    @objc open var isDrawHoleEnabled: Bool
  420|       |    {
  421|       |        get
  422|      0|        {
  423|      0|            return drawHoleEnabled
  424|      0|        }
  425|       |    }
  426|       |    
  427|       |    /// the text that is displayed in the center of the pie-chart
  428|       |    @objc open var centerText: String?
  429|       |    {
  430|       |        get
  431|      0|        {
  432|      0|            return self.centerAttributedText?.string
  433|      0|        }
  434|       |        set
  435|      0|        {
  436|      0|            var attrString: NSMutableAttributedString?
  437|      0|            if newValue == nil
  438|      0|            {
  439|      0|                attrString = nil
  440|      0|            }
  441|      0|            else
  442|      0|            {
  443|      0|                let paragraphStyle = NSParagraphStyle.default.mutableCopy() as! NSMutableParagraphStyle
  444|      0|                paragraphStyle.lineBreakMode = .byTruncatingTail
  445|      0|                paragraphStyle.alignment = .center
  446|      0|                
  447|      0|                attrString = NSMutableAttributedString(string: newValue!)
  448|      0|                attrString?.setAttributes([
  449|      0|                    .foregroundColor: NSUIColor.labelOrBlack,
  450|      0|                    .font: NSUIFont.systemFont(ofSize: 12.0),
  451|      0|                    .paragraphStyle: paragraphStyle
  452|      0|                    ], range: NSMakeRange(0, attrString!.length))
  453|      0|            }
  454|      0|            self.centerAttributedText = attrString
  455|      0|        }
  456|       |    }
  457|       |    
  458|       |    /// the text that is displayed in the center of the pie-chart
  459|       |    @objc open var centerAttributedText: NSAttributedString?
  460|       |    {
  461|       |        get
  462|      0|        {
  463|      0|            return _centerAttributedText
  464|      0|        }
  465|       |        set
  466|      0|        {
  467|      0|            _centerAttributedText = newValue
  468|      0|            setNeedsDisplay()
  469|      0|        }
  470|       |    }
  471|       |    
  472|       |    /// Sets the offset the center text should have from it's original position in dp. Default x = 0, y = 0
  473|       |    @objc open var centerTextOffset: CGPoint
  474|       |    {
  475|       |        get
  476|      0|        {
  477|      0|            return _centerTextOffset
  478|      0|        }
  479|       |        set
  480|      0|        {
  481|      0|            _centerTextOffset = newValue
  482|      0|            setNeedsDisplay()
  483|      0|        }
  484|       |    }
  485|       |    
  486|       |    /// `true` if drawing the center text is enabled
  487|       |    @objc open var drawCenterTextEnabled: Bool
  488|       |    {
  489|       |        get
  490|      0|        {
  491|      0|            return _drawCenterTextEnabled
  492|      0|        }
  493|       |        set
  494|      0|        {
  495|      0|            _drawCenterTextEnabled = newValue
  496|      0|            setNeedsDisplay()
  497|      0|        }
  498|       |    }
  499|       |    
  500|       |    /// `true` if drawing the center text is enabled
  501|       |    @objc open var isDrawCenterTextEnabled: Bool
  502|       |    {
  503|       |        get
  504|      0|        {
  505|      0|            return drawCenterTextEnabled
  506|      0|        }
  507|       |    }
  508|       |    
  509|       |    internal override var requiredLegendOffset: CGFloat
  510|      0|    {
  511|      0|        return _legend.font.pointSize * 2.0
  512|      0|    }
  513|       |    
  514|       |    internal override var requiredBaseOffset: CGFloat
  515|      0|    {
  516|      0|        return 0.0
  517|      0|    }
  518|       |    
  519|       |    open override var radius: CGFloat
  520|      0|    {
  521|      0|        return _circleBox.width / 2.0
  522|      0|    }
  523|       |    
  524|       |    /// The circlebox, the boundingbox of the pie-chart slices
  525|       |    @objc open var circleBox: CGRect
  526|      0|    {
  527|      0|        return _circleBox
  528|      0|    }
  529|       |    
  530|       |    /// The center of the circlebox
  531|       |    @objc open var centerCircleBox: CGPoint
  532|      0|    {
  533|      0|        return CGPoint(x: _circleBox.midX, y: _circleBox.midY)
  534|      0|    }
  535|       |    
  536|       |    /// the radius of the hole in the center of the piechart in percent of the maximum radius (max = the radius of the whole chart)
  537|       |    /// 
  538|       |    /// **default**: 0.5 (50%) (half the pie)
  539|       |    @objc open var holeRadiusPercent: CGFloat
  540|       |    {
  541|       |        get
  542|      0|        {
  543|      0|            return _holeRadiusPercent
  544|      0|        }
  545|       |        set
  546|      0|        {
  547|      0|            _holeRadiusPercent = newValue
  548|      0|            setNeedsDisplay()
  549|      0|        }
  550|       |    }
  551|       |    
  552|       |    /// The color that the transparent-circle should have.
  553|       |    ///
  554|       |    /// **default**: `nil`
  555|       |    @objc open var transparentCircleColor: NSUIColor?
  556|       |    {
  557|       |        get
  558|      0|        {
  559|      0|            return _transparentCircleColor
  560|      0|        }
  561|       |        set
  562|      0|        {
  563|      0|            _transparentCircleColor = newValue
  564|      0|            setNeedsDisplay()
  565|      0|        }
  566|       |    }
  567|       |    
  568|       |    /// the radius of the transparent circle that is drawn next to the hole in the piechart in percent of the maximum radius (max = the radius of the whole chart)
  569|       |    /// 
  570|       |    /// **default**: 0.55 (55%) -> means 5% larger than the center-hole by default
  571|       |    @objc open var transparentCircleRadiusPercent: CGFloat
  572|       |    {
  573|       |        get
  574|      0|        {
  575|      0|            return _transparentCircleRadiusPercent
  576|      0|        }
  577|       |        set
  578|      0|        {
  579|      0|            _transparentCircleRadiusPercent = newValue
  580|      0|            setNeedsDisplay()
  581|      0|        }
  582|       |    }
  583|       |        
  584|       |    /// The color the entry labels are drawn with.
  585|       |    @objc open var entryLabelColor: NSUIColor?
  586|       |    {
  587|      0|        get { return _entryLabelColor }
  588|       |        set
  589|      0|        {
  590|      0|            _entryLabelColor = newValue
  591|      0|            setNeedsDisplay()
  592|      0|        }
  593|       |    }
  594|       |    
  595|       |    /// The font the entry labels are drawn with.
  596|       |    @objc open var entryLabelFont: NSUIFont?
  597|       |    {
  598|      0|        get { return _entryLabelFont }
  599|       |        set
  600|      0|        {
  601|      0|            _entryLabelFont = newValue
  602|      0|            setNeedsDisplay()
  603|      0|        }
  604|       |    }
  605|       |    
  606|       |    /// Set this to true to draw the enrty labels into the pie slices
  607|       |    @objc open var drawEntryLabelsEnabled: Bool
  608|       |    {
  609|       |        get
  610|      0|        {
  611|      0|            return _drawEntryLabelsEnabled
  612|      0|        }
  613|       |        set
  614|      0|        {
  615|      0|            _drawEntryLabelsEnabled = newValue
  616|      0|            setNeedsDisplay()
  617|      0|        }
  618|       |    }
  619|       |    
  620|       |    /// `true` if drawing entry labels is enabled, `false` ifnot
  621|       |    @objc open var isDrawEntryLabelsEnabled: Bool
  622|       |    {
  623|       |        get
  624|      0|        {
  625|      0|            return drawEntryLabelsEnabled
  626|      0|        }
  627|       |    }
  628|       |    
  629|       |    /// If this is enabled, values inside the PieChart are drawn in percent and not with their original value. Values provided for the ValueFormatter to format are then provided in percent.
  630|       |    @objc open var usePercentValuesEnabled: Bool
  631|       |    {
  632|       |        get
  633|      0|        {
  634|      0|            return _usePercentValuesEnabled
  635|      0|        }
  636|       |        set
  637|      0|        {
  638|      0|            _usePercentValuesEnabled = newValue
  639|      0|            setNeedsDisplay()
  640|      0|        }
  641|       |    }
  642|       |    
  643|       |    /// `true` if drawing x-values is enabled, `false` ifnot
  644|       |    @objc open var isUsePercentValuesEnabled: Bool
  645|       |    {
  646|       |        get
  647|      0|        {
  648|      0|            return usePercentValuesEnabled
  649|      0|        }
  650|       |    }
  651|       |    
  652|       |    /// the rectangular radius of the bounding box for the center text, as a percentage of the pie hole
  653|       |    @objc open var centerTextRadiusPercent: CGFloat
  654|       |    {
  655|       |        get
  656|      0|        {
  657|      0|            return _centerTextRadiusPercent
  658|      0|        }
  659|       |        set
  660|      0|        {
  661|      0|            _centerTextRadiusPercent = newValue
  662|      0|            setNeedsDisplay()
  663|      0|        }
  664|       |    }
  665|       |    
  666|       |    /// The max angle that is used for calculating the pie-circle.
  667|       |    /// 360 means it's a full pie-chart, 180 results in a half-pie-chart.
  668|       |    /// **default**: 360.0
  669|       |    @objc open var maxAngle: CGFloat
  670|       |    {
  671|       |        get
  672|      0|        {
  673|      0|            return _maxAngle
  674|      0|        }
  675|       |        set
  676|      0|        {
  677|      0|            _maxAngle = newValue
  678|      0|            
  679|      0|            if _maxAngle > 360.0
  680|      0|            {
  681|      0|                _maxAngle = 360.0
  682|      0|            }
  683|      0|            
  684|      0|            if _maxAngle < 90.0
  685|      0|            {
  686|      0|                _maxAngle = 90.0
  687|      0|            }
  688|      0|        }
  689|       |    }
  690|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/PieRadarChartViewBase.swift:
    1|       |//
    2|       |//  PieRadarChartViewBase.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |import QuartzCore
   15|       |
   16|       |#if canImport(AppKit)
   17|       |import AppKit
   18|       |#endif
   19|       |
   20|       |
   21|       |/// Base class of PieChartView and RadarChartView.
   22|       |open class PieRadarChartViewBase: ChartViewBase
   23|       |{
   24|       |    /// holds the normalized version of the current rotation angle of the chart
   25|      0|    private var _rotationAngle = CGFloat(270.0)
   26|       |    
   27|       |    /// holds the raw version of the current rotation angle of the chart
   28|      0|    private var _rawRotationAngle = CGFloat(270.0)
   29|       |    
   30|       |    /// flag that indicates if rotation is enabled or not
   31|       |    @objc open var rotationEnabled = true
   32|       |    
   33|       |    /// Sets the minimum offset (padding) around the chart, defaults to 0.0
   34|      0|    @objc open var minOffset = CGFloat(0.0)
   35|       |
   36|       |    /// iOS && OSX only: Enabled multi-touch rotation using two fingers.
   37|       |    private var _rotationWithTwoFingers = false
   38|       |    
   39|       |    private var _tapGestureRecognizer: NSUITapGestureRecognizer!
   40|       |    #if !os(tvOS)
   41|       |    private var _rotationGestureRecognizer: NSUIRotationGestureRecognizer!
   42|       |    #endif
   43|       |    
   44|       |    public override init(frame: CGRect)
   45|      0|    {
   46|      0|        super.init(frame: frame)
   47|      0|    }
   48|       |    
   49|       |    public required init?(coder aDecoder: NSCoder)
   50|      0|    {
   51|      0|        super.init(coder: aDecoder)
   52|      0|    }
   53|       |    
   54|       |    deinit
   55|      0|    {
   56|      0|        stopDeceleration()
   57|      0|    }
   58|       |    
   59|       |    internal override func initialize()
   60|      0|    {
   61|      0|        super.initialize()
   62|      0|        
   63|      0|        _tapGestureRecognizer = NSUITapGestureRecognizer(target: self, action: #selector(tapGestureRecognized(_:)))
   64|      0|        
   65|      0|        self.addGestureRecognizer(_tapGestureRecognizer)
   66|      0|
   67|      0|        #if !os(tvOS)
   68|      0|        _rotationGestureRecognizer = NSUIRotationGestureRecognizer(target: self, action: #selector(rotationGestureRecognized(_:)))
   69|      0|        self.addGestureRecognizer(_rotationGestureRecognizer)
   70|      0|        _rotationGestureRecognizer.isEnabled = rotationWithTwoFingers
   71|      0|        #endif
   72|      0|    }
   73|       |    
   74|       |    internal override func calcMinMax()
   75|      0|    {
   76|      0|        /*_xAxis.axisRange = Double((_data?.xVals.count ?? 0) - 1)*/
   77|      0|    }
   78|       |    
   79|       |    open override var maxVisibleCount: Int
   80|       |    {
   81|       |        get
   82|      0|        {
   83|      0|            return data?.entryCount ?? 0
   84|      0|        }
   85|       |    }
   86|       |    
   87|       |    open override func notifyDataSetChanged()
   88|      0|    {
   89|      0|        calcMinMax()
   90|      0|        
   91|      0|        if let data = _data , _legend !== nil
   92|      0|        {
   93|      0|            legendRenderer.computeLegend(data: data)
   94|      0|        }
   95|      0|        
   96|      0|        calculateOffsets()
   97|      0|        
   98|      0|        setNeedsDisplay()
   99|      0|    }
  100|       |  
  101|       |    internal override func calculateOffsets()
  102|      0|    {
  103|      0|        var legendLeft = CGFloat(0.0)
  104|      0|        var legendRight = CGFloat(0.0)
  105|      0|        var legendBottom = CGFloat(0.0)
  106|      0|        var legendTop = CGFloat(0.0)
  107|      0|
  108|      0|        if _legend != nil && _legend.enabled && !_legend.drawInside
  109|      0|        {
  110|      0|            let fullLegendWidth = min(_legend.neededWidth, _viewPortHandler.chartWidth * _legend.maxSizePercent)
  111|      0|            
  112|      0|            switch _legend.orientation
  113|      0|            {
  114|      0|            case .vertical:
  115|      0|                
  116|      0|                var xLegendOffset: CGFloat = 0.0
  117|      0|                
  118|      0|                if _legend.horizontalAlignment == .left
  119|      0|                    || _legend.horizontalAlignment == .right
  120|      0|                {
  121|      0|                    if _legend.verticalAlignment == .center
  122|      0|                    {
  123|      0|                        // this is the space between the legend and the chart
  124|      0|                        let spacing = CGFloat(13.0)
  125|      0|                        
  126|      0|                        xLegendOffset = fullLegendWidth + spacing
  127|      0|                    }
  128|      0|                    else
  129|      0|                    {
  130|      0|                        // this is the space between the legend and the chart
  131|      0|                        let spacing = CGFloat(8.0)
  132|      0|                        
  133|      0|                        let legendWidth = fullLegendWidth + spacing
  134|      0|                        let legendHeight = _legend.neededHeight + _legend.textHeightMax
  135|      0|                        
  136|      0|                        let c = self.midPoint
  137|      0|                        
  138|      0|                        let bottomX = _legend.horizontalAlignment == .right
  139|      0|                            ? self.bounds.width - legendWidth + 15.0
  140|      0|                            : legendWidth - 15.0
  141|      0|                        let bottomY = legendHeight + 15
  142|      0|                        let distLegend = distanceToCenter(x: bottomX, y: bottomY)
  143|      0|                        
  144|      0|                        let reference = getPosition(center: c, dist: self.radius,
  145|      0|                                                    angle: angleForPoint(x: bottomX, y: bottomY))
  146|      0|                        
  147|      0|                        let distReference = distanceToCenter(x: reference.x, y: reference.y)
  148|      0|                        let minOffset = CGFloat(5.0)
  149|      0|                        
  150|      0|                        if bottomY >= c.y
  151|      0|                            && self.bounds.height - legendWidth > self.bounds.width
  152|      0|                        {
  153|      0|                            xLegendOffset = legendWidth
  154|      0|                        }
  155|      0|                        else if distLegend < distReference
  156|      0|                        {
  157|      0|                            let diff = distReference - distLegend
  158|      0|                            xLegendOffset = minOffset + diff
  159|      0|                        }
  160|      0|                    }
  161|      0|                }
  162|      0|                
  163|      0|                switch _legend.horizontalAlignment
  164|      0|                {
  165|      0|                case .left:
  166|      0|                    legendLeft = xLegendOffset
  167|      0|                    
  168|      0|                case .right:
  169|      0|                    legendRight = xLegendOffset
  170|      0|                    
  171|      0|                case .center:
  172|      0|                    
  173|      0|                    switch _legend.verticalAlignment
  174|      0|                    {
  175|      0|                    case .top:
  176|      0|                        legendTop = min(_legend.neededHeight, _viewPortHandler.chartHeight * _legend.maxSizePercent)
  177|      0|                        
  178|      0|                    case .bottom:
  179|      0|                        legendBottom = min(_legend.neededHeight, _viewPortHandler.chartHeight * _legend.maxSizePercent)
  180|      0|                        
  181|      0|                    default:
  182|      0|                        break
  183|      0|                    }
  184|      0|                }
  185|      0|            
  186|      0|            case .horizontal:
  187|      0|                
  188|      0|                var yLegendOffset: CGFloat = 0.0
  189|      0|                
  190|      0|                if _legend.verticalAlignment == .top
  191|      0|                    || _legend.verticalAlignment == .bottom
  192|      0|                {
  193|      0|                    // It's possible that we do not need this offset anymore as it
  194|      0|                    //   is available through the extraOffsets, but changing it can mean
  195|      0|                    //   changing default visibility for existing apps.
  196|      0|                    let yOffset = self.requiredLegendOffset
  197|      0|                    
  198|      0|                    yLegendOffset = min(
  199|      0|                        _legend.neededHeight + yOffset,
  200|      0|                        _viewPortHandler.chartHeight * _legend.maxSizePercent)
  201|      0|                }
  202|      0|                
  203|      0|                switch _legend.verticalAlignment
  204|      0|                {
  205|      0|                case .top:
  206|      0|                    
  207|      0|                    legendTop = yLegendOffset
  208|      0|                    
  209|      0|                case .bottom:
  210|      0|                    
  211|      0|                    legendBottom = yLegendOffset
  212|      0|                    
  213|      0|                default:
  214|      0|                    break
  215|      0|                }
  216|      0|            }
  217|      0|
  218|      0|            legendLeft += self.requiredBaseOffset
  219|      0|            legendRight += self.requiredBaseOffset
  220|      0|            legendTop += self.requiredBaseOffset
  221|      0|            legendBottom += self.requiredBaseOffset
  222|      0|        }
  223|      0|        
  224|      0|        legendTop += self.extraTopOffset
  225|      0|        legendRight += self.extraRightOffset
  226|      0|        legendBottom += self.extraBottomOffset
  227|      0|        legendLeft += self.extraLeftOffset
  228|      0|        
  229|      0|        var minOffset = self.minOffset
  230|      0|        
  231|      0|        if self is RadarChartView
  232|      0|        {
  233|      0|            let x = self.xAxis
  234|      0|            
  235|      0|            if x.isEnabled && x.drawLabelsEnabled
  236|      0|            {
  237|      0|                minOffset = max(minOffset, x.labelRotatedWidth)
  238|      0|            }
  239|      0|        }
  240|      0|
  241|      0|        let offsetLeft = max(minOffset, legendLeft)
  242|      0|        let offsetTop = max(minOffset, legendTop)
  243|      0|        let offsetRight = max(minOffset, legendRight)
  244|      0|        let offsetBottom = max(minOffset, max(self.requiredBaseOffset, legendBottom))
  245|      0|
  246|      0|        _viewPortHandler.restrainViewPort(offsetLeft: offsetLeft, offsetTop: offsetTop, offsetRight: offsetRight, offsetBottom: offsetBottom)
  247|      0|    }
  248|       |
  249|       |    /// - Returns: The angle relative to the chart center for the given point on the chart in degrees.
  250|       |    /// The angle is always between 0 and 360°, 0° is NORTH, 90° is EAST, ...
  251|       |    @objc open func angleForPoint(x: CGFloat, y: CGFloat) -> CGFloat
  252|      0|    {
  253|      0|        let c = centerOffsets
  254|      0|        
  255|      0|        let tx = Double(x - c.x)
  256|      0|        let ty = Double(y - c.y)
  257|      0|        let length = sqrt(tx * tx + ty * ty)
  258|      0|        let r = acos(ty / length)
  259|      0|
  260|      0|        var angle = r.RAD2DEG
  261|      0|
  262|      0|        if x > c.x
  263|      0|        {
  264|      0|            angle = 360.0 - angle
  265|      0|        }
  266|      0|
  267|      0|        // add 90° because chart starts EAST
  268|      0|        angle = angle + 90.0
  269|      0|
  270|      0|        // neutralize overflow
  271|      0|        if angle > 360.0
  272|      0|        {
  273|      0|            angle = angle - 360.0
  274|      0|        }
  275|      0|
  276|      0|        return CGFloat(angle)
  277|      0|    }
  278|       |    
  279|       |    /// Calculates the position around a center point, depending on the distance
  280|       |    /// from the center, and the angle of the position around the center.
  281|       |    @objc open func getPosition(center: CGPoint, dist: CGFloat, angle: CGFloat) -> CGPoint
  282|      0|    {
  283|      0|        return CGPoint(x: center.x + dist * cos(angle.DEG2RAD),
  284|      0|                y: center.y + dist * sin(angle.DEG2RAD))
  285|      0|    }
  286|       |
  287|       |    /// - Returns: The distance of a certain point on the chart to the center of the chart.
  288|       |    @objc open func distanceToCenter(x: CGFloat, y: CGFloat) -> CGFloat
  289|      0|    {
  290|      0|        let c = self.centerOffsets
  291|      0|
  292|      0|        var dist = CGFloat(0.0)
  293|      0|
  294|      0|        var xDist = CGFloat(0.0)
  295|      0|        var yDist = CGFloat(0.0)
  296|      0|
  297|      0|        if x > c.x
  298|      0|        {
  299|      0|            xDist = x - c.x
  300|      0|        }
  301|      0|        else
  302|      0|        {
  303|      0|            xDist = c.x - x
  304|      0|        }
  305|      0|
  306|      0|        if y > c.y
  307|      0|        {
  308|      0|            yDist = y - c.y
  309|      0|        }
  310|      0|        else
  311|      0|        {
  312|      0|            yDist = c.y - y
  313|      0|        }
  314|      0|
  315|      0|        // pythagoras
  316|      0|        dist = sqrt(pow(xDist, 2.0) + pow(yDist, 2.0))
  317|      0|
  318|      0|        return dist
  319|      0|    }
  320|       |
  321|       |    /// - Returns: The xIndex for the given angle around the center of the chart.
  322|       |    /// -1 if not found / outofbounds.
  323|       |    @objc open func indexForAngle(_ angle: CGFloat) -> Int
  324|      0|    {
  325|      0|        fatalError("indexForAngle() cannot be called on PieRadarChartViewBase")
  326|      0|    }
  327|       |
  328|       |    /// current rotation angle of the pie chart
  329|       |    ///
  330|       |    /// **default**: 270 --> top (NORTH)
  331|       |    /// Will always return a normalized value, which will be between 0.0 < 360.0
  332|       |    @objc open var rotationAngle: CGFloat
  333|       |    {
  334|       |        get
  335|      0|        {
  336|      0|            return _rotationAngle
  337|      0|        }
  338|       |        set
  339|      0|        {
  340|      0|            _rawRotationAngle = newValue
  341|      0|            _rotationAngle = newValue.normalizedAngle
  342|      0|            setNeedsDisplay()
  343|      0|        }
  344|       |    }
  345|       |    
  346|       |    /// gets the raw version of the current rotation angle of the pie chart the returned value could be any value, negative or positive, outside of the 360 degrees. 
  347|       |    /// this is used when working with rotation direction, mainly by gestures and animations.
  348|       |    @objc open var rawRotationAngle: CGFloat
  349|      0|    {
  350|      0|        return _rawRotationAngle
  351|      0|    }
  352|       |
  353|       |    /// The diameter of the pie- or radar-chart
  354|       |    @objc open var diameter: CGFloat
  355|      0|    {
  356|      0|        var content = _viewPortHandler.contentRect
  357|      0|        content.origin.x += extraLeftOffset
  358|      0|        content.origin.y += extraTopOffset
  359|      0|        content.size.width -= extraLeftOffset + extraRightOffset
  360|      0|        content.size.height -= extraTopOffset + extraBottomOffset
  361|      0|        return min(content.width, content.height)
  362|      0|    }
  363|       |
  364|       |    /// The radius of the chart in pixels.
  365|       |    @objc open var radius: CGFloat
  366|      0|    {
  367|      0|        fatalError("radius cannot be called on PieRadarChartViewBase")
  368|      0|    }
  369|       |
  370|       |    /// The required offset for the chart legend.
  371|       |    internal var requiredLegendOffset: CGFloat
  372|      0|    {
  373|      0|        fatalError("requiredLegendOffset cannot be called on PieRadarChartViewBase")
  374|      0|    }
  375|       |
  376|       |    /// - Returns: The base offset needed for the chart without calculating the
  377|       |    /// legend size.
  378|       |    internal var requiredBaseOffset: CGFloat
  379|      0|    {
  380|      0|        fatalError("requiredBaseOffset cannot be called on PieRadarChartViewBase")
  381|      0|    }
  382|       |    
  383|       |    open override var chartYMax: Double
  384|      0|    {
  385|      0|        return 0.0
  386|      0|    }
  387|       |    
  388|       |    open override var chartYMin: Double
  389|      0|    {
  390|      0|        return 0.0
  391|      0|    }
  392|       |    
  393|      0|    @objc open var isRotationEnabled: Bool { return rotationEnabled }
  394|       |    
  395|       |    /// flag that indicates if rotation is done with two fingers or one.
  396|       |    /// when the chart is inside a scrollview, you need a two-finger rotation because a one-finger rotation eats up all touch events.
  397|       |    ///
  398|       |    /// On iOS this will disable one-finger rotation.
  399|       |    /// On OSX this will keep two-finger multitouch rotation, and one-pointer mouse rotation.
  400|       |    /// 
  401|       |    /// **default**: false
  402|       |    @objc open var rotationWithTwoFingers: Bool
  403|       |    {
  404|       |        get
  405|      0|        {
  406|      0|            return _rotationWithTwoFingers
  407|      0|        }
  408|       |        set
  409|      0|        {
  410|      0|            _rotationWithTwoFingers = newValue
  411|      0|            #if !os(tvOS)
  412|      0|            _rotationGestureRecognizer.isEnabled = _rotationWithTwoFingers
  413|      0|            #endif
  414|      0|        }
  415|       |    }
  416|       |    
  417|       |    /// flag that indicates if rotation is done with two fingers or one.
  418|       |    /// when the chart is inside a scrollview, you need a two-finger rotation because a one-finger rotation eats up all touch events.
  419|       |    ///
  420|       |    /// On iOS this will disable one-finger rotation.
  421|       |    /// On OSX this will keep two-finger multitouch rotation, and one-pointer mouse rotation.
  422|       |    ///
  423|       |    /// **default**: false
  424|       |    @objc open var isRotationWithTwoFingers: Bool
  425|      0|    {
  426|      0|        return _rotationWithTwoFingers
  427|      0|    }
  428|       |    
  429|       |    // MARK: - Animation
  430|       |    
  431|       |    private var _spinAnimator: Animator!
  432|       |    
  433|       |    /// Applys a spin animation to the Chart.
  434|       |    @objc open func spin(duration: TimeInterval, fromAngle: CGFloat, toAngle: CGFloat, easing: ChartEasingFunctionBlock?)
  435|      0|    {
  436|      0|        if _spinAnimator != nil
  437|      0|        {
  438|      0|            _spinAnimator.stop()
  439|      0|        }
  440|      0|        
  441|      0|        _spinAnimator = Animator()
  442|      0|        _spinAnimator.updateBlock = {
  443|      0|            self.rotationAngle = (toAngle - fromAngle) * CGFloat(self._spinAnimator.phaseX) + fromAngle
  444|      0|        }
  445|      0|        _spinAnimator.stopBlock = { self._spinAnimator = nil }
  446|      0|        
  447|      0|        _spinAnimator.animate(xAxisDuration: duration, easing: easing)
  448|      0|    }
  449|       |    
  450|       |    @objc open func spin(duration: TimeInterval, fromAngle: CGFloat, toAngle: CGFloat, easingOption: ChartEasingOption)
  451|      0|    {
  452|      0|        spin(duration: duration, fromAngle: fromAngle, toAngle: toAngle, easing: easingFunctionFromOption(easingOption))
  453|      0|    }
  454|       |    
  455|       |    @objc open func spin(duration: TimeInterval, fromAngle: CGFloat, toAngle: CGFloat)
  456|      0|    {
  457|      0|        spin(duration: duration, fromAngle: fromAngle, toAngle: toAngle, easing: nil)
  458|      0|    }
  459|       |    
  460|       |    @objc open func stopSpinAnimation()
  461|      0|    {
  462|      0|        if _spinAnimator != nil
  463|      0|        {
  464|      0|            _spinAnimator.stop()
  465|      0|        }
  466|      0|    }
  467|       |    
  468|       |    // MARK: - Gestures
  469|       |    
  470|       |    private var _rotationGestureStartPoint: CGPoint!
  471|       |    private var _isRotating = false
  472|      0|    private var _startAngle = CGFloat(0.0)
  473|       |    
  474|       |    private struct AngularVelocitySample
  475|       |    {
  476|       |        var time: TimeInterval
  477|       |        var angle: CGFloat
  478|       |    }
  479|       |    
  480|      0|    private var velocitySamples = [AngularVelocitySample]()
  481|       |    
  482|       |    private var _decelerationLastTime: TimeInterval = 0.0
  483|       |    private var _decelerationDisplayLink: NSUIDisplayLink!
  484|       |    private var _decelerationAngularVelocity: CGFloat = 0.0
  485|       |    
  486|       |    internal final func processRotationGestureBegan(location: CGPoint)
  487|      0|    {
  488|      0|        self.resetVelocity()
  489|      0|        
  490|      0|        if rotationEnabled
  491|      0|        {
  492|      0|            self.sampleVelocity(touchLocation: location)
  493|      0|        }
  494|      0|        
  495|      0|        self.setGestureStartAngle(x: location.x, y: location.y)
  496|      0|        
  497|      0|        _rotationGestureStartPoint = location
  498|      0|    }
  499|       |    
  500|       |    internal final func processRotationGestureMoved(location: CGPoint)
  501|      0|    {
  502|      0|        if isDragDecelerationEnabled
  503|      0|        {
  504|      0|            sampleVelocity(touchLocation: location)
  505|      0|        }
  506|      0|        
  507|      0|        if !_isRotating &&
  508|      0|            distance(
  509|      0|                eventX: location.x,
  510|      0|                startX: _rotationGestureStartPoint.x,
  511|      0|                eventY: location.y,
  512|      0|                startY: _rotationGestureStartPoint.y) > CGFloat(8.0)
  513|      0|        {
  514|      0|            _isRotating = true
  515|      0|        }
  516|      0|        else
  517|      0|        {
  518|      0|            self.updateGestureRotation(x: location.x, y: location.y)
  519|      0|            setNeedsDisplay()
  520|      0|        }
  521|      0|    }
  522|       |    
  523|       |    internal final func processRotationGestureEnded(location: CGPoint)
  524|      0|    {
  525|      0|        if isDragDecelerationEnabled
  526|      0|        {
  527|      0|            stopDeceleration()
  528|      0|            
  529|      0|            sampleVelocity(touchLocation: location)
  530|      0|            
  531|      0|            _decelerationAngularVelocity = calculateVelocity()
  532|      0|            
  533|      0|            if _decelerationAngularVelocity != 0.0
  534|      0|            {
  535|      0|                _decelerationLastTime = CACurrentMediaTime()
  536|      0|                _decelerationDisplayLink = NSUIDisplayLink(target: self, selector: #selector(PieRadarChartViewBase.decelerationLoop))
  537|      0|                _decelerationDisplayLink.add(to: RunLoop.main, forMode: RunLoop.Mode.common)
  538|      0|            }
  539|      0|        }
  540|      0|    }
  541|       |    
  542|       |    internal final func processRotationGestureCancelled()
  543|      0|    {
  544|      0|        if _isRotating
  545|      0|        {
  546|      0|            _isRotating = false
  547|      0|        }
  548|      0|    }
  549|       |    
  550|       |    #if !os(OSX)
  551|       |    open override func nsuiTouchesBegan(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
  552|      0|    {
  553|      0|        // if rotation by touch is enabled
  554|      0|        if rotationEnabled
  555|      0|        {
  556|      0|            stopDeceleration()
  557|      0|            
  558|      0|            if !rotationWithTwoFingers, let touchLocation = touches.first?.location(in: self)
  559|      0|            {
  560|      0|                processRotationGestureBegan(location: touchLocation)
  561|      0|            }
  562|      0|        }
  563|      0|        
  564|      0|        if !_isRotating
  565|      0|        {
  566|      0|            super.nsuiTouchesBegan(touches, withEvent: event)
  567|      0|        }
  568|      0|    }
  569|       |    
  570|       |    open override func nsuiTouchesMoved(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
  571|      0|    {
  572|      0|        if rotationEnabled && !rotationWithTwoFingers, let touch = touches.first
  573|      0|        {
  574|      0|            let touchLocation = touch.location(in: self)
  575|      0|            processRotationGestureMoved(location: touchLocation)
  576|      0|        }
  577|      0|        
  578|      0|        if !_isRotating
  579|      0|        {
  580|      0|            super.nsuiTouchesMoved(touches, withEvent: event)
  581|      0|        }
  582|      0|    }
  583|       |    
  584|       |    open override func nsuiTouchesEnded(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
  585|      0|    {
  586|      0|        if !_isRotating
  587|      0|        {
  588|      0|            super.nsuiTouchesEnded(touches, withEvent: event)
  589|      0|        }
  590|      0|        
  591|      0|        if rotationEnabled && !rotationWithTwoFingers, let touch = touches.first
  592|      0|        {
  593|      0|            let touchLocation = touch.location(in: self)
  594|      0|            processRotationGestureEnded(location: touchLocation)
  595|      0|        }
  596|      0|        
  597|      0|        if _isRotating
  598|      0|        {
  599|      0|            _isRotating = false
  600|      0|        }
  601|      0|    }
  602|       |    
  603|       |    open override func nsuiTouchesCancelled(_ touches: Set<NSUITouch>?, withEvent event: NSUIEvent?)
  604|      0|    {
  605|      0|        super.nsuiTouchesCancelled(touches, withEvent: event)
  606|      0|        
  607|      0|        processRotationGestureCancelled()
  608|      0|    }
  609|       |    #endif
  610|       |    
  611|       |    #if os(OSX)
  612|       |    open override func mouseDown(with theEvent: NSEvent)
  613|       |    {
  614|       |        // if rotation by touch is enabled
  615|       |        if rotationEnabled
  616|       |        {
  617|       |            stopDeceleration()
  618|       |        
  619|       |            let location = self.convert(theEvent.locationInWindow, from: nil)
  620|       |            
  621|       |            processRotationGestureBegan(location: location)
  622|       |        }
  623|       |        
  624|       |        if !_isRotating
  625|       |        {
  626|       |            super.mouseDown(with: theEvent)
  627|       |        }
  628|       |    }
  629|       |    
  630|       |    open override func mouseDragged(with theEvent: NSEvent)
  631|       |    {
  632|       |        if rotationEnabled
  633|       |        {
  634|       |            let location = self.convert(theEvent.locationInWindow, from: nil)
  635|       |            
  636|       |            processRotationGestureMoved(location: location)
  637|       |        }
  638|       |        
  639|       |        if !_isRotating
  640|       |        {
  641|       |            super.mouseDragged(with: theEvent)
  642|       |        }
  643|       |    }
  644|       |    
  645|       |    open override func mouseUp(with theEvent: NSEvent)
  646|       |    {
  647|       |        if !_isRotating
  648|       |        {
  649|       |            super.mouseUp(with: theEvent)
  650|       |        }
  651|       |        
  652|       |        if rotationEnabled
  653|       |        {
  654|       |            let location = self.convert(theEvent.locationInWindow, from: nil)
  655|       |            
  656|       |            processRotationGestureEnded(location: location)
  657|       |        }
  658|       |        
  659|       |        if _isRotating
  660|       |        {
  661|       |            _isRotating = false
  662|       |        }
  663|       |    }
  664|       |    #endif
  665|       |    
  666|       |    private func resetVelocity()
  667|      0|    {
  668|      0|        velocitySamples.removeAll(keepingCapacity: false)
  669|      0|    }
  670|       |    
  671|       |    private func sampleVelocity(touchLocation: CGPoint)
  672|      0|    {
  673|      0|        let currentSample: AngularVelocitySample = {
  674|      0|            let time = CACurrentMediaTime()
  675|      0|            let angle = angleForPoint(x: touchLocation.x, y: touchLocation.y)
  676|      0|            return AngularVelocitySample(time: time, angle: angle)
  677|      0|        }()
  678|      0|
  679|      0|        // Remove samples older than our sample time - 1 seconds
  680|      0|        // while keeping at least one sample
  681|      0|        
  682|      0|        var i = 0, count = velocitySamples.count
  683|      0|        while (i < count - 2)
  684|      0|        {
  685|      0|            if currentSample.time - velocitySamples[i].time > 1.0
  686|      0|            {
  687|      0|                velocitySamples.remove(at: 0)
  688|      0|                i -= 1
  689|      0|                count -= 1
  690|      0|            }
  691|      0|            else
  692|      0|            {
  693|      0|                break
  694|      0|            }
  695|      0|
  696|      0|            i += 1
  697|      0|        }
  698|      0|
  699|      0|        velocitySamples.append(currentSample)
  700|      0|    }
  701|       |
  702|       |    private func calculateVelocity() -> CGFloat
  703|      0|    {
  704|      0|        guard var firstSample = velocitySamples.first,
  705|      0|            var lastSample = velocitySamples.last
  706|      0|            else { return 0 }
  707|      0|
  708|      0|        // Look for a sample that's closest to the latest sample, but not the same, so we can deduce the direction
  709|      0|        let beforeLastSample = velocitySamples.last { $0.angle != lastSample.angle }
  710|      0|            ?? firstSample
  711|      0|
  712|      0|        // Calculate the sampling time
  713|      0|        let timeDelta: CGFloat = {
  714|      0|            let delta = CGFloat(lastSample.time - firstSample.time)
  715|      0|            return delta == 0 ? 0.1 : delta
  716|      0|        }()
  717|      0|
  718|      0|        // Calculate clockwise/ccw by choosing two values that should be closest to each other,
  719|      0|        // so if the angles are two far from each other we know they are inverted "for sure"
  720|      0|        let isClockwise: Bool = {
  721|      0|            let isClockwise = lastSample.angle >= beforeLastSample.angle
  722|      0|            let isInverted = abs(lastSample.angle - beforeLastSample.angle) > 270.0
  723|      0|            return isInverted ? !isClockwise : isClockwise
  724|      0|        }()
  725|      0|
  726|      0|        // Now if the "gesture" is over a too big of an angle - then we know the angles are inverted, and we need to move them closer to each other from both sides of the 360.0 wrapping point
  727|      0|        if lastSample.angle - firstSample.angle > 180.0
  728|      0|        {
  729|      0|            firstSample.angle += 360.0
  730|      0|        }
  731|      0|        else if firstSample.angle - lastSample.angle > 180.0
  732|      0|        {
  733|      0|            lastSample.angle += 360.0
  734|      0|        }
  735|      0|
  736|      0|        // The velocity
  737|      0|        let velocity = abs((lastSample.angle - firstSample.angle) / timeDelta)
  738|      0|        return isClockwise ? velocity : -velocity
  739|      0|    }
  740|       |
  741|       |    /// sets the starting angle of the rotation, this is only used by the touch listener, x and y is the touch position
  742|       |    private func setGestureStartAngle(x: CGFloat, y: CGFloat)
  743|      0|    {
  744|      0|        _startAngle = angleForPoint(x: x, y: y)
  745|      0|        
  746|      0|        // take the current angle into consideration when starting a new drag
  747|      0|        _startAngle -= _rotationAngle
  748|      0|    }
  749|       |    
  750|       |    /// updates the view rotation depending on the given touch position, also takes the starting angle into consideration
  751|       |    private func updateGestureRotation(x: CGFloat, y: CGFloat)
  752|      0|    {
  753|      0|        self.rotationAngle = angleForPoint(x: x, y: y) - _startAngle
  754|      0|    }
  755|       |    
  756|       |    @objc open func stopDeceleration()
  757|      0|    {
  758|      0|        if _decelerationDisplayLink !== nil
  759|      0|        {
  760|      0|            _decelerationDisplayLink.remove(from: RunLoop.main, forMode: RunLoop.Mode.common)
  761|      0|            _decelerationDisplayLink = nil
  762|      0|        }
  763|      0|    }
  764|       |    
  765|       |    @objc private func decelerationLoop()
  766|      0|    {
  767|      0|        let currentTime = CACurrentMediaTime()
  768|      0|        
  769|      0|        _decelerationAngularVelocity *= self.dragDecelerationFrictionCoef
  770|      0|        
  771|      0|        let timeInterval = CGFloat(currentTime - _decelerationLastTime)
  772|      0|        
  773|      0|        self.rotationAngle += _decelerationAngularVelocity * timeInterval
  774|      0|        
  775|      0|        _decelerationLastTime = currentTime
  776|      0|        
  777|      0|        if(abs(_decelerationAngularVelocity) < 0.001)
  778|      0|        {
  779|      0|            stopDeceleration()
  780|      0|        }
  781|      0|    }
  782|       |    
  783|       |    /// - Returns: The distance between two points
  784|       |    private func distance(eventX: CGFloat, startX: CGFloat, eventY: CGFloat, startY: CGFloat) -> CGFloat
  785|      0|    {
  786|      0|        let dx = eventX - startX
  787|      0|        let dy = eventY - startY
  788|      0|        return sqrt(dx * dx + dy * dy)
  789|      0|    }
  790|       |    
  791|       |    /// - Returns: The distance between two points
  792|       |    private func distance(from: CGPoint, to: CGPoint) -> CGFloat
  793|      0|    {
  794|      0|        let dx = from.x - to.x
  795|      0|        let dy = from.y - to.y
  796|      0|        return sqrt(dx * dx + dy * dy)
  797|      0|    }
  798|       |    
  799|       |    /// reference to the last highlighted object
  800|       |    private var _lastHighlight: Highlight!
  801|       |    
  802|       |    @objc private func tapGestureRecognized(_ recognizer: NSUITapGestureRecognizer)
  803|      0|    {
  804|      0|        if recognizer.state == NSUIGestureRecognizerState.ended
  805|      0|        {
  806|      0|            if !self.isHighLightPerTapEnabled { return }
  807|      0|            
  808|      0|            let location = recognizer.location(in: self)
  809|      0|            
  810|      0|            let high = self.getHighlightByTouchPoint(location)
  811|      0|            self.highlightValue(high, callDelegate: true)
  812|      0|        }
  813|      0|    }
  814|       |    
  815|       |    #if !os(tvOS)
  816|       |    @objc private func rotationGestureRecognized(_ recognizer: NSUIRotationGestureRecognizer)
  817|      0|    {
  818|      0|        if recognizer.state == NSUIGestureRecognizerState.began
  819|      0|        {
  820|      0|            stopDeceleration()
  821|      0|            
  822|      0|            _startAngle = self.rawRotationAngle
  823|      0|        }
  824|      0|        
  825|      0|        if recognizer.state == NSUIGestureRecognizerState.began || recognizer.state == NSUIGestureRecognizerState.changed
  826|      0|        {
  827|      0|            let angle = recognizer.nsuiRotation.RAD2DEG
  828|      0|            
  829|      0|            self.rotationAngle = _startAngle + angle
  830|      0|            setNeedsDisplay()
  831|      0|        }
  832|      0|        else if recognizer.state == NSUIGestureRecognizerState.ended
  833|      0|        {
  834|      0|            let angle = recognizer.nsuiRotation.RAD2DEG
  835|      0|            
  836|      0|            self.rotationAngle = _startAngle + angle
  837|      0|            setNeedsDisplay()
  838|      0|            
  839|      0|            if isDragDecelerationEnabled
  840|      0|            {
  841|      0|                stopDeceleration()
  842|      0|                
  843|      0|                _decelerationAngularVelocity = recognizer.velocity.RAD2DEG
  844|      0|                
  845|      0|                if _decelerationAngularVelocity != 0.0
  846|      0|                {
  847|      0|                    _decelerationLastTime = CACurrentMediaTime()
  848|      0|                    _decelerationDisplayLink = NSUIDisplayLink(target: self, selector: #selector(PieRadarChartViewBase.decelerationLoop))
  849|      0|                    _decelerationDisplayLink.add(to: RunLoop.main, forMode: RunLoop.Mode.common)
  850|      0|                }
  851|      0|            }
  852|      0|        }
  853|      0|    }
  854|       |    #endif
  855|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/RadarChartView.swift:
    1|       |//
    2|       |//  RadarChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |/// Implementation of the RadarChart, a "spidernet"-like chart. It works best
   17|       |/// when displaying 5-10 entries per DataSet.
   18|       |open class RadarChartView: PieRadarChartViewBase
   19|       |{
   20|       |    /// width of the web lines that come from the center.
   21|      0|    @objc open var webLineWidth = CGFloat(1.5)
   22|       |    
   23|       |    /// width of the web lines that are in between the lines coming from the center
   24|      0|    @objc open var innerWebLineWidth = CGFloat(0.75)
   25|       |    
   26|       |    /// color for the web lines that come from the center
   27|      0|    @objc open var webColor = NSUIColor(red: 122/255.0, green: 122/255.0, blue: 122.0/255.0, alpha: 1.0)
   28|       |    
   29|       |    /// color for the web lines in between the lines that come from the center.
   30|      0|    @objc open var innerWebColor = NSUIColor(red: 122/255.0, green: 122/255.0, blue: 122.0/255.0, alpha: 1.0)
   31|       |    
   32|       |    /// transparency the grid is drawn with (0.0 - 1.0)
   33|      0|    @objc open var webAlpha: CGFloat = 150.0 / 255.0
   34|       |    
   35|       |    /// flag indicating if the web lines should be drawn or not
   36|       |    @objc open var drawWeb = true
   37|       |    
   38|       |    /// modulus that determines how many labels and web-lines are skipped before the next is drawn
   39|       |    private var _skipWebLineCount = 0
   40|       |    
   41|       |    /// the object reprsenting the y-axis labels
   42|       |    private var _yAxis: YAxis!
   43|       |    
   44|       |    internal var _yAxisRenderer: YAxisRendererRadarChart!
   45|       |    internal var _xAxisRenderer: XAxisRendererRadarChart!
   46|       |    
   47|       |    public override init(frame: CGRect)
   48|      0|    {
   49|      0|        super.init(frame: frame)
   50|      0|    }
   51|       |    
   52|       |    public required init?(coder aDecoder: NSCoder)
   53|      0|    {
   54|      0|        super.init(coder: aDecoder)
   55|      0|    }
   56|       |    
   57|       |    internal override func initialize()
   58|      0|    {
   59|      0|        super.initialize()
   60|      0|        
   61|      0|        _yAxis = YAxis(position: .left)
   62|      0|        _yAxis.labelXOffset = 10.0
   63|      0|        
   64|      0|        renderer = RadarChartRenderer(chart: self, animator: _animator, viewPortHandler: _viewPortHandler)
   65|      0|        
   66|      0|        _yAxisRenderer = YAxisRendererRadarChart(viewPortHandler: _viewPortHandler, yAxis: _yAxis, chart: self)
   67|      0|        _xAxisRenderer = XAxisRendererRadarChart(viewPortHandler: _viewPortHandler, xAxis: _xAxis, chart: self)
   68|      0|        
   69|      0|        self.highlighter = RadarHighlighter(chart: self)
   70|      0|    }
   71|       |
   72|       |    internal override func calcMinMax()
   73|      0|    {
   74|      0|        super.calcMinMax()
   75|      0|        
   76|      0|        guard let data = _data else { return }
   77|      0|        
   78|      0|        _yAxis.calculate(min: data.getYMin(axis: .left), max: data.getYMax(axis: .left))
   79|      0|        _xAxis.calculate(min: 0.0, max: Double(data.maxEntryCountSet?.entryCount ?? 0))
   80|      0|    }
   81|       |    
   82|       |    open override func notifyDataSetChanged()
   83|      0|    {
   84|      0|        calcMinMax()
   85|      0|
   86|      0|        _yAxisRenderer?.computeAxis(min: _yAxis._axisMinimum, max: _yAxis._axisMaximum, inverted: _yAxis.isInverted)
   87|      0|        _xAxisRenderer?.computeAxis(min: _xAxis._axisMinimum, max: _xAxis._axisMaximum, inverted: false)
   88|      0|        
   89|      0|        if let data = _data,
   90|      0|            let legend = _legend,
   91|      0|            !legend.isLegendCustom
   92|      0|        {
   93|      0|            legendRenderer?.computeLegend(data: data)
   94|      0|        }
   95|      0|        
   96|      0|        calculateOffsets()
   97|      0|        
   98|      0|        setNeedsDisplay()
   99|      0|    }
  100|       |    
  101|       |    open override func draw(_ rect: CGRect)
  102|      0|    {
  103|      0|        super.draw(rect)
  104|      0|
  105|      0|        guard data != nil, let renderer = renderer else { return }
  106|      0|        
  107|      0|        let optionalContext = NSUIGraphicsGetCurrentContext()
  108|      0|        guard let context = optionalContext else { return }
  109|      0|        
  110|      0|        if _xAxis.isEnabled
  111|      0|        {
  112|      0|            _xAxisRenderer.computeAxis(min: _xAxis._axisMinimum, max: _xAxis._axisMaximum, inverted: false)
  113|      0|        }
  114|      0|        
  115|      0|        _xAxisRenderer?.renderAxisLabels(context: context)
  116|      0|        
  117|      0|        if drawWeb
  118|      0|        {
  119|      0|            renderer.drawExtras(context: context)
  120|      0|        }
  121|      0|        
  122|      0|        if _yAxis.isEnabled && _yAxis.isDrawLimitLinesBehindDataEnabled
  123|      0|        {
  124|      0|            _yAxisRenderer.renderLimitLines(context: context)
  125|      0|        }
  126|      0|
  127|      0|        renderer.drawData(context: context)
  128|      0|
  129|      0|        if valuesToHighlight()
  130|      0|        {
  131|      0|            renderer.drawHighlighted(context: context, indices: _indicesToHighlight)
  132|      0|        }
  133|      0|        
  134|      0|        if _yAxis.isEnabled && !_yAxis.isDrawLimitLinesBehindDataEnabled
  135|      0|        {
  136|      0|            _yAxisRenderer.renderLimitLines(context: context)
  137|      0|        }
  138|      0|        
  139|      0|        _yAxisRenderer.renderAxisLabels(context: context)
  140|      0|
  141|      0|        renderer.drawValues(context: context)
  142|      0|
  143|      0|        legendRenderer.renderLegend(context: context)
  144|      0|
  145|      0|        drawDescription(context: context)
  146|      0|
  147|      0|        drawMarkers(context: context)
  148|      0|    }
  149|       |
  150|       |    /// The factor that is needed to transform values into pixels.
  151|       |    @objc open var factor: CGFloat
  152|      0|    {
  153|      0|        let content = _viewPortHandler.contentRect
  154|      0|        return min(content.width / 2.0, content.height / 2.0)
  155|      0|                / CGFloat(_yAxis.axisRange)
  156|      0|    }
  157|       |
  158|       |    /// The angle that each slice in the radar chart occupies.
  159|       |    @objc open var sliceAngle: CGFloat
  160|      0|    {
  161|      0|        return 360.0 / CGFloat(_data?.maxEntryCountSet?.entryCount ?? 0)
  162|      0|    }
  163|       |
  164|       |    open override func indexForAngle(_ angle: CGFloat) -> Int
  165|      0|    {
  166|      0|        // take the current angle of the chart into consideration
  167|      0|        let a = (angle - self.rotationAngle).normalizedAngle
  168|      0|        
  169|      0|        let sliceAngle = self.sliceAngle
  170|      0|        
  171|      0|        let max = _data?.maxEntryCountSet?.entryCount ?? 0
  172|      0|        return (0..<max).firstIndex {
  173|      0|            sliceAngle * CGFloat($0 + 1) - sliceAngle / 2.0 > a
  174|      0|        } ?? max
  175|      0|    }
  176|       |
  177|       |    /// The object that represents all y-labels of the RadarChart.
  178|       |    @objc open var yAxis: YAxis
  179|      0|    {
  180|      0|        return _yAxis
  181|      0|    }
  182|       |
  183|       |    /// Sets the number of web-lines that should be skipped on chart web before the next one is drawn. This targets the lines that come from the center of the RadarChart.
  184|       |    /// if count = 1 -> 1 line is skipped in between
  185|       |    @objc open var skipWebLineCount: Int
  186|       |    {
  187|       |        get
  188|      0|        {
  189|      0|            return _skipWebLineCount
  190|      0|        }
  191|       |        set
  192|      0|        {
  193|      0|            _skipWebLineCount = max(0, newValue)
  194|      0|        }
  195|       |    }
  196|       |    
  197|       |    internal override var requiredLegendOffset: CGFloat
  198|      0|    {
  199|      0|        return _legend.font.pointSize * 4.0
  200|      0|    }
  201|       |
  202|       |    internal override var requiredBaseOffset: CGFloat
  203|      0|    {
  204|      0|        return _xAxis.isEnabled && _xAxis.isDrawLabelsEnabled ? _xAxis.labelRotatedWidth : 10.0
  205|      0|    }
  206|       |
  207|       |    open override var radius: CGFloat
  208|      0|    {
  209|      0|        let content = _viewPortHandler.contentRect
  210|      0|        return min(content.width / 2.0, content.height / 2.0)
  211|      0|    }
  212|       |
  213|       |    /// The maximum value this chart can display on it's y-axis.
  214|      0|    open override var chartYMax: Double { return _yAxis._axisMaximum }
  215|       |    
  216|       |    /// The minimum value this chart can display on it's y-axis.
  217|      0|    open override var chartYMin: Double { return _yAxis._axisMinimum }
  218|       |    
  219|       |    /// The range of y-values this chart can display.
  220|      0|    @objc open var yRange: Double { return _yAxis.axisRange }
  221|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Charts/ScatterChartView.swift:
    1|       |//
    2|       |//  ScatterChartView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// The ScatterChart. Draws dots, triangles, squares and custom shapes into the chartview.
   16|       |open class ScatterChartView: BarLineChartViewBase, ScatterChartDataProvider
   17|       |{
   18|       |    open override func initialize()
   19|      0|    {
   20|      0|        super.initialize()
   21|      0|        
   22|      0|        renderer = ScatterChartRenderer(dataProvider: self, animator: _animator, viewPortHandler: _viewPortHandler)
   23|      0|
   24|      0|        xAxis.spaceMin = 0.5
   25|      0|        xAxis.spaceMax = 0.5
   26|      0|    }
   27|       |    
   28|       |    // MARK: - ScatterChartDataProvider
   29|       |    
   30|      0|    open var scatterData: ScatterChartData? { return _data as? ScatterChartData }
   31|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/AxisBase.swift:
    1|       |//
    2|       |//  AxisBase.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// Base class for all axes
   16|       |@objc(ChartAxisBase)
   17|       |open class AxisBase: ComponentBase
   18|       |{
   19|       |    public override init()
   20|      0|    {
   21|      0|        super.init()
   22|      0|    }
   23|       |    
   24|       |    /// Custom formatter that is used instead of the auto-formatter if set
   25|       |    private var _axisValueFormatter: IAxisValueFormatter?
   26|       |    
   27|      0|    @objc open var labelFont = NSUIFont.systemFont(ofSize: 10.0)
   28|      0|    @objc open var labelTextColor = NSUIColor.labelOrBlack
   29|       |    
   30|      0|    @objc open var axisLineColor = NSUIColor.gray
   31|      0|    @objc open var axisLineWidth = CGFloat(0.5)
   32|      0|    @objc open var axisLineDashPhase = CGFloat(0.0)
   33|       |    @objc open var axisLineDashLengths: [CGFloat]!
   34|       |    
   35|      0|    @objc open var gridColor = NSUIColor.gray.withAlphaComponent(0.9)
   36|      0|    @objc open var gridLineWidth = CGFloat(0.5)
   37|      0|    @objc open var gridLineDashPhase = CGFloat(0.0)
   38|       |    @objc open var gridLineDashLengths: [CGFloat]!
   39|      0|    @objc open var gridLineCap = CGLineCap.butt
   40|       |    
   41|       |    @objc open var drawGridLinesEnabled = true
   42|       |    @objc open var drawAxisLineEnabled = true
   43|       |    
   44|       |    /// flag that indicates of the labels of this axis should be drawn or not
   45|       |    @objc open var drawLabelsEnabled = true
   46|       |    
   47|       |    private var _centerAxisLabelsEnabled = false
   48|       |
   49|       |    /// Centers the axis labels instead of drawing them at their original position.
   50|       |    /// This is useful especially for grouped BarChart.
   51|       |    @objc open var centerAxisLabelsEnabled: Bool
   52|       |    {
   53|      0|        get { return _centerAxisLabelsEnabled && entryCount > 0 }
   54|      0|        set { _centerAxisLabelsEnabled = newValue }
   55|       |    }
   56|       |    
   57|       |    @objc open var isCenterAxisLabelsEnabled: Bool
   58|       |    {
   59|      0|        get { return centerAxisLabelsEnabled }
   60|       |    }
   61|       |
   62|       |    /// array of limitlines that can be set for the axis
   63|      0|    private var _limitLines = [ChartLimitLine]()
   64|       |    
   65|       |    /// Are the LimitLines drawn behind the data or in front of the data?
   66|       |    ///
   67|       |    /// **default**: false
   68|       |    @objc open var drawLimitLinesBehindDataEnabled = false
   69|       |    
   70|       |    /// Are the grid lines drawn behind the data or in front of the data?
   71|       |    ///
   72|       |    /// **default**: true
   73|       |    @objc open var drawGridLinesBehindDataEnabled = true
   74|       |
   75|       |    /// the flag can be used to turn off the antialias for grid lines
   76|       |    @objc open var gridAntialiasEnabled = true
   77|       |    
   78|       |    /// the actual array of entries
   79|      0|    @objc open var entries = [Double]()
   80|       |    
   81|       |    /// axis label entries only used for centered labels
   82|      0|    @objc open var centeredEntries = [Double]()
   83|       |    
   84|       |    /// the number of entries the legend contains
   85|      0|    @objc open var entryCount: Int { return entries.count }
   86|       |    
   87|       |    /// the number of label entries the axis should have
   88|       |    ///
   89|       |    /// **default**: 6
   90|      0|    private var _labelCount = Int(6)
   91|       |    
   92|       |    /// the number of decimal digits to use (for the default formatter
   93|       |    @objc open var decimals: Int = 0
   94|       |    
   95|       |    /// When true, axis labels are controlled by the `granularity` property.
   96|       |    /// When false, axis values could possibly be repeated.
   97|       |    /// This could happen if two adjacent axis values are rounded to same value.
   98|       |    /// If using granularity this could be avoided by having fewer axis values visible.
   99|       |    @objc open var granularityEnabled = false
  100|       |    
  101|      0|    private var _granularity = Double(1.0)
  102|       |    
  103|       |    /// The minimum interval between axis values.
  104|       |    /// This can be used to avoid label duplicating when zooming in.
  105|       |    ///
  106|       |    /// **default**: 1.0
  107|       |    @objc open var granularity: Double
  108|       |    {
  109|       |        get
  110|      0|        {
  111|      0|            return _granularity
  112|      0|        }
  113|       |        set
  114|      0|        {
  115|      0|            _granularity = newValue
  116|      0|            
  117|      0|            // set this to `true` if it was disabled, as it makes no sense to set this property with granularity disabled
  118|      0|            granularityEnabled = true
  119|      0|        }
  120|       |    }
  121|       |    
  122|       |    /// The minimum interval between axis values.
  123|       |    @objc open var isGranularityEnabled: Bool
  124|       |    {
  125|       |        get
  126|      0|        {
  127|      0|            return granularityEnabled
  128|      0|        }
  129|       |    }
  130|       |    
  131|       |    /// if true, the set number of y-labels will be forced
  132|       |    @objc open var forceLabelsEnabled = false
  133|       |    
  134|       |    @objc open func getLongestLabel() -> String
  135|      0|    {
  136|      0|        var longest = ""
  137|      0|        
  138|      0|        for i in 0 ..< entries.count
  139|      0|        {
  140|      0|            let text = getFormattedLabel(i)
  141|      0|            
  142|      0|            if longest.count < text.count
  143|      0|            {
  144|      0|                longest = text
  145|      0|            }
  146|      0|        }
  147|      0|        
  148|      0|        return longest
  149|      0|    }
  150|       |    
  151|       |    /// - Returns: The formatted label at the specified index. This will either use the auto-formatter or the custom formatter (if one is set).
  152|       |    @objc open func getFormattedLabel(_ index: Int) -> String
  153|      0|    {
  154|      0|        if index < 0 || index >= entries.count
  155|      0|        {
  156|      0|            return ""
  157|      0|        }
  158|      0|        
  159|      0|        return valueFormatter?.stringForValue(entries[index], axis: self) ?? ""
  160|      0|    }
  161|       |    
  162|       |    /// Sets the formatter to be used for formatting the axis labels.
  163|       |    /// If no formatter is set, the chart will automatically determine a reasonable formatting (concerning decimals) for all the values that are drawn inside the chart.
  164|       |    /// Use `nil` to use the formatter calculated by the chart.
  165|       |    @objc open var valueFormatter: IAxisValueFormatter?
  166|       |    {
  167|       |        get
  168|      0|        {
  169|      0|            if _axisValueFormatter == nil ||
  170|      0|                (_axisValueFormatter is DefaultAxisValueFormatter &&
  171|      0|                    (_axisValueFormatter as! DefaultAxisValueFormatter).hasAutoDecimals &&
  172|      0|                    (_axisValueFormatter as! DefaultAxisValueFormatter).decimals != decimals)
  173|      0|            {
  174|      0|                _axisValueFormatter = DefaultAxisValueFormatter(decimals: decimals)
  175|      0|            }
  176|      0|            
  177|      0|            return _axisValueFormatter
  178|      0|        }
  179|       |        set
  180|      0|        {
  181|      0|            _axisValueFormatter = newValue ?? DefaultAxisValueFormatter(decimals: decimals)
  182|      0|        }
  183|       |    }
  184|       |    
  185|      0|    @objc open var isDrawGridLinesEnabled: Bool { return drawGridLinesEnabled }
  186|       |    
  187|      0|    @objc open var isDrawAxisLineEnabled: Bool { return drawAxisLineEnabled }
  188|       |    
  189|      0|    @objc open var isDrawLabelsEnabled: Bool { return drawLabelsEnabled }
  190|       |    
  191|       |    /// Are the LimitLines drawn behind the data or in front of the data?
  192|       |    /// 
  193|       |    /// **default**: false
  194|      0|    @objc open var isDrawLimitLinesBehindDataEnabled: Bool { return drawLimitLinesBehindDataEnabled }
  195|       |    
  196|       |    /// Are the grid lines drawn behind the data or in front of the data?
  197|       |    ///
  198|       |    /// **default**: true
  199|      0|    @objc open var isDrawGridLinesBehindDataEnabled: Bool { return drawGridLinesBehindDataEnabled }
  200|       |    
  201|       |    /// Extra spacing for `axisMinimum` to be added to automatically calculated `axisMinimum`
  202|       |    @objc open var spaceMin: Double = 0.0
  203|       |    
  204|       |    /// Extra spacing for `axisMaximum` to be added to automatically calculated `axisMaximum`
  205|       |    @objc open var spaceMax: Double = 0.0
  206|       |    
  207|       |    /// Flag indicating that the axis-min value has been customized
  208|       |    internal var _customAxisMin: Bool = false
  209|       |    
  210|       |    /// Flag indicating that the axis-max value has been customized
  211|       |    internal var _customAxisMax: Bool = false
  212|       |    
  213|       |    /// Do not touch this directly, instead, use axisMinimum.
  214|       |    /// This is automatically calculated to represent the real min value,
  215|       |    /// and is used when calculating the effective minimum.
  216|      0|    internal var _axisMinimum = Double(0)
  217|       |    
  218|       |    /// Do not touch this directly, instead, use axisMaximum.
  219|       |    /// This is automatically calculated to represent the real max value,
  220|       |    /// and is used when calculating the effective maximum.
  221|      0|    internal var _axisMaximum = Double(0)
  222|       |    
  223|       |    /// the total range of values this axis covers
  224|      0|    @objc open var axisRange = Double(0)
  225|       |    
  226|       |    /// The minumum number of labels on the axis
  227|      0|    @objc open var axisMinLabels = Int(2) {
  228|      0|        didSet { axisMinLabels = axisMinLabels > 0 ? axisMinLabels : oldValue }
  229|       |    }
  230|       |    
  231|       |    /// The maximum number of labels on the axis
  232|      0|    @objc open var axisMaxLabels = Int(25) {
  233|      0|        didSet { axisMaxLabels = axisMaxLabels > 0 ? axisMaxLabels : oldValue }
  234|       |    }
  235|       |    
  236|       |    /// the number of label entries the axis should have
  237|       |    /// max = 25,
  238|       |    /// min = 2,
  239|       |    /// default = 6,
  240|       |    /// be aware that this number is not fixed and can only be approximated
  241|       |    @objc open var labelCount: Int
  242|       |    {
  243|       |        get
  244|      0|        {
  245|      0|            return _labelCount
  246|      0|        }
  247|       |        set
  248|      0|        {
  249|      0|            let range = axisMinLabels...axisMaxLabels as ClosedRange
  250|      0|            _labelCount = newValue.clamped(to: range)
  251|      0|                        
  252|      0|            forceLabelsEnabled = false
  253|      0|        }
  254|       |    }
  255|       |    
  256|       |    @objc open func setLabelCount(_ count: Int, force: Bool)
  257|      0|    {
  258|      0|        self.labelCount = count
  259|      0|        forceLabelsEnabled = force
  260|      0|    }
  261|       |    
  262|       |    /// `true` if focing the y-label count is enabled. Default: false
  263|      0|    @objc open var isForceLabelsEnabled: Bool { return forceLabelsEnabled }
  264|       |    
  265|       |    /// Adds a new ChartLimitLine to this axis.
  266|       |    @objc open func addLimitLine(_ line: ChartLimitLine)
  267|      0|    {
  268|      0|        _limitLines.append(line)
  269|      0|    }
  270|       |    
  271|       |    /// Removes the specified ChartLimitLine from the axis.
  272|       |    @objc open func removeLimitLine(_ line: ChartLimitLine)
  273|      0|    {
  274|      0|        guard let i = _limitLines.firstIndex(of: line) else { return }
  275|      0|        _limitLines.remove(at: i)
  276|      0|    }
  277|       |    
  278|       |    /// Removes all LimitLines from the axis.
  279|       |    @objc open func removeAllLimitLines()
  280|      0|    {
  281|      0|        _limitLines.removeAll(keepingCapacity: false)
  282|      0|    }
  283|       |    
  284|       |    /// The LimitLines of this axis.
  285|       |    @objc open var limitLines : [ChartLimitLine]
  286|      0|    {
  287|      0|        return _limitLines
  288|      0|    }
  289|       |    
  290|       |    // MARK: Custom axis ranges
  291|       |    
  292|       |    /// By calling this method, any custom minimum value that has been previously set is reseted, and the calculation is done automatically.
  293|       |    @objc open func resetCustomAxisMin()
  294|      0|    {
  295|      0|        _customAxisMin = false
  296|      0|    }
  297|       |    
  298|      0|    @objc open var isAxisMinCustom: Bool { return _customAxisMin }
  299|       |    
  300|       |    /// By calling this method, any custom maximum value that has been previously set is reseted, and the calculation is done automatically.
  301|       |    @objc open func resetCustomAxisMax()
  302|      0|    {
  303|      0|        _customAxisMax = false
  304|      0|    }
  305|       |    
  306|      0|    @objc open var isAxisMaxCustom: Bool { return _customAxisMax }
  307|       |        
  308|       |    /// The minimum value for this axis.
  309|       |    /// If set, this value will not be calculated automatically depending on the provided data.
  310|       |    /// Use `resetCustomAxisMin()` to undo this.
  311|       |    @objc open var axisMinimum: Double
  312|       |    {
  313|       |        get
  314|      0|        {
  315|      0|            return _axisMinimum
  316|      0|        }
  317|       |        set
  318|      0|        {
  319|      0|            _customAxisMin = true
  320|      0|            _axisMinimum = newValue
  321|      0|            axisRange = abs(_axisMaximum - newValue)
  322|      0|        }
  323|       |    }
  324|       |    
  325|       |    /// The maximum value for this axis.
  326|       |    /// If set, this value will not be calculated automatically depending on the provided data.
  327|       |    /// Use `resetCustomAxisMax()` to undo this.
  328|       |    @objc open var axisMaximum: Double
  329|       |    {
  330|       |        get
  331|      0|        {
  332|      0|            return _axisMaximum
  333|      0|        }
  334|       |        set
  335|      0|        {
  336|      0|            _customAxisMax = true
  337|      0|            _axisMaximum = newValue
  338|      0|            axisRange = abs(newValue - _axisMinimum)
  339|      0|        }
  340|       |    }
  341|       |    
  342|       |    /// Calculates the minimum, maximum and range values of the YAxis with the given minimum and maximum values from the chart data.
  343|       |    ///
  344|       |    /// - Parameters:
  345|       |    ///   - dataMin: the y-min value according to chart data
  346|       |    ///   - dataMax: the y-max value according to chart
  347|       |    @objc open func calculate(min dataMin: Double, max dataMax: Double)
  348|      0|    {
  349|      0|        // if custom, use value as is, else use data value
  350|      0|        var min = _customAxisMin ? _axisMinimum : (dataMin - spaceMin)
  351|      0|        var max = _customAxisMax ? _axisMaximum : (dataMax + spaceMax)
  352|      0|        
  353|      0|        // temporary range (before calculations)
  354|      0|        let range = abs(max - min)
  355|      0|        
  356|      0|        // in case all values are equal
  357|      0|        if range == 0.0
  358|      0|        {
  359|      0|            max = max + 1.0
  360|      0|            min = min - 1.0
  361|      0|        }
  362|      0|        
  363|      0|        _axisMinimum = min
  364|      0|        _axisMaximum = max
  365|      0|        
  366|      0|        // actual range
  367|      0|        axisRange = abs(max - min)
  368|      0|    }
  369|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/ChartLimitLine.swift:
    1|       |//
    2|       |//  ChartLimitLine.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |/// The limit line is an additional feature for all Line, Bar and ScatterCharts.
   17|       |/// It allows the displaying of an additional line in the chart that marks a certain maximum / limit on the specified axis (x- or y-axis).
   18|       |open class ChartLimitLine: ComponentBase
   19|       |{
   20|       |    @objc(ChartLimitLabelPosition)
   21|       |    public enum LabelPosition: Int
   22|       |    {
   23|       |        case topLeft
   24|       |        case topRight
   25|       |        case bottomLeft
   26|       |        case bottomRight
   27|       |    }
   28|       |    
   29|       |    /// limit / maximum (the y-value or xIndex)
   30|      0|    @objc open var limit = Double(0.0)
   31|       |    
   32|      0|    private var _lineWidth = CGFloat(2.0)
   33|      0|    @objc open var lineColor = NSUIColor(red: 237.0/255.0, green: 91.0/255.0, blue: 91.0/255.0, alpha: 1.0)
   34|      0|    @objc open var lineDashPhase = CGFloat(0.0)
   35|       |    @objc open var lineDashLengths: [CGFloat]?
   36|       |    
   37|      0|    @objc open var valueTextColor = NSUIColor.labelOrBlack
   38|      0|    @objc open var valueFont = NSUIFont.systemFont(ofSize: 13.0)
   39|       |    
   40|       |    @objc open var drawLabelEnabled = true
   41|       |    @objc open var label = ""
   42|      0|    @objc open var labelPosition = LabelPosition.topRight
   43|       |    
   44|       |    public override init()
   45|      0|    {
   46|      0|        super.init()
   47|      0|    }
   48|       |    
   49|       |    @objc public init(limit: Double)
   50|      0|    {
   51|      0|        super.init()
   52|      0|        self.limit = limit
   53|      0|    }
   54|       |    
   55|       |    @objc public init(limit: Double, label: String)
   56|      0|    {
   57|      0|        super.init()
   58|      0|        self.limit = limit
   59|      0|        self.label = label
   60|      0|    }
   61|       |    
   62|       |    /// set the line width of the chart (min = 0.2, max = 12); default 2
   63|       |    @objc open var lineWidth: CGFloat
   64|       |    {
   65|       |        get
   66|      0|        {
   67|      0|            return _lineWidth
   68|      0|        }
   69|       |        set
   70|      0|        {
   71|      0|            _lineWidth = newValue.clamped(to: 0.2...12)
   72|      0|        }
   73|       |    }
   74|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/ComponentBase.swift:
    1|       |//
    2|       |//  ComponentBase.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |/// This class encapsulates everything both Axis, Legend and LimitLines have in common
   17|       |@objc(ChartComponentBase)
   18|       |open class ComponentBase: NSObject
   19|       |{
   20|       |    /// flag that indicates if this component is enabled or not
   21|       |    @objc open var enabled = true
   22|       |    
   23|       |    /// The offset this component has on the x-axis
   24|       |    /// **default**: 5.0
   25|      0|    @objc open var xOffset = CGFloat(5.0)
   26|       |    
   27|       |    /// The offset this component has on the x-axis
   28|       |    /// **default**: 5.0 (or 0.0 on ChartYAxis)
   29|      0|    @objc open var yOffset = CGFloat(5.0)
   30|       |    
   31|       |    public override init()
   32|      0|    {
   33|      0|        super.init()
   34|      0|    }
   35|       |
   36|      0|    @objc open var isEnabled: Bool { return enabled }
   37|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/Description.swift:
    1|       |//
    2|       |//  Description.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |@objc(ChartDescription)
   24|       |open class Description: ComponentBase
   25|       |{
   26|       |    public override init()
   27|      0|    {
   28|      0|        #if os(tvOS)
   29|      0|        // 23 is the smallest recommended font size on the TV
   30|      0|        font = .systemFont(ofSize: 23)
   31|      0|        #elseif os(OSX)
   32|      0|        font = .systemFont(ofSize: NSUIFont.systemFontSize)
   33|      0|        #else
   34|      0|        font = .systemFont(ofSize: 8.0)
   35|      0|        #endif
   36|      0|        
   37|      0|        super.init()
   38|      0|    }
   39|       |    
   40|       |    /// The text to be shown as the description.
   41|       |    @objc open var text: String?
   42|       |    
   43|       |    /// Custom position for the description text in pixels on the screen.
   44|       |    open var position: CGPoint? = nil
   45|       |    
   46|       |    /// The text alignment of the description text. Default RIGHT.
   47|      0|    @objc open var textAlign: NSTextAlignment = NSTextAlignment.right
   48|       |    
   49|       |    /// Font object used for drawing the description text.
   50|       |    @objc open var font: NSUIFont
   51|       |    
   52|       |    /// Text color used for drawing the description text
   53|      0|    @objc open var textColor = NSUIColor.labelOrBlack
   54|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/Legend.swift:
    1|       |//
    2|       |//  Legend.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartLegend)
   16|       |open class Legend: ComponentBase
   17|       |{
   18|       |    @objc(ChartLegendForm)
   19|       |    public enum Form: Int
   20|       |    {
   21|       |        /// Avoid drawing a form
   22|       |        case none
   23|       |        
   24|       |        /// Do not draw the a form, but leave space for it
   25|       |        case empty
   26|       |        
   27|       |        /// Use default (default dataset's form to the legend's form)
   28|       |        case `default`
   29|       |        
   30|       |        /// Draw a square
   31|       |        case square
   32|       |        
   33|       |        /// Draw a circle
   34|       |        case circle
   35|       |        
   36|       |        /// Draw a horizontal line
   37|       |        case line
   38|       |    }
   39|       |    
   40|       |    @objc(ChartLegendHorizontalAlignment)
   41|       |    public enum HorizontalAlignment: Int
   42|       |    {
   43|       |        case left
   44|       |        case center
   45|       |        case right
   46|       |    }
   47|       |    
   48|       |    @objc(ChartLegendVerticalAlignment)
   49|       |    public enum VerticalAlignment: Int
   50|       |    {
   51|       |        case top
   52|       |        case center
   53|       |        case bottom
   54|       |    }
   55|       |    
   56|       |    @objc(ChartLegendOrientation)
   57|       |    public enum Orientation: Int
   58|       |    {
   59|       |        case horizontal
   60|       |        case vertical
   61|       |    }
   62|       |    
   63|       |    @objc(ChartLegendDirection)
   64|       |    public enum Direction: Int
   65|       |    {
   66|       |        case leftToRight
   67|       |        case rightToLeft
   68|       |    }
   69|       |    
   70|       |    /// The legend entries array
   71|      0|    @objc open var entries = [LegendEntry]()
   72|       |    
   73|       |    /// Entries that will be appended to the end of the auto calculated entries after calculating the legend.
   74|       |    /// (if the legend has already been calculated, you will need to call notifyDataSetChanged() to let the changes take effect)
   75|      0|    @objc open var extraEntries = [LegendEntry]()
   76|       |    
   77|       |    /// Are the legend labels/colors a custom value or auto calculated? If false, then it's auto, if true, then custom.
   78|       |    /// 
   79|       |    /// **default**: false (automatic legend)
   80|       |    private var _isLegendCustom = false
   81|       |
   82|       |    /// The horizontal alignment of the legend
   83|      0|    @objc open var horizontalAlignment: HorizontalAlignment = HorizontalAlignment.left
   84|       |    
   85|       |    /// The vertical alignment of the legend
   86|      0|    @objc open var verticalAlignment: VerticalAlignment = VerticalAlignment.bottom
   87|       |    
   88|       |    /// The orientation of the legend
   89|      0|    @objc open var orientation: Orientation = Orientation.horizontal
   90|       |    
   91|       |    /// Flag indicating whether the legend will draw inside the chart or outside
   92|       |    @objc open var drawInside: Bool = false
   93|       |    
   94|       |    /// Flag indicating whether the legend will draw inside the chart or outside
   95|      0|    @objc open var isDrawInsideEnabled: Bool { return drawInside }
   96|       |    
   97|       |    /// The text direction of the legend
   98|      0|    @objc open var direction: Direction = Direction.leftToRight
   99|       |
  100|      0|    @objc open var font: NSUIFont = NSUIFont.systemFont(ofSize: 10.0)
  101|      0|    @objc open var textColor = NSUIColor.labelOrBlack
  102|       |
  103|       |    /// The form/shape of the legend forms
  104|      0|    @objc open var form = Form.square
  105|       |    
  106|       |    /// The size of the legend forms
  107|      0|    @objc open var formSize = CGFloat(8.0)
  108|       |    
  109|       |    /// The line width for forms that consist of lines
  110|      0|    @objc open var formLineWidth = CGFloat(3.0)
  111|       |    
  112|       |    /// Line dash configuration for shapes that consist of lines.
  113|       |    ///
  114|       |    /// This is how much (in pixels) into the dash pattern are we starting from.
  115|       |    @objc open var formLineDashPhase: CGFloat = 0.0
  116|       |    
  117|       |    /// Line dash configuration for shapes that consist of lines.
  118|       |    ///
  119|       |    /// This is the actual dash pattern.
  120|       |    /// I.e. [2, 3] will paint [--   --   ]
  121|       |    /// [1, 3, 4, 2] will paint [-   ----  -   ----  ]
  122|       |    @objc open var formLineDashLengths: [CGFloat]?
  123|       |    
  124|      0|    @objc open var xEntrySpace = CGFloat(6.0)
  125|      0|    @objc open var yEntrySpace = CGFloat(0.0)
  126|      0|    @objc open var formToTextSpace = CGFloat(5.0)
  127|      0|    @objc open var stackSpace = CGFloat(3.0)
  128|       |    
  129|      0|    @objc open var calculatedLabelSizes = [CGSize]()
  130|      0|    @objc open var calculatedLabelBreakPoints = [Bool]()
  131|      0|    @objc open var calculatedLineSizes = [CGSize]()
  132|       |    
  133|       |    public override init()
  134|      0|    {
  135|      0|        super.init()
  136|      0|        
  137|      0|        self.xOffset = 5.0
  138|      0|        self.yOffset = 3.0
  139|      0|    }
  140|       |    
  141|       |    @objc public init(entries: [LegendEntry])
  142|      0|    {
  143|      0|        super.init()
  144|      0|        
  145|      0|        self.entries = entries
  146|      0|    }
  147|       |    
  148|       |    @objc open func getMaximumEntrySize(withFont font: NSUIFont) -> CGSize
  149|      0|    {
  150|      0|        var maxW = CGFloat(0.0)
  151|      0|        var maxH = CGFloat(0.0)
  152|      0|        
  153|      0|        var maxFormSize: CGFloat = 0.0
  154|      0|
  155|      0|        for entry in entries
  156|      0|        {
  157|      0|            let formSize = entry.formSize.isNaN ? self.formSize : entry.formSize
  158|      0|            if formSize > maxFormSize
  159|      0|            {
  160|      0|                maxFormSize = formSize
  161|      0|            }
  162|      0|            
  163|      0|            guard let label = entry.label
  164|      0|                else { continue }
  165|      0|            
  166|      0|            let size = (label as NSString).size(withAttributes: [.font: font])
  167|      0|            
  168|      0|            if size.width > maxW
  169|      0|            {
  170|      0|                maxW = size.width
  171|      0|            }
  172|      0|            if size.height > maxH
  173|      0|            {
  174|      0|                maxH = size.height
  175|      0|            }
  176|      0|        }
  177|      0|        
  178|      0|        return CGSize(
  179|      0|            width: maxW + maxFormSize + formToTextSpace,
  180|      0|            height: maxH
  181|      0|        )
  182|      0|    }
  183|       |
  184|      0|    @objc open var neededWidth = CGFloat(0.0)
  185|      0|    @objc open var neededHeight = CGFloat(0.0)
  186|      0|    @objc open var textWidthMax = CGFloat(0.0)
  187|      0|    @objc open var textHeightMax = CGFloat(0.0)
  188|       |    
  189|       |    /// flag that indicates if word wrapping is enabled
  190|       |    /// this is currently supported only for `orientation == Horizontal`.
  191|       |    /// you may want to set maxSizePercent when word wrapping, to set the point where the text wraps.
  192|       |    /// 
  193|       |    /// **default**: true
  194|       |    @objc open var wordWrapEnabled = true
  195|       |    
  196|       |    /// if this is set, then word wrapping the legend is enabled.
  197|      0|    @objc open var isWordWrapEnabled: Bool { return wordWrapEnabled }
  198|       |
  199|       |    /// The maximum relative size out of the whole chart view in percent.
  200|       |    /// If the legend is to the right/left of the chart, then this affects the width of the legend.
  201|       |    /// If the legend is to the top/bottom of the chart, then this affects the height of the legend.
  202|       |    /// 
  203|       |    /// **default**: 0.95 (95%)
  204|       |    @objc open var maxSizePercent: CGFloat = 0.95
  205|       |    
  206|       |    @objc open func calculateDimensions(labelFont: NSUIFont, viewPortHandler: ViewPortHandler)
  207|      0|    {
  208|      0|        let maxEntrySize = getMaximumEntrySize(withFont: labelFont)
  209|      0|        let defaultFormSize = self.formSize
  210|      0|        let stackSpace = self.stackSpace
  211|      0|        let formToTextSpace = self.formToTextSpace
  212|      0|        let xEntrySpace = self.xEntrySpace
  213|      0|        let yEntrySpace = self.yEntrySpace
  214|      0|        let wordWrapEnabled = self.wordWrapEnabled
  215|      0|        let entries = self.entries
  216|      0|        let entryCount = entries.count
  217|      0|        
  218|      0|        textWidthMax = maxEntrySize.width
  219|      0|        textHeightMax = maxEntrySize.height
  220|      0|        
  221|      0|        switch orientation
  222|      0|        {
  223|      0|        case .vertical:
  224|      0|            
  225|      0|            var maxWidth = CGFloat(0.0)
  226|      0|            var width = CGFloat(0.0)
  227|      0|            var maxHeight = CGFloat(0.0)
  228|      0|            let labelLineHeight = labelFont.lineHeight
  229|      0|            
  230|      0|            var wasStacked = false
  231|      0|            
  232|      0|            for i in 0 ..< entryCount
  233|      0|            {
  234|      0|                let e = entries[i]
  235|      0|                let drawingForm = e.form != .none
  236|      0|                let formSize = e.formSize.isNaN ? defaultFormSize : e.formSize
  237|      0|                let label = e.label
  238|      0|                
  239|      0|                if !wasStacked
  240|      0|                {
  241|      0|                    width = 0.0
  242|      0|                }
  243|      0|                
  244|      0|                if drawingForm
  245|      0|                {
  246|      0|                    if wasStacked
  247|      0|                    {
  248|      0|                        width += stackSpace
  249|      0|                    }
  250|      0|                    width += formSize
  251|      0|                }
  252|      0|                
  253|      0|                if label != nil
  254|      0|                {
  255|      0|                    let size = (label! as NSString).size(withAttributes: [.font: labelFont])
  256|      0|                    
  257|      0|                    if drawingForm && !wasStacked
  258|      0|                    {
  259|      0|                        width += formToTextSpace
  260|      0|                    }
  261|      0|                    else if wasStacked
  262|      0|                    {
  263|      0|                        maxWidth = max(maxWidth, width)
  264|      0|                        maxHeight += labelLineHeight + yEntrySpace
  265|      0|                        width = 0.0
  266|      0|                        wasStacked = false
  267|      0|                    }
  268|      0|                    
  269|      0|                    width += size.width
  270|      0|                    maxHeight += labelLineHeight + yEntrySpace
  271|      0|                }
  272|      0|                else
  273|      0|                {
  274|      0|                    wasStacked = true
  275|      0|                    width += formSize
  276|      0|                    
  277|      0|                    if i < entryCount - 1
  278|      0|                    {
  279|      0|                        width += stackSpace
  280|      0|                    }
  281|      0|                }
  282|      0|                
  283|      0|                maxWidth = max(maxWidth, width)
  284|      0|            }
  285|      0|            
  286|      0|            neededWidth = maxWidth
  287|      0|            neededHeight = maxHeight
  288|      0|            
  289|      0|        case .horizontal:
  290|      0|            
  291|      0|            let labelLineHeight = labelFont.lineHeight
  292|      0|            
  293|      0|            let contentWidth: CGFloat = viewPortHandler.contentWidth * maxSizePercent
  294|      0|            
  295|      0|            // Prepare arrays for calculated layout
  296|      0|            if calculatedLabelSizes.count != entryCount
  297|      0|            {
  298|      0|                calculatedLabelSizes = [CGSize](repeating: CGSize(), count: entryCount)
  299|      0|            }
  300|      0|            
  301|      0|            if calculatedLabelBreakPoints.count != entryCount
  302|      0|            {
  303|      0|                calculatedLabelBreakPoints = [Bool](repeating: false, count: entryCount)
  304|      0|            }
  305|      0|            
  306|      0|            calculatedLineSizes.removeAll(keepingCapacity: true)
  307|      0|            
  308|      0|            // Start calculating layout
  309|      0|            
  310|      0|            let labelAttrs = [NSAttributedString.Key.font: labelFont]
  311|      0|            var maxLineWidth: CGFloat = 0.0
  312|      0|            var currentLineWidth: CGFloat = 0.0
  313|      0|            var requiredWidth: CGFloat = 0.0
  314|      0|            var stackedStartIndex: Int = -1
  315|      0|            
  316|      0|            for i in 0 ..< entryCount
  317|      0|            {
  318|      0|                let e = entries[i]
  319|      0|                let drawingForm = e.form != .none
  320|      0|                let label = e.label
  321|      0|                
  322|      0|                calculatedLabelBreakPoints[i] = false
  323|      0|                
  324|      0|                if stackedStartIndex == -1
  325|      0|                {
  326|      0|                    // we are not stacking, so required width is for this label only
  327|      0|                    requiredWidth = 0.0
  328|      0|                }
  329|      0|                else
  330|      0|                {
  331|      0|                    // add the spacing appropriate for stacked labels/forms
  332|      0|                    requiredWidth += stackSpace
  333|      0|                }
  334|      0|                
  335|      0|                // grouped forms have null labels
  336|      0|                if label != nil
  337|      0|                {
  338|      0|                    calculatedLabelSizes[i] = (label! as NSString).size(withAttributes: labelAttrs)
  339|      0|                    requiredWidth += drawingForm ? formToTextSpace + formSize : 0.0
  340|      0|                    requiredWidth += calculatedLabelSizes[i].width
  341|      0|                }
  342|      0|                else
  343|      0|                {
  344|      0|                    calculatedLabelSizes[i] = CGSize()
  345|      0|                    requiredWidth += drawingForm ? formSize : 0.0
  346|      0|                    
  347|      0|                    if stackedStartIndex == -1
  348|      0|                    {
  349|      0|                        // mark this index as we might want to break here later
  350|      0|                        stackedStartIndex = i
  351|      0|                    }
  352|      0|                }
  353|      0|                
  354|      0|                if label != nil || i == entryCount - 1
  355|      0|                {
  356|      0|                    let requiredSpacing = currentLineWidth == 0.0 ? 0.0 : xEntrySpace
  357|      0|                    
  358|      0|                    if (!wordWrapEnabled || // No word wrapping, it must fit.
  359|      0|                        currentLineWidth == 0.0 || // The line is empty, it must fit.
  360|      0|                        (contentWidth - currentLineWidth >= requiredSpacing + requiredWidth)) // It simply fits
  361|      0|                    {
  362|      0|                        // Expand current line
  363|      0|                        currentLineWidth += requiredSpacing + requiredWidth
  364|      0|                    }
  365|      0|                    else
  366|      0|                    { // It doesn't fit, we need to wrap a line
  367|      0|                        
  368|      0|                        // Add current line size to array
  369|      0|                        calculatedLineSizes.append(CGSize(width: currentLineWidth, height: labelLineHeight))
  370|      0|                        maxLineWidth = max(maxLineWidth, currentLineWidth)
  371|      0|                        
  372|      0|                        // Start a new line
  373|      0|                        calculatedLabelBreakPoints[stackedStartIndex > -1 ? stackedStartIndex : i] = true
  374|      0|                        currentLineWidth = requiredWidth
  375|      0|                    }
  376|      0|                    
  377|      0|                    if i == entryCount - 1
  378|      0|                    { // Add last line size to array
  379|      0|                        calculatedLineSizes.append(CGSize(width: currentLineWidth, height: labelLineHeight))
  380|      0|                        maxLineWidth = max(maxLineWidth, currentLineWidth)
  381|      0|                    }
  382|      0|                }
  383|      0|                
  384|      0|                stackedStartIndex = label != nil ? -1 : stackedStartIndex
  385|      0|            }
  386|      0|            
  387|      0|            neededWidth = maxLineWidth
  388|      0|            neededHeight = labelLineHeight * CGFloat(calculatedLineSizes.count) +
  389|      0|                yEntrySpace * CGFloat(calculatedLineSizes.count == 0 ? 0 : (calculatedLineSizes.count - 1))
  390|      0|        }
  391|      0|        
  392|      0|        neededWidth += xOffset
  393|      0|        neededHeight += yOffset
  394|      0|    }
  395|       |    
  396|       |    /// MARK: - Custom legend
  397|       |    
  398|       |    /// Sets a custom legend's entries array.
  399|       |    /// * A nil label will start a group.
  400|       |    /// This will disable the feature that automatically calculates the legend entries from the datasets.
  401|       |    /// Call `resetCustom(...)` to re-enable automatic calculation (and then `notifyDataSetChanged()` is needed).
  402|       |    @objc open func setCustom(entries: [LegendEntry])
  403|      0|    {
  404|      0|        self.entries = entries
  405|      0|        _isLegendCustom = true
  406|      0|    }
  407|       |    
  408|       |    /// Calling this will disable the custom legend entries (set by `setLegend(...)`). Instead, the entries will again be calculated automatically (after `notifyDataSetChanged()` is called).
  409|       |    @objc open func resetCustom()
  410|      0|    {
  411|      0|        _isLegendCustom = false
  412|      0|    }
  413|       |    
  414|       |    /// **default**: false (automatic legend)
  415|       |    /// `true` if a custom legend entries has been set
  416|       |    @objc open var isLegendCustom: Bool
  417|      0|    {
  418|      0|        return _isLegendCustom
  419|      0|    }
  420|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/LegendEntry.swift:
    1|       |//
    2|       |//  LegendEntry.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartLegendEntry)
   16|       |open class LegendEntry: NSObject
   17|       |{
   18|       |    public override init()
   19|      0|    {
   20|      0|        super.init()
   21|      0|    }
   22|       |    
   23|       |    /// - Parameters:
   24|       |    ///   - label:                  The legend entry text.
   25|       |    ///                                     A `nil` label will start a group.
   26|       |    ///   - form:                   The form to draw for this entry.
   27|       |    ///   - formSize:               Set to NaN to use the legend's default.
   28|       |    ///   - formLineWidth:          Set to NaN to use the legend's default.
   29|       |    ///   - formLineDashPhase:      Line dash configuration.
   30|       |    ///   - formLineDashLengths:    Line dash configurationas NaN to use the legend's default.
   31|       |    ///   - formColor:              The color for drawing the form.
   32|       |    @objc public init(label: String?,
   33|       |                form: Legend.Form,
   34|       |                formSize: CGFloat,
   35|       |                formLineWidth: CGFloat,
   36|       |                formLineDashPhase: CGFloat,
   37|       |                formLineDashLengths: [CGFloat]?,
   38|       |                formColor: NSUIColor?)
   39|      0|    {
   40|      0|        self.label = label
   41|      0|        self.form = form
   42|      0|        self.formSize = formSize
   43|      0|        self.formLineWidth = formLineWidth
   44|      0|        self.formLineDashPhase = formLineDashPhase
   45|      0|        self.formLineDashLengths = formLineDashLengths
   46|      0|        self.formColor = formColor
   47|      0|    }
   48|       |    
   49|       |    /// The legend entry text.
   50|       |    /// A `nil` label will start a group.
   51|       |    @objc open var label: String?
   52|       |    
   53|       |    /// The form to draw for this entry.
   54|       |    ///
   55|       |    /// `None` will avoid drawing a form, and any related space.
   56|       |    /// `Empty` will avoid drawing a form, but keep its space.
   57|       |    /// `Default` will use the Legend's default.
   58|      0|    @objc open var form: Legend.Form = .default
   59|       |    
   60|       |    /// Form size will be considered except for when .None is used
   61|       |    ///
   62|       |    /// Set as NaN to use the legend's default
   63|      0|    @objc open var formSize: CGFloat = CGFloat.nan
   64|       |    
   65|       |    /// Line width used for shapes that consist of lines.
   66|       |    ///
   67|       |    /// Set to NaN to use the legend's default.
   68|      0|    @objc open var formLineWidth: CGFloat = CGFloat.nan
   69|       |    
   70|       |    /// Line dash configuration for shapes that consist of lines.
   71|       |    ///
   72|       |    /// This is how much (in pixels) into the dash pattern are we starting from.
   73|       |    ///
   74|       |    /// Set to NaN to use the legend's default.
   75|       |    @objc open var formLineDashPhase: CGFloat = 0.0
   76|       |    
   77|       |    /// Line dash configuration for shapes that consist of lines.
   78|       |    ///
   79|       |    /// This is the actual dash pattern.
   80|       |    /// I.e. [2, 3] will paint [--   --   ]
   81|       |    /// [1, 3, 4, 2] will paint [-   ----  -   ----  ]
   82|       |    ///
   83|       |    /// Set to nil to use the legend's default.
   84|       |    @objc open var formLineDashLengths: [CGFloat]?
   85|       |    
   86|       |    /// The color for drawing the form
   87|       |    @objc open var formColor: NSUIColor?
   88|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/MarkerImage.swift:
    1|       |//
    2|       |//  ChartMarkerImage.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartMarkerImage)
   16|       |open class MarkerImage: NSObject, IMarker
   17|       |{
   18|       |    /// The marker image to render
   19|       |    @objc open var image: NSUIImage?
   20|       |    
   21|      0|    open var offset: CGPoint = CGPoint()
   22|       |    
   23|       |    @objc open weak var chartView: ChartViewBase?
   24|       |    
   25|       |    /// As long as size is 0.0/0.0 - it will default to the image's size
   26|      0|    @objc open var size: CGSize = CGSize()
   27|       |    
   28|       |    public override init()
   29|      0|    {
   30|      0|        super.init()
   31|      0|    }
   32|       |    
   33|       |    open func offsetForDrawing(atPoint point: CGPoint) -> CGPoint
   34|      0|    {
   35|      0|        var offset = self.offset
   36|      0|        
   37|      0|        let chart = self.chartView
   38|      0|        
   39|      0|        var size = self.size
   40|      0|        
   41|      0|        if size.width == 0.0 && image != nil
   42|      0|        {
   43|      0|            size.width = image?.size.width ?? 0.0
   44|      0|        }
   45|      0|        if size.height == 0.0 && image != nil
   46|      0|        {
   47|      0|            size.height = image?.size.height ?? 0.0
   48|      0|        }
   49|      0|        
   50|      0|        let width = size.width
   51|      0|        let height = size.height
   52|      0|        
   53|      0|        if point.x + offset.x < 0.0
   54|      0|        {
   55|      0|            offset.x = -point.x
   56|      0|        }
   57|      0|        else if chart != nil && point.x + width + offset.x > chart!.bounds.size.width
   58|      0|        {
   59|      0|            offset.x = chart!.bounds.size.width - point.x - width
   60|      0|        }
   61|      0|        
   62|      0|        if point.y + offset.y < 0
   63|      0|        {
   64|      0|            offset.y = -point.y
   65|      0|        }
   66|      0|        else if chart != nil && point.y + height + offset.y > chart!.bounds.size.height
   67|      0|        {
   68|      0|            offset.y = chart!.bounds.size.height - point.y - height
   69|      0|        }
   70|      0|        
   71|      0|        return offset
   72|      0|    }
   73|       |    
   74|       |    open func refreshContent(entry: ChartDataEntry, highlight: Highlight)
   75|      0|    {
   76|      0|        // Do nothing here...
   77|      0|    }
   78|       |    
   79|       |    open func draw(context: CGContext, point: CGPoint)
   80|      0|    {
   81|      0|        guard let image = image else { return }
   82|      0|
   83|      0|        let offset = offsetForDrawing(atPoint: point)
   84|      0|        
   85|      0|        var size = self.size
   86|      0|        
   87|      0|        if size.width == 0.0
   88|      0|        {
   89|      0|            size.width = image.size.width
   90|      0|        }
   91|      0|        if size.height == 0.0
   92|      0|        {
   93|      0|            size.height = image.size.height
   94|      0|        }
   95|      0|        
   96|      0|        let rect = CGRect(
   97|      0|            x: point.x + offset.x,
   98|      0|            y: point.y + offset.y,
   99|      0|            width: size.width,
  100|      0|            height: size.height)
  101|      0|        
  102|      0|        NSUIGraphicsPushContext(context)
  103|      0|        image.draw(in: rect)
  104|      0|        NSUIGraphicsPopContext()
  105|      0|    }
  106|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/MarkerView.swift:
    1|       |//
    2|       |//  ChartMarkerView.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(AppKit)
   16|       |import AppKit
   17|       |#endif
   18|       |
   19|       |@objc(ChartMarkerView)
   20|       |open class MarkerView: NSUIView, IMarker
   21|       |{
   22|      0|    open var offset: CGPoint = CGPoint()
   23|       |    
   24|       |    @objc open weak var chartView: ChartViewBase?
   25|       |    
   26|       |    open func offsetForDrawing(atPoint point: CGPoint) -> CGPoint
   27|      0|    {
   28|      0|        guard let chart = chartView else { return self.offset }
   29|      0|        
   30|      0|        var offset = self.offset
   31|      0|        
   32|      0|        let width = self.bounds.size.width
   33|      0|        let height = self.bounds.size.height
   34|      0|        
   35|      0|        if point.x + offset.x < 0.0
   36|      0|        {
   37|      0|            offset.x = -point.x
   38|      0|        }
   39|      0|        else if point.x + width + offset.x > chart.bounds.size.width
   40|      0|        {
   41|      0|            offset.x = chart.bounds.size.width - point.x - width
   42|      0|        }
   43|      0|        
   44|      0|        if point.y + offset.y < 0
   45|      0|        {
   46|      0|            offset.y = -point.y
   47|      0|        }
   48|      0|        else if point.y + height + offset.y > chart.bounds.size.height
   49|      0|        {
   50|      0|            offset.y = chart.bounds.size.height - point.y - height
   51|      0|        }
   52|      0|        
   53|      0|        return offset
   54|      0|    }
   55|       |    
   56|       |    open func refreshContent(entry: ChartDataEntry, highlight: Highlight)
   57|      0|    {
   58|      0|        // Do nothing here...
   59|      0|    }
   60|       |    
   61|       |    open func draw(context: CGContext, point: CGPoint)
   62|      0|    {
   63|      0|        let offset = self.offsetForDrawing(atPoint: point)
   64|      0|        
   65|      0|        context.saveGState()
   66|      0|        context.translateBy(x: point.x + offset.x,
   67|      0|                              y: point.y + offset.y)
   68|      0|        NSUIGraphicsPushContext(context)
   69|      0|        self.nsuiLayer?.render(in: context)
   70|      0|        NSUIGraphicsPopContext()
   71|      0|        context.restoreGState()
   72|      0|    }
   73|       |    
   74|       |    @objc
   75|       |    open class func viewFromXib(in bundle: Bundle = .main) -> MarkerView?
   76|      0|    {
   77|      0|        #if !os(OSX)
   78|      0|        
   79|      0|        return bundle.loadNibNamed(
   80|      0|            String(describing: self),
   81|      0|            owner: nil,
   82|      0|            options: nil)?[0] as? MarkerView
   83|      0|        #else
   84|      0|        
   85|      0|        var loadedObjects = NSArray()
   86|      0|        let loadedObjectsPointer = AutoreleasingUnsafeMutablePointer<NSArray?>(&loadedObjects)
   87|      0|        
   88|      0|        if bundle.loadNibNamed(
   89|      0|            NSNib.Name(String(describing: self)),
   90|      0|            owner: nil,
   91|      0|            topLevelObjects: loadedObjectsPointer)
   92|      0|        {
   93|      0|            return loadedObjects[0] as? MarkerView
   94|      0|        }
   95|      0|        
   96|      0|        return nil
   97|      0|        #endif
   98|      0|    }
   99|       |    
  100|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/XAxis.swift:
    1|       |//
    2|       |//  XAxis.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartXAxis)
   16|       |open class XAxis: AxisBase
   17|       |{
   18|       |    @objc(XAxisLabelPosition)
   19|       |    public enum LabelPosition: Int
   20|       |    {
   21|       |        case top
   22|       |        case bottom
   23|       |        case bothSided
   24|       |        case topInside
   25|       |        case bottomInside
   26|       |    }
   27|       |    
   28|       |    /// width of the x-axis labels in pixels - this is automatically calculated by the `computeSize()` methods in the renderers
   29|      0|    @objc open var labelWidth = CGFloat(1.0)
   30|       |    
   31|       |    /// height of the x-axis labels in pixels - this is automatically calculated by the `computeSize()` methods in the renderers
   32|      0|    @objc open var labelHeight = CGFloat(1.0)
   33|       |    
   34|       |    /// width of the (rotated) x-axis labels in pixels - this is automatically calculated by the `computeSize()` methods in the renderers
   35|      0|    @objc open var labelRotatedWidth = CGFloat(1.0)
   36|       |    
   37|       |    /// height of the (rotated) x-axis labels in pixels - this is automatically calculated by the `computeSize()` methods in the renderers
   38|      0|    @objc open var labelRotatedHeight = CGFloat(1.0)
   39|       |    
   40|       |    /// This is the angle for drawing the X axis labels (in degrees)
   41|      0|    @objc open var labelRotationAngle = CGFloat(0.0)
   42|       |
   43|       |    /// if set to true, the chart will avoid that the first and last label entry in the chart "clip" off the edge of the chart
   44|       |    @objc open var avoidFirstLastClippingEnabled = false
   45|       |    
   46|       |    /// the position of the x-labels relative to the chart
   47|      0|    @objc open var labelPosition = LabelPosition.top
   48|       |    
   49|       |    /// if set to true, word wrapping the labels will be enabled.
   50|       |    /// word wrapping is done using `(value width * labelRotatedWidth)`
   51|       |    ///
   52|       |    /// - Note: currently supports all charts except pie/radar/horizontal-bar*
   53|       |    @objc open var wordWrapEnabled = false
   54|       |    
   55|       |    /// `true` if word wrapping the labels is enabled
   56|      0|    @objc open var isWordWrapEnabled: Bool { return wordWrapEnabled }
   57|       |    
   58|       |    /// the width for wrapping the labels, as percentage out of one value width.
   59|       |    /// used only when isWordWrapEnabled = true.
   60|       |    /// 
   61|       |    /// **default**: 1.0
   62|       |    @objc open var wordWrapWidthPercent: CGFloat = 1.0
   63|       |    
   64|       |    public override init()
   65|      0|    {
   66|      0|        super.init()
   67|      0|        
   68|      0|        self.yOffset = 4.0
   69|      0|    }
   70|       |    
   71|       |    @objc open var isAvoidFirstLastClippingEnabled: Bool
   72|      0|    {
   73|      0|        return avoidFirstLastClippingEnabled
   74|      0|    }
   75|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Components/YAxis.swift:
    1|       |//
    2|       |//  YAxis.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |
   24|       |/// Class representing the y-axis labels settings and its entries.
   25|       |/// Be aware that not all features the YLabels class provides are suitable for the RadarChart.
   26|       |/// Customizations that affect the value range of the axis need to be applied before setting data for the chart.
   27|       |@objc(ChartYAxis)
   28|       |open class YAxis: AxisBase
   29|       |{
   30|       |    @objc(YAxisLabelPosition)
   31|       |    public enum LabelPosition: Int
   32|       |    {
   33|       |        case outsideChart
   34|       |        case insideChart
   35|       |    }
   36|       |    
   37|       |    ///  Enum that specifies the axis a DataSet should be plotted against, either Left or Right.
   38|       |    @objc
   39|       |    public enum AxisDependency: Int
   40|       |    {
   41|       |        case left
   42|       |        case right
   43|       |    }
   44|       |    
   45|       |    /// indicates if the bottom y-label entry is drawn or not
   46|       |    @objc open var drawBottomYLabelEntryEnabled = true
   47|       |    
   48|       |    /// indicates if the top y-label entry is drawn or not
   49|       |    @objc open var drawTopYLabelEntryEnabled = true
   50|       |    
   51|       |    /// flag that indicates if the axis is inverted or not
   52|       |    @objc open var inverted = false
   53|       |    
   54|       |    /// flag that indicates if the zero-line should be drawn regardless of other grid lines
   55|       |    @objc open var drawZeroLineEnabled = false
   56|       |    
   57|       |    /// Color of the zero line
   58|      0|    @objc open var zeroLineColor: NSUIColor? = NSUIColor.gray
   59|       |    
   60|       |    /// Width of the zero line
   61|       |    @objc open var zeroLineWidth: CGFloat = 1.0
   62|       |    
   63|       |    /// This is how much (in pixels) into the dash pattern are we starting from.
   64|      0|    @objc open var zeroLineDashPhase = CGFloat(0.0)
   65|       |    
   66|       |    /// This is the actual dash pattern.
   67|       |    /// I.e. [2, 3] will paint [--   --   ]
   68|       |    /// [1, 3, 4, 2] will paint [-   ----  -   ----  ]
   69|       |    @objc open var zeroLineDashLengths: [CGFloat]?
   70|       |
   71|       |    /// axis space from the largest value to the top in percent of the total axis range
   72|      0|    @objc open var spaceTop = CGFloat(0.1)
   73|       |
   74|       |    /// axis space from the smallest value to the bottom in percent of the total axis range
   75|      0|    @objc open var spaceBottom = CGFloat(0.1)
   76|       |    
   77|       |    /// the position of the y-labels relative to the chart
   78|      0|    @objc open var labelPosition = LabelPosition.outsideChart
   79|       |
   80|       |    /// the alignment of the text in the y-label
   81|      0|    @objc open var labelAlignment: NSTextAlignment = .left
   82|       |
   83|       |    /// the horizontal offset of the y-label
   84|       |    @objc open var labelXOffset: CGFloat = 0.0
   85|       |    
   86|       |    /// the side this axis object represents
   87|      0|    private var _axisDependency = AxisDependency.left
   88|       |    
   89|       |    /// the minimum width that the axis should take
   90|       |    /// 
   91|       |    /// **default**: 0.0
   92|      0|    @objc open var minWidth = CGFloat(0)
   93|       |    
   94|       |    /// the maximum width that the axis can take.
   95|       |    /// use Infinity for disabling the maximum.
   96|       |    /// 
   97|       |    /// **default**: CGFloat.infinity
   98|      0|    @objc open var maxWidth = CGFloat(CGFloat.infinity)
   99|       |    
  100|       |    public override init()
  101|      0|    {
  102|      0|        super.init()
  103|      0|        
  104|      0|        self.yOffset = 0.0
  105|      0|    }
  106|       |    
  107|       |    @objc public init(position: AxisDependency)
  108|      0|    {
  109|      0|        super.init()
  110|      0|        
  111|      0|        _axisDependency = position
  112|      0|        
  113|      0|        self.yOffset = 0.0
  114|      0|    }
  115|       |    
  116|       |    @objc open var axisDependency: AxisDependency
  117|      0|    {
  118|      0|        return _axisDependency
  119|      0|    }
  120|       |    
  121|       |    @objc open func requiredSize() -> CGSize
  122|      0|    {
  123|      0|        let label = getLongestLabel() as NSString
  124|      0|        var size = label.size(withAttributes: [NSAttributedString.Key.font: labelFont])
  125|      0|        size.width += xOffset * 2.0
  126|      0|        size.height += yOffset * 2.0
  127|      0|        size.width = max(minWidth, min(size.width, maxWidth > 0.0 ? maxWidth : size.width))
  128|      0|        return size
  129|      0|    }
  130|       |    
  131|       |    @objc open func getRequiredHeightSpace() -> CGFloat
  132|      0|    {
  133|      0|        return requiredSize().height
  134|      0|    }
  135|       |    
  136|       |    /// `true` if this axis needs horizontal offset, `false` ifno offset is needed.
  137|       |    @objc open var needsOffset: Bool
  138|      0|    {
  139|      0|        if isEnabled && isDrawLabelsEnabled && labelPosition == .outsideChart
  140|      0|        {
  141|      0|            return true
  142|      0|        }
  143|      0|        else
  144|      0|        {
  145|      0|            return false
  146|      0|        }
  147|      0|    }
  148|       |    
  149|      0|    @objc open var isInverted: Bool { return inverted }
  150|       |    
  151|       |    open override func calculate(min dataMin: Double, max dataMax: Double)
  152|      0|    {
  153|      0|        // if custom, use value as is, else use data value
  154|      0|        var min = _customAxisMin ? _axisMinimum : dataMin
  155|      0|        var max = _customAxisMax ? _axisMaximum : dataMax
  156|      0|        
  157|      0|        // Make sure max is greater than min
  158|      0|        // Discussion: https://github.com/danielgindi/Charts/pull/3650#discussion_r221409991
  159|      0|        if min > max
  160|      0|        {
  161|      0|            switch(_customAxisMax, _customAxisMin)
  162|      0|            {
  163|      0|            case(true, true):
  164|      0|                (min, max) = (max, min)
  165|      0|            case(true, false):
  166|      0|                min = max < 0 ? max * 1.5 : max * 0.5
  167|      0|            case(false, true):
  168|      0|                max = min < 0 ? min * 0.5 : min * 1.5
  169|      0|            case(false, false):
  170|      0|                break
  171|      0|            }
  172|      0|        }
  173|      0|        
  174|      0|        // temporary range (before calculations)
  175|      0|        let range = abs(max - min)
  176|      0|        
  177|      0|        // in case all values are equal
  178|      0|        if range == 0.0
  179|      0|        {
  180|      0|            max = max + 1.0
  181|      0|            min = min - 1.0
  182|      0|        }
  183|      0|        
  184|      0|        // bottom-space only effects non-custom min
  185|      0|        if !_customAxisMin
  186|      0|        {
  187|      0|            let bottomSpace = range * Double(spaceBottom)
  188|      0|            _axisMinimum = (min - bottomSpace)
  189|      0|        }
  190|      0|        
  191|      0|        // top-space only effects non-custom max
  192|      0|        if !_customAxisMax
  193|      0|        {
  194|      0|            let topSpace = range * Double(spaceTop)
  195|      0|            _axisMaximum = (max + topSpace)
  196|      0|        }
  197|      0|        
  198|      0|        // calc actual range
  199|      0|        axisRange = abs(_axisMaximum - _axisMinimum)
  200|      0|    }
  201|       |    
  202|      0|    @objc open var isDrawBottomYLabelEntryEnabled: Bool { return drawBottomYLabelEntryEnabled }
  203|       |    
  204|      0|    @objc open var isDrawTopYLabelEntryEnabled: Bool { return drawTopYLabelEntryEnabled }
  205|       |
  206|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/ChartBaseDataSet.swift:
    1|       |//
    2|       |//  BaseDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class ChartBaseDataSet: NSObject, IChartDataSet, NSCopying
   17|       |{
   18|       |    public required override init()
   19|      0|    {
   20|      0|        super.init()
   21|      0|        
   22|      0|        // default color
   23|      0|        colors.append(NSUIColor(red: 140.0/255.0, green: 234.0/255.0, blue: 255.0/255.0, alpha: 1.0))
   24|      0|        valueColors.append(.labelOrBlack)
   25|      0|    }
   26|       |    
   27|       |    @objc public init(label: String?)
   28|      0|    {
   29|      0|        super.init()
   30|      0|        
   31|      0|        // default color
   32|      0|        colors.append(NSUIColor(red: 140.0/255.0, green: 234.0/255.0, blue: 255.0/255.0, alpha: 1.0))
   33|      0|        valueColors.append(.labelOrBlack)
   34|      0|        
   35|      0|        self.label = label
   36|      0|    }
   37|       |    
   38|       |    // MARK: - Data functions and accessors
   39|       |    
   40|       |    /// Use this method to tell the data set that the underlying data has changed
   41|       |    open func notifyDataSetChanged()
   42|      0|    {
   43|      0|        calcMinMax()
   44|      0|    }
   45|       |    
   46|       |    open func calcMinMax()
   47|      0|    {
   48|      0|        fatalError("calcMinMax is not implemented in ChartBaseDataSet")
   49|      0|    }
   50|       |    
   51|       |    open func calcMinMaxY(fromX: Double, toX: Double)
   52|      0|    {
   53|      0|        fatalError("calcMinMaxY(fromX:, toX:) is not implemented in ChartBaseDataSet")
   54|      0|    }
   55|       |    
   56|       |    open var yMin: Double
   57|      0|    {
   58|      0|        fatalError("yMin is not implemented in ChartBaseDataSet")
   59|      0|    }
   60|       |    
   61|       |    open var yMax: Double
   62|      0|    {
   63|      0|        fatalError("yMax is not implemented in ChartBaseDataSet")
   64|      0|    }
   65|       |    
   66|       |    open var xMin: Double
   67|      0|    {
   68|      0|        fatalError("xMin is not implemented in ChartBaseDataSet")
   69|      0|    }
   70|       |    
   71|       |    open var xMax: Double
   72|      0|    {
   73|      0|        fatalError("xMax is not implemented in ChartBaseDataSet")
   74|      0|    }
   75|       |    
   76|       |    open var entryCount: Int
   77|      0|    {
   78|      0|        fatalError("entryCount is not implemented in ChartBaseDataSet")
   79|      0|    }
   80|       |        
   81|       |    open func entryForIndex(_ i: Int) -> ChartDataEntry?
   82|      0|    {
   83|      0|        fatalError("entryForIndex is not implemented in ChartBaseDataSet")
   84|      0|    }
   85|       |    
   86|       |    open func entryForXValue(
   87|       |        _ x: Double,
   88|       |        closestToY y: Double,
   89|       |        rounding: ChartDataSetRounding) -> ChartDataEntry?
   90|      0|    {
   91|      0|        fatalError("entryForXValue(x, closestToY, rounding) is not implemented in ChartBaseDataSet")
   92|      0|    }
   93|       |    
   94|       |    open func entryForXValue(
   95|       |        _ x: Double,
   96|       |        closestToY y: Double) -> ChartDataEntry?
   97|      0|    {
   98|      0|        fatalError("entryForXValue(x, closestToY) is not implemented in ChartBaseDataSet")
   99|      0|    }
  100|       |    
  101|       |    open func entriesForXValue(_ x: Double) -> [ChartDataEntry]
  102|      0|    {
  103|      0|        fatalError("entriesForXValue is not implemented in ChartBaseDataSet")
  104|      0|    }
  105|       |    
  106|       |    open func entryIndex(
  107|       |        x xValue: Double,
  108|       |        closestToY y: Double,
  109|       |        rounding: ChartDataSetRounding) -> Int
  110|      0|    {
  111|      0|        fatalError("entryIndex(x, closestToY, rounding) is not implemented in ChartBaseDataSet")
  112|      0|    }
  113|       |    
  114|       |    open func entryIndex(entry e: ChartDataEntry) -> Int
  115|      0|    {
  116|      0|        fatalError("entryIndex(entry) is not implemented in ChartBaseDataSet")
  117|      0|    }
  118|       |    
  119|       |    open func addEntry(_ e: ChartDataEntry) -> Bool
  120|      0|    {
  121|      0|        fatalError("addEntry is not implemented in ChartBaseDataSet")
  122|      0|    }
  123|       |    
  124|       |    open func addEntryOrdered(_ e: ChartDataEntry) -> Bool
  125|      0|    {
  126|      0|        fatalError("addEntryOrdered is not implemented in ChartBaseDataSet")
  127|      0|    }
  128|       |    
  129|       |    @discardableResult open func removeEntry(_ entry: ChartDataEntry) -> Bool
  130|      0|    {
  131|      0|        fatalError("removeEntry is not implemented in ChartBaseDataSet")
  132|      0|    }
  133|       |    
  134|       |    @discardableResult open func removeEntry(index: Int) -> Bool
  135|      0|    {
  136|      0|        if let entry = entryForIndex(index)
  137|      0|        {
  138|      0|            return removeEntry(entry)
  139|      0|        }
  140|      0|        return false
  141|      0|    }
  142|       |    
  143|       |    @discardableResult open func removeEntry(x: Double) -> Bool
  144|      0|    {
  145|      0|        if let entry = entryForXValue(x, closestToY: Double.nan)
  146|      0|        {
  147|      0|            return removeEntry(entry)
  148|      0|        }
  149|      0|        return false
  150|      0|    }
  151|       |    
  152|       |    @discardableResult open func removeFirst() -> Bool
  153|      0|    {
  154|      0|        if entryCount > 0
  155|      0|        {
  156|      0|            if let entry = entryForIndex(0)
  157|      0|            {
  158|      0|                return removeEntry(entry)
  159|      0|            }
  160|      0|        }
  161|      0|        return false
  162|      0|    }
  163|       |    
  164|       |    @discardableResult open func removeLast() -> Bool
  165|      0|    {
  166|      0|        if entryCount > 0
  167|      0|        {
  168|      0|            if let entry = entryForIndex(entryCount - 1)
  169|      0|            {
  170|      0|                return removeEntry(entry)
  171|      0|            }
  172|      0|        }
  173|      0|        return false
  174|      0|    }
  175|       |    
  176|       |    open func contains(_ e: ChartDataEntry) -> Bool
  177|      0|    {
  178|      0|        fatalError("removeEntry is not implemented in ChartBaseDataSet")
  179|      0|    }
  180|       |    
  181|       |    open func clear()
  182|      0|    {
  183|      0|        fatalError("clear is not implemented in ChartBaseDataSet")
  184|      0|    }
  185|       |    
  186|       |    // MARK: - Styling functions and accessors
  187|       |    
  188|       |    /// All the colors that are used for this DataSet.
  189|       |    /// Colors are reused as soon as the number of Entries the DataSet represents is higher than the size of the colors array.
  190|      0|    open var colors = [NSUIColor]()
  191|       |    
  192|       |    /// List representing all colors that are used for drawing the actual values for this DataSet
  193|      0|    open var valueColors = [NSUIColor]()
  194|       |
  195|       |    /// The label string that describes the DataSet.
  196|      0|    open var label: String? = "DataSet"
  197|       |    
  198|       |    /// The axis this DataSet should be plotted against.
  199|      0|    open var axisDependency = YAxis.AxisDependency.left
  200|       |    
  201|       |    /// - Returns: The color at the given index of the DataSet's color array.
  202|       |    /// This prevents out-of-bounds by performing a modulus on the color index, so colours will repeat themselves.
  203|       |    open func color(atIndex index: Int) -> NSUIColor
  204|      0|    {
  205|      0|        var index = index
  206|      0|        if index < 0
  207|      0|        {
  208|      0|            index = 0
  209|      0|        }
  210|      0|        return colors[index % colors.count]
  211|      0|    }
  212|       |    
  213|       |    /// Resets all colors of this DataSet and recreates the colors array.
  214|       |    open func resetColors()
  215|      0|    {
  216|      0|        colors.removeAll(keepingCapacity: false)
  217|      0|    }
  218|       |    
  219|       |    /// Adds a new color to the colors array of the DataSet.
  220|       |    ///
  221|       |    /// - Parameters:
  222|       |    ///   - color: the color to add
  223|       |    open func addColor(_ color: NSUIColor)
  224|      0|    {
  225|      0|        colors.append(color)
  226|      0|    }
  227|       |    
  228|       |    /// Sets the one and **only** color that should be used for this DataSet.
  229|       |    /// Internally, this recreates the colors array and adds the specified color.
  230|       |    ///
  231|       |    /// - Parameters:
  232|       |    ///   - color: the color to set
  233|       |    open func setColor(_ color: NSUIColor)
  234|      0|    {
  235|      0|        colors.removeAll(keepingCapacity: false)
  236|      0|        colors.append(color)
  237|      0|    }
  238|       |    
  239|       |    /// Sets colors to a single color a specific alpha value.
  240|       |    ///
  241|       |    /// - Parameters:
  242|       |    ///   - color: the color to set
  243|       |    ///   - alpha: alpha to apply to the set `color`
  244|       |    @objc open func setColor(_ color: NSUIColor, alpha: CGFloat)
  245|      0|    {
  246|      0|        setColor(color.withAlphaComponent(alpha))
  247|      0|    }
  248|       |    
  249|       |    /// Sets colors with a specific alpha value.
  250|       |    ///
  251|       |    /// - Parameters:
  252|       |    ///   - colors: the colors to set
  253|       |    ///   - alpha: alpha to apply to the set `colors`
  254|       |    @objc open func setColors(_ colors: [NSUIColor], alpha: CGFloat)
  255|      0|    {
  256|      0|        self.colors = colors.map { $0.withAlphaComponent(alpha) }
  257|      0|    }
  258|       |    
  259|       |    /// Sets colors with a specific alpha value.
  260|       |    ///
  261|       |    /// - Parameters:
  262|       |    ///   - colors: the colors to set
  263|       |    ///   - alpha: alpha to apply to the set `colors`
  264|       |    open func setColors(_ colors: NSUIColor...)
  265|      0|    {
  266|      0|        self.colors = colors
  267|      0|    }
  268|       |    
  269|       |    /// if true, value highlighting is enabled
  270|       |    open var highlightEnabled = true
  271|       |    
  272|       |    /// `true` if value highlighting is enabled for this dataset
  273|      0|    open var isHighlightEnabled: Bool { return highlightEnabled }
  274|       |    
  275|       |    /// Custom formatter that is used instead of the auto-formatter if set
  276|       |    internal var _valueFormatter: IValueFormatter?
  277|       |    
  278|       |    /// Custom formatter that is used instead of the auto-formatter if set
  279|       |    open var valueFormatter: IValueFormatter?
  280|       |    {
  281|       |        get
  282|      0|        {
  283|      0|            if needsFormatter
  284|      0|            {
  285|      0|                return ChartUtils.defaultValueFormatter()
  286|      0|            }
  287|      0|            
  288|      0|            return _valueFormatter
  289|      0|        }
  290|       |        set
  291|      0|        {
  292|      0|            if newValue == nil { return }
  293|      0|            
  294|      0|            _valueFormatter = newValue
  295|      0|        }
  296|       |    }
  297|       |    
  298|       |    open var needsFormatter: Bool
  299|      0|    {
  300|      0|        return _valueFormatter == nil
  301|      0|    }
  302|       |    
  303|       |    /// Sets/get a single color for value text.
  304|       |    /// Setting the color clears the colors array and adds a single color.
  305|       |    /// Getting will return the first color in the array.
  306|       |    open var valueTextColor: NSUIColor
  307|       |    {
  308|       |        get
  309|      0|        {
  310|      0|            return valueColors[0]
  311|      0|        }
  312|       |        set
  313|      0|        {
  314|      0|            valueColors.removeAll(keepingCapacity: false)
  315|      0|            valueColors.append(newValue)
  316|      0|        }
  317|       |    }
  318|       |    
  319|       |    /// - Returns: The color at the specified index that is used for drawing the values inside the chart. Uses modulus internally.
  320|       |    open func valueTextColorAt(_ index: Int) -> NSUIColor
  321|      0|    {
  322|      0|        var index = index
  323|      0|        if index < 0
  324|      0|        {
  325|      0|            index = 0
  326|      0|        }
  327|      0|        return valueColors[index % valueColors.count]
  328|      0|    }
  329|       |    
  330|       |    /// the font for the value-text labels
  331|      0|    open var valueFont: NSUIFont = NSUIFont.systemFont(ofSize: 7.0)
  332|       |    
  333|       |    /// The form to draw for this dataset in the legend.
  334|      0|    open var form = Legend.Form.default
  335|       |    
  336|       |    /// The form size to draw for this dataset in the legend.
  337|       |    ///
  338|       |    /// Return `NaN` to use the default legend form size.
  339|      0|    open var formSize: CGFloat = CGFloat.nan
  340|       |    
  341|       |    /// The line width for drawing the form of this dataset in the legend
  342|       |    ///
  343|       |    /// Return `NaN` to use the default legend form line width.
  344|      0|    open var formLineWidth: CGFloat = CGFloat.nan
  345|       |    
  346|       |    /// Line dash configuration for legend shapes that consist of lines.
  347|       |    ///
  348|       |    /// This is how much (in pixels) into the dash pattern are we starting from.
  349|       |    open var formLineDashPhase: CGFloat = 0.0
  350|       |    
  351|       |    /// Line dash configuration for legend shapes that consist of lines.
  352|       |    ///
  353|       |    /// This is the actual dash pattern.
  354|       |    /// I.e. [2, 3] will paint [--   --   ]
  355|       |    /// [1, 3, 4, 2] will paint [-   ----  -   ----  ]
  356|       |    open var formLineDashLengths: [CGFloat]? = nil
  357|       |    
  358|       |    /// Set this to true to draw y-values on the chart.
  359|       |    ///
  360|       |    /// - Note: For bar and line charts: if `maxVisibleCount` is reached, no values will be drawn even if this is enabled.
  361|       |    open var drawValuesEnabled = true
  362|       |    
  363|       |    /// `true` if y-value drawing is enabled, `false` ifnot
  364|       |    open var isDrawValuesEnabled: Bool
  365|      0|    {
  366|      0|        return drawValuesEnabled
  367|      0|    }
  368|       |
  369|       |    /// Set this to true to draw y-icons on the chart.
  370|       |    ///
  371|       |    /// - Note: For bar and line charts: if `maxVisibleCount` is reached, no icons will be drawn even if this is enabled.
  372|       |    open var drawIconsEnabled = true
  373|       |    
  374|       |    /// Returns true if y-icon drawing is enabled, false if not
  375|       |    open var isDrawIconsEnabled: Bool
  376|      0|    {
  377|      0|        return drawIconsEnabled
  378|      0|    }
  379|       |    
  380|       |    /// Offset of icons drawn on the chart.  
  381|       |    ///
  382|       |    /// For all charts except Pie and Radar it will be ordinary (x offset, y offset).
  383|       |    ///
  384|       |    /// For Pie and Radar chart it will be (y offset, distance from center offset); so if you want icon to be rendered under value, you should increase X component of CGPoint, and if you want icon to be rendered closet to center, you should decrease height component of CGPoint.
  385|      0|    open var iconsOffset = CGPoint(x: 0, y: 0)
  386|       |    
  387|       |    /// Set the visibility of this DataSet. If not visible, the DataSet will not be drawn to the chart upon refreshing it.
  388|       |    open var visible = true
  389|       |    
  390|       |    /// `true` if this DataSet is visible inside the chart, or `false` ifit is currently hidden.
  391|       |    open var isVisible: Bool
  392|      0|    {
  393|      0|        return visible
  394|      0|    }
  395|       |    
  396|       |    // MARK: - NSObject
  397|       |    
  398|       |    open override var description: String
  399|      0|    {
  400|      0|        return String(format: "%@, label: %@, %i entries", arguments: [NSStringFromClass(type(of: self)), self.label ?? "", self.entryCount])
  401|      0|    }
  402|       |    
  403|       |    open override var debugDescription: String
  404|      0|    {
  405|      0|        return (0..<entryCount).reduce(description + ":") {
  406|      0|            "\($0)\n\(self.entryForIndex($1)?.description ?? "")"
  407|      0|        }
  408|      0|    }
  409|       |    
  410|       |    // MARK: - NSCopying
  411|       |    
  412|       |    open func copy(with zone: NSZone? = nil) -> Any 
  413|      0|    {
  414|      0|        let copy = type(of: self).init()
  415|      0|        
  416|      0|        copy.colors = colors
  417|      0|        copy.valueColors = valueColors
  418|      0|        copy.label = label
  419|      0|        copy.axisDependency = axisDependency
  420|      0|        copy.highlightEnabled = highlightEnabled
  421|      0|        copy._valueFormatter = _valueFormatter
  422|      0|        copy.valueFont = valueFont
  423|      0|        copy.form = form
  424|      0|        copy.formSize = formSize
  425|      0|        copy.formLineWidth = formLineWidth
  426|      0|        copy.formLineDashPhase = formLineDashPhase
  427|      0|        copy.formLineDashLengths = formLineDashLengths
  428|      0|        copy.drawValuesEnabled = drawValuesEnabled
  429|      0|        copy.drawValuesEnabled = drawValuesEnabled
  430|      0|        copy.iconsOffset = iconsOffset
  431|      0|        copy.visible = visible
  432|      0|        
  433|      0|        return copy
  434|      0|    }
  435|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/BarChartData.swift:
    1|       |//
    2|       |//  BarChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class BarChartData: BarLineScatterCandleBubbleChartData
   16|       |{
   17|       |    public override init()
   18|      0|    {
   19|      0|        super.init()
   20|      0|    }
   21|       |    
   22|       |    public override init(dataSets: [IChartDataSet]?)
   23|      0|    {
   24|      0|        super.init(dataSets: dataSets)
   25|      0|    }
   26|       |    
   27|       |    /// The width of the bars on the x-axis, in values (not pixels)
   28|       |    ///
   29|       |    /// **default**: 0.85
   30|      0|    @objc open var barWidth = Double(0.85)
   31|       |    
   32|       |    /// Groups all BarDataSet objects this data object holds together by modifying the x-value of their entries.
   33|       |    /// Previously set x-values of entries will be overwritten. Leaves space between bars and groups as specified by the parameters.
   34|       |    /// Do not forget to call notifyDataSetChanged() on your BarChart object after calling this method.
   35|       |    ///
   36|       |    /// - Parameters:
   37|       |    ///   - fromX: the starting point on the x-axis where the grouping should begin
   38|       |    ///   - groupSpace: The space between groups of bars in values (not pixels) e.g. 0.8f for bar width 1f
   39|       |    ///   - barSpace: The space between individual bars in values (not pixels) e.g. 0.1f for bar width 1f
   40|       |    @objc open func groupBars(fromX: Double, groupSpace: Double, barSpace: Double)
   41|      0|    {
   42|      0|        let setCount = _dataSets.count
   43|      0|        if setCount <= 1
   44|      0|        {
   45|      0|            print("BarData needs to hold at least 2 BarDataSets to allow grouping.", terminator: "\n")
   46|      0|            return
   47|      0|        }
   48|      0|        
   49|      0|        let max = maxEntryCountSet
   50|      0|        let maxEntryCount = max?.entryCount ?? 0
   51|      0|        
   52|      0|        let groupSpaceWidthHalf = groupSpace / 2.0
   53|      0|        let barSpaceHalf = barSpace / 2.0
   54|      0|        let barWidthHalf = self.barWidth / 2.0
   55|      0|        
   56|      0|        var fromX = fromX
   57|      0|        
   58|      0|        let interval = groupWidth(groupSpace: groupSpace, barSpace: barSpace)
   59|      0|
   60|      0|        for i in stride(from: 0, to: maxEntryCount, by: 1)
   61|      0|        {
   62|      0|            let start = fromX
   63|      0|            fromX += groupSpaceWidthHalf
   64|      0|            
   65|      0|            (_dataSets as? [IBarChartDataSet])?.forEach { set in
   66|      0|                fromX += barSpaceHalf
   67|      0|                fromX += barWidthHalf
   68|      0|                
   69|      0|                if i < set.entryCount
   70|      0|                {
   71|      0|                    if let entry = set.entryForIndex(i)
   72|      0|                    {
   73|      0|                        entry.x = fromX
   74|      0|                    }
   75|      0|                }
   76|      0|                
   77|      0|                fromX += barWidthHalf
   78|      0|                fromX += barSpaceHalf
   79|      0|            }
   80|      0|            
   81|      0|            fromX += groupSpaceWidthHalf
   82|      0|            let end = fromX
   83|      0|            let innerInterval = end - start
   84|      0|            let diff = interval - innerInterval
   85|      0|            
   86|      0|            // correct rounding errors
   87|      0|            if diff > 0 || diff < 0
   88|      0|            {
   89|      0|                fromX += diff
   90|      0|            }
   91|      0|
   92|      0|        }
   93|      0|        
   94|      0|        notifyDataChanged()
   95|      0|    }
   96|       |    
   97|       |    /// In case of grouped bars, this method returns the space an individual group of bar needs on the x-axis.
   98|       |    ///
   99|       |    /// - Parameters:
  100|       |    ///   - groupSpace:
  101|       |    ///   - barSpace:
  102|       |    @objc open func groupWidth(groupSpace: Double, barSpace: Double) -> Double
  103|      0|    {
  104|      0|        return Double(_dataSets.count) * (self.barWidth + barSpace) + groupSpace
  105|      0|    }
  106|       |    
  107|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/BarChartDataEntry.swift:
    1|       |//
    2|       |//  BarChartDataEntry.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class BarChartDataEntry: ChartDataEntry
   15|       |{
   16|       |    /// the values the stacked barchart holds
   17|       |    private var _yVals: [Double]?
   18|       |    
   19|       |    /// the ranges for the individual stack values - automatically calculated
   20|       |    private var _ranges: [Range]?
   21|       |    
   22|       |    /// the sum of all negative values this entry (if stacked) contains
   23|       |    private var _negativeSum: Double = 0.0
   24|       |    
   25|       |    /// the sum of all positive values this entry (if stacked) contains
   26|       |    private var _positiveSum: Double = 0.0
   27|       |    
   28|       |    public required init()
   29|      0|    {
   30|      0|        super.init()
   31|      0|    }
   32|       |    
   33|       |    /// Constructor for normal bars (not stacked).
   34|       |    public override init(x: Double, y: Double)
   35|      0|    {
   36|      0|        super.init(x: x, y: y)
   37|      0|    }
   38|       |    
   39|       |    /// Constructor for normal bars (not stacked).
   40|       |    public convenience init(x: Double, y: Double, data: Any?)
   41|      0|    {
   42|      0|        self.init(x: x, y: y)
   43|      0|        self.data = data
   44|      0|    }
   45|       |    
   46|       |    /// Constructor for normal bars (not stacked).
   47|       |    public convenience init(x: Double, y: Double, icon: NSUIImage?)
   48|      0|    {
   49|      0|        self.init(x: x, y: y)
   50|      0|        self.icon = icon
   51|      0|    }
   52|       |    
   53|       |    /// Constructor for normal bars (not stacked).
   54|       |    public convenience init(x: Double, y: Double, icon: NSUIImage?, data: Any?)
   55|      0|    {
   56|      0|        self.init(x: x, y: y)
   57|      0|        self.icon = icon
   58|      0|        self.data = data
   59|      0|    }
   60|       |    
   61|       |    /// Constructor for stacked bar entries.
   62|       |    @objc public init(x: Double, yValues: [Double])
   63|      0|    {
   64|      0|        super.init(x: x, y: BarChartDataEntry.calcSum(values: yValues))
   65|      0|        self._yVals = yValues
   66|      0|        calcPosNegSum()
   67|      0|        calcRanges()
   68|      0|    }
   69|       |
   70|       |    /// Constructor for stacked bar entries. One data object for whole stack
   71|       |    @objc public convenience init(x: Double, yValues: [Double], icon: NSUIImage?)
   72|      0|    {
   73|      0|        self.init(x: x, yValues: yValues)
   74|      0|        self.icon = icon
   75|      0|    }
   76|       |
   77|       |    /// Constructor for stacked bar entries. One data object for whole stack
   78|       |    @objc public convenience init(x: Double, yValues: [Double], data: Any?)
   79|      0|    {
   80|      0|        self.init(x: x, yValues: yValues)
   81|      0|        self.data = data
   82|      0|    }
   83|       |
   84|       |    /// Constructor for stacked bar entries. One data object for whole stack
   85|       |    @objc public convenience init(x: Double, yValues: [Double], icon: NSUIImage?, data: Any?)
   86|      0|    {
   87|      0|        self.init(x: x, yValues: yValues)
   88|      0|        self.icon = icon
   89|      0|        self.data = data
   90|      0|    }
   91|       |    
   92|       |    @objc open func sumBelow(stackIndex :Int) -> Double
   93|      0|    {
   94|      0|        guard let yVals = _yVals else
   95|      0|        {
   96|      0|            return 0
   97|      0|        }
   98|      0|        
   99|      0|        var remainder: Double = 0.0
  100|      0|        var index = yVals.count - 1
  101|      0|        
  102|      0|        while (index > stackIndex && index >= 0)
  103|      0|        {
  104|      0|            remainder += yVals[index]
  105|      0|            index -= 1
  106|      0|        }
  107|      0|        
  108|      0|        return remainder
  109|      0|    }
  110|       |    
  111|       |    /// The sum of all negative values this entry (if stacked) contains. (this is a positive number)
  112|       |    @objc open var negativeSum: Double
  113|      0|    {
  114|      0|        return _negativeSum
  115|      0|    }
  116|       |    
  117|       |    /// The sum of all positive values this entry (if stacked) contains.
  118|       |    @objc open var positiveSum: Double
  119|      0|    {
  120|      0|        return _positiveSum
  121|      0|    }
  122|       |
  123|       |    @objc open func calcPosNegSum()
  124|      0|    {
  125|      0|        (_negativeSum, _positiveSum) = _yVals?.reduce(into: (0,0)) { (result, y) in
  126|      0|            if y < 0
  127|      0|            {
  128|      0|                result.0 += -y
  129|      0|            }
  130|      0|            else
  131|      0|            {
  132|      0|                result.1 += y
  133|      0|            }
  134|      0|        } ?? (0,0)
  135|      0|    }
  136|       |    
  137|       |    /// Splits up the stack-values of the given bar-entry into Range objects.
  138|       |    ///
  139|       |    /// - Parameters:
  140|       |    ///   - entry:
  141|       |    /// - Returns:
  142|       |    @objc open func calcRanges()
  143|      0|    {
  144|      0|        guard let values = yValues, !values.isEmpty else { return }
  145|      0|
  146|      0|        if _ranges == nil
  147|      0|        {
  148|      0|            _ranges = [Range]()
  149|      0|        }
  150|      0|        else
  151|      0|        {
  152|      0|            _ranges!.removeAll()
  153|      0|        }
  154|      0|        
  155|      0|        _ranges!.reserveCapacity(values.count)
  156|      0|        
  157|      0|        var negRemain = -negativeSum
  158|      0|        var posRemain: Double = 0.0
  159|      0|        
  160|      0|        for value in values
  161|      0|        {
  162|      0|            if value < 0
  163|      0|            {
  164|      0|                _ranges!.append(Range(from: negRemain, to: negRemain - value))
  165|      0|                negRemain -= value
  166|      0|            }
  167|      0|            else
  168|      0|            {
  169|      0|                _ranges!.append(Range(from: posRemain, to: posRemain + value))
  170|      0|                posRemain += value
  171|      0|            }
  172|      0|        }
  173|      0|    }
  174|       |    
  175|       |    // MARK: Accessors
  176|       |    
  177|       |    /// the values the stacked barchart holds
  178|      0|    @objc open var isStacked: Bool { return _yVals != nil }
  179|       |    
  180|       |    /// the values the stacked barchart holds
  181|       |    @objc open var yValues: [Double]?
  182|       |    {
  183|      0|        get { return self._yVals }
  184|       |        set
  185|      0|        {
  186|      0|            self.y = BarChartDataEntry.calcSum(values: newValue)
  187|      0|            self._yVals = newValue
  188|      0|            calcPosNegSum()
  189|      0|            calcRanges()
  190|      0|        }
  191|       |    }
  192|       |    
  193|       |    /// The ranges of the individual stack-entries. Will return null if this entry is not stacked.
  194|       |    @objc open var ranges: [Range]?
  195|      0|    {
  196|      0|        return _ranges
  197|      0|    }
  198|       |    
  199|       |    // MARK: NSCopying
  200|       |    
  201|       |    open override func copy(with zone: NSZone? = nil) -> Any
  202|      0|    {
  203|      0|        let copy = super.copy(with: zone) as! BarChartDataEntry
  204|      0|        copy._yVals = _yVals
  205|      0|        copy.y = y
  206|      0|        copy._negativeSum = _negativeSum
  207|      0|        copy._positiveSum = _positiveSum
  208|      0|        return copy
  209|      0|    }
  210|       |    
  211|       |    /// Calculates the sum across all values of the given stack.
  212|       |    ///
  213|       |    /// - Parameters:
  214|       |    ///   - vals:
  215|       |    /// - Returns:
  216|       |    private static func calcSum(values: [Double]?) -> Double
  217|      0|    {
  218|      0|        guard let values = values
  219|      0|            else { return 0.0 }
  220|      0|        
  221|      0|        var sum = 0.0
  222|      0|        
  223|      0|        for f in values
  224|      0|        {
  225|      0|            sum += f
  226|      0|        }
  227|      0|        
  228|      0|        return sum
  229|      0|    }
  230|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/BarChartDataSet.swift:
    1|       |//
    2|       |//  BarChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class BarChartDataSet: BarLineScatterCandleBubbleChartDataSet, IBarChartDataSet
   17|       |{
   18|       |    private func initialize()
   19|      0|    {
   20|      0|        self.highlightColor = NSUIColor.black
   21|      0|        
   22|      0|        self.calcStackSize(entries: entries as! [BarChartDataEntry])
   23|      0|        self.calcEntryCountIncludingStacks(entries: entries as! [BarChartDataEntry])
   24|      0|    }
   25|       |    
   26|       |    public required init()
   27|      0|    {
   28|      0|        super.init()
   29|      0|        initialize()
   30|      0|    }
   31|       |    
   32|       |    public override init(entries: [ChartDataEntry]?, label: String?)
   33|      0|    {
   34|      0|        super.init(entries: entries, label: label)
   35|      0|        initialize()
   36|      0|    }
   37|       |
   38|       |    // MARK: - Data functions and accessors
   39|       |    
   40|       |    /// the maximum number of bars that are stacked upon each other, this value
   41|       |    /// is calculated from the Entries that are added to the DataSet
   42|       |    private var _stackSize = 1
   43|       |    
   44|       |    /// the overall entry count, including counting each stack-value individually
   45|       |    private var _entryCountStacks = 0
   46|       |    
   47|       |    /// Calculates the total number of entries this DataSet represents, including
   48|       |    /// stacks. All values belonging to a stack are calculated separately.
   49|       |    private func calcEntryCountIncludingStacks(entries: [BarChartDataEntry])
   50|      0|    {
   51|      0|        _entryCountStacks = 0
   52|      0|        
   53|      0|        for i in 0 ..< entries.count
   54|      0|        {
   55|      0|            if let vals = entries[i].yValues
   56|      0|            {
   57|      0|                _entryCountStacks += vals.count
   58|      0|            }
   59|      0|            else
   60|      0|            {
   61|      0|                _entryCountStacks += 1
   62|      0|            }
   63|      0|        }
   64|      0|    }
   65|       |    
   66|       |    /// calculates the maximum stacksize that occurs in the Entries array of this DataSet
   67|       |    private func calcStackSize(entries: [BarChartDataEntry])
   68|      0|    {
   69|      0|        for i in 0 ..< entries.count
   70|      0|        {
   71|      0|            if let vals = entries[i].yValues
   72|      0|            {
   73|      0|                if vals.count > _stackSize
   74|      0|                {
   75|      0|                    _stackSize = vals.count
   76|      0|                }
   77|      0|            }
   78|      0|        }
   79|      0|    }
   80|       |    
   81|       |    open override func calcMinMax(entry e: ChartDataEntry)
   82|      0|    {
   83|      0|        guard let e = e as? BarChartDataEntry
   84|      0|            else { return }
   85|      0|        
   86|      0|        if !e.y.isNaN
   87|      0|        {
   88|      0|            if e.yValues == nil
   89|      0|            {
   90|      0|                if e.y < _yMin
   91|      0|                {
   92|      0|                    _yMin = e.y
   93|      0|                }
   94|      0|                
   95|      0|                if e.y > _yMax
   96|      0|                {
   97|      0|                    _yMax = e.y
   98|      0|                }
   99|      0|            }
  100|      0|            else
  101|      0|            {
  102|      0|                if -e.negativeSum < _yMin
  103|      0|                {
  104|      0|                    _yMin = -e.negativeSum
  105|      0|                }
  106|      0|                
  107|      0|                if e.positiveSum > _yMax
  108|      0|                {
  109|      0|                    _yMax = e.positiveSum
  110|      0|                }
  111|      0|            }
  112|      0|            
  113|      0|            calcMinMaxX(entry: e)
  114|      0|        }
  115|      0|    }
  116|       |    
  117|       |    /// The maximum number of bars that can be stacked upon another in this DataSet.
  118|       |    open var stackSize: Int
  119|      0|    {
  120|      0|        return _stackSize
  121|      0|    }
  122|       |    
  123|       |    /// `true` if this DataSet is stacked (stacksize > 1) or not.
  124|       |    open var isStacked: Bool
  125|      0|    {
  126|      0|        return _stackSize > 1 ? true : false
  127|      0|    }
  128|       |    
  129|       |    /// The overall entry count, including counting each stack-value individually
  130|       |    @objc open var entryCountStacks: Int
  131|      0|    {
  132|      0|        return _entryCountStacks
  133|      0|    }
  134|       |    
  135|       |    /// array of labels used to describe the different values of the stacked bars
  136|      0|    open var stackLabels: [String] = []
  137|       |    
  138|       |    // MARK: - Styling functions and accessors
  139|       |    
  140|       |    /// the color used for drawing the bar-shadows. The bar shadows is a surface behind the bar that indicates the maximum value
  141|      0|    open var barShadowColor = NSUIColor(red: 215.0/255.0, green: 215.0/255.0, blue: 215.0/255.0, alpha: 1.0)
  142|       |
  143|       |    /// the width used for drawing borders around the bars. If borderWidth == 0, no border will be drawn.
  144|       |    open var barBorderWidth : CGFloat = 0.0
  145|       |
  146|       |    /// the color drawing borders around the bars.
  147|      0|    open var barBorderColor = NSUIColor.black
  148|       |
  149|       |    /// the alpha value (transparency) that is used for drawing the highlight indicator bar. min = 0.0 (fully transparent), max = 1.0 (fully opaque)
  150|      0|    open var highlightAlpha = CGFloat(120.0 / 255.0)
  151|       |    
  152|       |    // MARK: - NSCopying
  153|       |    
  154|       |    open override func copy(with zone: NSZone? = nil) -> Any
  155|      0|    {
  156|      0|        let copy = super.copy(with: zone) as! BarChartDataSet
  157|      0|        copy._stackSize = _stackSize
  158|      0|        copy._entryCountStacks = _entryCountStacks
  159|      0|        copy.stackLabels = stackLabels
  160|      0|
  161|      0|        copy.barShadowColor = barShadowColor
  162|      0|        copy.barBorderWidth = barBorderWidth
  163|      0|        copy.barBorderColor = barBorderColor
  164|      0|        copy.highlightAlpha = highlightAlpha
  165|      0|        return copy
  166|      0|    }
  167|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/BarLineScatterCandleBubbleChartData.swift:
    1|       |//
    2|       |//  BarLineScatterCandleBubbleChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class BarLineScatterCandleBubbleChartData: ChartData
   15|       |{
   16|       |    public override init()
   17|      0|    {
   18|      0|        super.init()
   19|      0|    }
   20|       |    
   21|       |    public override init(dataSets: [IChartDataSet]?)
   22|      0|    {
   23|      0|        super.init(dataSets: dataSets)
   24|      0|    }
   25|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/BarLineScatterCandleBubbleChartDataSet.swift:
    1|       |//
    2|       |//  BarLineScatterCandleBubbleChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class BarLineScatterCandleBubbleChartDataSet: ChartDataSet, IBarLineScatterCandleBubbleChartDataSet
   17|       |{
   18|       |    // MARK: - Data functions and accessors
   19|       |    
   20|       |    // MARK: - Styling functions and accessors
   21|       |    
   22|      0|    open var highlightColor = NSUIColor(red: 255.0/255.0, green: 187.0/255.0, blue: 115.0/255.0, alpha: 1.0)
   23|      0|    open var highlightLineWidth = CGFloat(0.5)
   24|      0|    open var highlightLineDashPhase = CGFloat(0.0)
   25|       |    open var highlightLineDashLengths: [CGFloat]?
   26|       |    
   27|       |    // MARK: - NSCopying
   28|       |    
   29|       |    open override func copy(with zone: NSZone? = nil) -> Any
   30|      0|    {
   31|      0|        let copy = super.copy(with: zone) as! BarLineScatterCandleBubbleChartDataSet
   32|      0|        copy.highlightColor = highlightColor
   33|      0|        copy.highlightLineWidth = highlightLineWidth
   34|      0|        copy.highlightLineDashPhase = highlightLineDashPhase
   35|      0|        copy.highlightLineDashLengths = highlightLineDashLengths
   36|      0|        return copy
   37|      0|    }
   38|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/BubbleChartData.swift:
    1|       |//
    2|       |//  BubbleChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Bubble chart implementation:
    6|       |//    Copyright 2015 Pierre-Marc Airoldi
    7|       |//    Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class BubbleChartData: BarLineScatterCandleBubbleChartData
   16|       |{
   17|       |    public override init()
   18|      0|    {
   19|      0|        super.init()
   20|      0|    }
   21|       |    
   22|       |    public override init(dataSets: [IChartDataSet]?)
   23|      0|    {
   24|      0|        super.init(dataSets: dataSets)
   25|      0|    }
   26|       |    
   27|       |    /// Sets the width of the circle that surrounds the bubble when highlighted for all DataSet objects this data object contains
   28|       |    @objc open func setHighlightCircleWidth(_ width: CGFloat)
   29|      0|    {
   30|      0|        (_dataSets as? [IBubbleChartDataSet])?.forEach { $0.highlightCircleWidth = width }
   31|      0|    }
   32|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/BubbleChartDataEntry.swift:
    1|       |//
    2|       |//  BubbleDataEntry.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Bubble chart implementation: 
    6|       |//    Copyright 2015 Pierre-Marc Airoldi
    7|       |//    Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class BubbleChartDataEntry: ChartDataEntry
   16|       |{
   17|       |    /// The size of the bubble.
   18|      0|    @objc open var size = CGFloat(0.0)
   19|       |    
   20|       |    public required init()
   21|      0|    {
   22|      0|        super.init()
   23|      0|    }
   24|       |    
   25|       |    /// - Parameters:
   26|       |    ///   - x: The index on the x-axis.
   27|       |    ///   - y: The value on the y-axis.
   28|       |    ///   - size: The size of the bubble.
   29|       |    @objc public init(x: Double, y: Double, size: CGFloat)
   30|      0|    {
   31|      0|        super.init(x: x, y: y)
   32|      0|        
   33|      0|        self.size = size
   34|      0|    }
   35|       |    
   36|       |    /// - Parameters:
   37|       |    ///   - x: The index on the x-axis.
   38|       |    ///   - y: The value on the y-axis.
   39|       |    ///   - size: The size of the bubble.
   40|       |    ///   - data: Spot for additional data this Entry represents.
   41|       |    @objc public convenience init(x: Double, y: Double, size: CGFloat, data: Any?)
   42|      0|    {
   43|      0|        self.init(x: x, y: y, size: size)
   44|      0|        self.data = data
   45|      0|    }
   46|       |    
   47|       |    /// - Parameters:
   48|       |    ///   - x: The index on the x-axis.
   49|       |    ///   - y: The value on the y-axis.
   50|       |    ///   - size: The size of the bubble.
   51|       |    ///   - icon: icon image
   52|       |    @objc public convenience init(x: Double, y: Double, size: CGFloat, icon: NSUIImage?)
   53|      0|    {
   54|      0|        self.init(x: x, y: y, size: size)
   55|      0|        self.icon = icon
   56|      0|    }
   57|       |    
   58|       |    /// - Parameters:
   59|       |    ///   - x: The index on the x-axis.
   60|       |    ///   - y: The value on the y-axis.
   61|       |    ///   - size: The size of the bubble.
   62|       |    ///   - icon: icon image
   63|       |    ///   - data: Spot for additional data this Entry represents.
   64|       |    @objc public convenience init(x: Double, y: Double, size: CGFloat, icon: NSUIImage?, data: Any?)
   65|      0|    {
   66|      0|        self.init(x: x, y: y, size: size)
   67|      0|        self.icon = icon
   68|      0|        self.data = data
   69|      0|    }
   70|       |    
   71|       |    // MARK: NSCopying
   72|       |    
   73|       |    open override func copy(with zone: NSZone? = nil) -> Any
   74|      0|    {
   75|      0|        let copy = super.copy(with: zone) as! BubbleChartDataEntry
   76|      0|        copy.size = size
   77|      0|        return copy
   78|      0|    }
   79|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/BubbleChartDataSet.swift:
    1|       |//
    2|       |//  BubbleChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Bubble chart implementation:
    6|       |//    Copyright 2015 Pierre-Marc Airoldi
    7|       |//    Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class BubbleChartDataSet: BarLineScatterCandleBubbleChartDataSet, IBubbleChartDataSet
   17|       |{
   18|       |    // MARK: - Data functions and accessors
   19|       |    
   20|      0|    internal var _maxSize = CGFloat(0.0)
   21|       |    
   22|      0|    open var maxSize: CGFloat { return _maxSize }
   23|       |    @objc open var normalizeSizeEnabled: Bool = true
   24|      0|    open var isNormalizeSizeEnabled: Bool { return normalizeSizeEnabled }
   25|       |    
   26|       |    open override func calcMinMax(entry e: ChartDataEntry)
   27|      0|    {
   28|      0|        guard let e = e as? BubbleChartDataEntry
   29|      0|            else { return }
   30|      0|        
   31|      0|        super.calcMinMax(entry: e)
   32|      0|        
   33|      0|        let size = e.size
   34|      0|        
   35|      0|        if size > _maxSize
   36|      0|        {
   37|      0|            _maxSize = size
   38|      0|        }
   39|      0|    }
   40|       |    
   41|       |    // MARK: - Styling functions and accessors
   42|       |    
   43|       |    /// Sets/gets the width of the circle that surrounds the bubble when highlighted
   44|       |    open var highlightCircleWidth: CGFloat = 2.5
   45|       |    
   46|       |    // MARK: - NSCopying
   47|       |    
   48|       |    open override func copy(with zone: NSZone? = nil) -> Any
   49|      0|    {
   50|      0|        let copy = super.copy(with: zone) as! BubbleChartDataSet
   51|      0|        copy._xMin = _xMin
   52|      0|        copy._xMax = _xMax
   53|      0|        copy._maxSize = _maxSize
   54|      0|        copy.normalizeSizeEnabled = normalizeSizeEnabled
   55|      0|        copy.highlightCircleWidth = highlightCircleWidth
   56|      0|        return copy
   57|      0|    }
   58|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/CandleChartData.swift:
    1|       |//
    2|       |//  CandleChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class CandleChartData: BarLineScatterCandleBubbleChartData
   15|       |{
   16|       |    public override init()
   17|      0|    {
   18|      0|        super.init()
   19|      0|    }
   20|       |    
   21|       |    public override init(dataSets: [IChartDataSet]?)
   22|      0|    {
   23|      0|        super.init(dataSets: dataSets)
   24|      0|    }
   25|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/CandleChartDataEntry.swift:
    1|       |//
    2|       |//  CandleChartDataEntry.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class CandleChartDataEntry: ChartDataEntry
   15|       |{
   16|       |    /// shadow-high value
   17|      0|    @objc open var high = Double(0.0)
   18|       |    
   19|       |    /// shadow-low value
   20|      0|    @objc open var low = Double(0.0)
   21|       |    
   22|       |    /// close value
   23|      0|    @objc open var close = Double(0.0)
   24|       |    
   25|       |    /// open value
   26|      0|    @objc open var open = Double(0.0)
   27|       |    
   28|       |    public required init()
   29|      0|    {
   30|      0|        super.init()
   31|      0|    }
   32|       |    
   33|       |    @objc public init(x: Double, shadowH: Double, shadowL: Double, open: Double, close: Double)
   34|      0|    {
   35|      0|        super.init(x: x, y: (shadowH + shadowL) / 2.0)
   36|      0|        
   37|      0|        self.high = shadowH
   38|      0|        self.low = shadowL
   39|      0|        self.open = open
   40|      0|        self.close = close
   41|      0|    }
   42|       |
   43|       |    @objc public convenience init(x: Double, shadowH: Double, shadowL: Double, open: Double, close: Double, icon: NSUIImage?)
   44|      0|    {
   45|      0|        self.init(x: x, shadowH: shadowH, shadowL: shadowL, open: open, close: close)
   46|      0|        self.icon = icon
   47|      0|    }
   48|       |
   49|       |    @objc public convenience init(x: Double, shadowH: Double, shadowL: Double, open: Double, close: Double, data: Any?)
   50|      0|    {
   51|      0|        self.init(x: x, shadowH: shadowH, shadowL: shadowL, open: open, close: close)
   52|      0|        self.data = data
   53|      0|    }
   54|       |
   55|       |    @objc public convenience init(x: Double, shadowH: Double, shadowL: Double, open: Double, close: Double, icon: NSUIImage?, data: Any?)
   56|      0|    {
   57|      0|        self.init(x: x, shadowH: shadowH, shadowL: shadowL, open: open, close: close)
   58|      0|        self.icon = icon
   59|      0|        self.data = data
   60|      0|    }
   61|       |    
   62|       |    /// The overall range (difference) between shadow-high and shadow-low.
   63|       |    @objc open var shadowRange: Double
   64|      0|    {
   65|      0|        return abs(high - low)
   66|      0|    }
   67|       |    
   68|       |    /// The body size (difference between open and close).
   69|       |    @objc open var bodyRange: Double
   70|      0|    {
   71|      0|        return abs(open - close)
   72|      0|    }
   73|       |    
   74|       |    /// the center value of the candle. (Middle value between high and low)
   75|       |    open override var y: Double
   76|       |    {
   77|       |        get
   78|      0|        {
   79|      0|            return super.y
   80|      0|        }
   81|       |        set
   82|      0|        {
   83|      0|            super.y = (high + low) / 2.0
   84|      0|        }
   85|       |    }
   86|       |    
   87|       |    // MARK: NSCopying
   88|       |    
   89|       |    open override func copy(with zone: NSZone? = nil) -> Any
   90|      0|    {
   91|      0|        let copy = super.copy(with: zone) as! CandleChartDataEntry
   92|      0|        copy.high = high
   93|      0|        copy.low = low
   94|      0|        copy.open = open
   95|      0|        copy.close = close
   96|      0|        return copy
   97|      0|    }
   98|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/CandleChartDataSet.swift:
    1|       |//
    2|       |//  CandleChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class CandleChartDataSet: LineScatterCandleRadarChartDataSet, ICandleChartDataSet
   17|       |{
   18|       |    
   19|       |    public required init()
   20|      0|    {
   21|      0|        super.init()
   22|      0|    }
   23|       |    
   24|       |    public override init(entries: [ChartDataEntry]?, label: String?)
   25|      0|    {
   26|      0|        super.init(entries: entries, label: label)
   27|      0|    }
   28|       |    
   29|       |    // MARK: - Data functions and accessors
   30|       |    
   31|       |    open override func calcMinMax(entry e: ChartDataEntry)
   32|      0|    {
   33|      0|        guard let e = e as? CandleChartDataEntry
   34|      0|            else { return }
   35|      0|        
   36|      0|        if e.low < _yMin
   37|      0|        {
   38|      0|            _yMin = e.low
   39|      0|        }
   40|      0|        
   41|      0|        if e.high > _yMax
   42|      0|        {
   43|      0|            _yMax = e.high
   44|      0|        }
   45|      0|        
   46|      0|        calcMinMaxX(entry: e)
   47|      0|    }
   48|       |    
   49|       |    open override func calcMinMaxY(entry e: ChartDataEntry)
   50|      0|    {
   51|      0|        guard let e = e as? CandleChartDataEntry
   52|      0|            else { return }
   53|      0|        
   54|      0|        if e.high < _yMin
   55|      0|        {
   56|      0|            _yMin = e.high
   57|      0|        }
   58|      0|        if e.high > _yMax
   59|      0|        {
   60|      0|            _yMax = e.high
   61|      0|        }
   62|      0|        
   63|      0|        if e.low < _yMin
   64|      0|        {
   65|      0|            _yMin = e.low
   66|      0|        }
   67|      0|        if e.low > _yMax
   68|      0|        {
   69|      0|            _yMax = e.low
   70|      0|        }
   71|      0|    }
   72|       |    
   73|       |    // MARK: - Styling functions and accessors
   74|       |    
   75|       |    /// the space between the candle entries
   76|       |    ///
   77|       |    /// **default**: 0.1 (10%)
   78|      0|    private var _barSpace = CGFloat(0.1)
   79|       |    
   80|       |    /// the space that is left out on the left and right side of each candle,
   81|       |    /// **default**: 0.1 (10%), max 0.45, min 0.0
   82|       |    open var barSpace: CGFloat
   83|       |    {
   84|       |        get
   85|      0|        {
   86|      0|            return _barSpace
   87|      0|        }
   88|       |        set
   89|      0|        {
   90|      0|            _barSpace = newValue.clamped(to: 0...0.45)
   91|      0|        }
   92|       |    }
   93|       |    
   94|       |    /// should the candle bars show?
   95|       |    /// when false, only "ticks" will show
   96|       |    ///
   97|       |    /// **default**: true
   98|       |    open var showCandleBar: Bool = true
   99|       |    
  100|       |    /// the width of the candle-shadow-line in pixels.
  101|       |    ///
  102|       |    /// **default**: 1.5
  103|      0|    open var shadowWidth = CGFloat(1.5)
  104|       |    
  105|       |    /// the color of the shadow line
  106|       |    open var shadowColor: NSUIColor?
  107|       |    
  108|       |    /// use candle color for the shadow
  109|       |    open var shadowColorSameAsCandle = false
  110|       |    
  111|       |    /// Is the shadow color same as the candle color?
  112|      0|    open var isShadowColorSameAsCandle: Bool { return shadowColorSameAsCandle }
  113|       |    
  114|       |    /// color for open == close
  115|       |    open var neutralColor: NSUIColor?
  116|       |    
  117|       |    /// color for open > close
  118|       |    open var increasingColor: NSUIColor?
  119|       |    
  120|       |    /// color for open < close
  121|       |    open var decreasingColor: NSUIColor?
  122|       |    
  123|       |    /// Are increasing values drawn as filled?
  124|       |    /// increasing candlesticks are traditionally hollow
  125|       |    open var increasingFilled = false
  126|       |    
  127|       |    /// Are increasing values drawn as filled?
  128|      0|    open var isIncreasingFilled: Bool { return increasingFilled }
  129|       |    
  130|       |    /// Are decreasing values drawn as filled?
  131|       |    /// descreasing candlesticks are traditionally filled
  132|       |    open var decreasingFilled = true
  133|       |    
  134|       |    /// Are decreasing values drawn as filled?
  135|      0|    open var isDecreasingFilled: Bool { return decreasingFilled }
  136|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/ChartData.swift:
    1|       |//
    2|       |//  ChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class ChartData: NSObject
   15|       |{
   16|      0|    internal var _yMax: Double = -Double.greatestFiniteMagnitude
   17|      0|    internal var _yMin: Double = Double.greatestFiniteMagnitude
   18|      0|    internal var _xMax: Double = -Double.greatestFiniteMagnitude
   19|      0|    internal var _xMin: Double = Double.greatestFiniteMagnitude
   20|      0|    internal var _leftAxisMax: Double = -Double.greatestFiniteMagnitude
   21|      0|    internal var _leftAxisMin: Double = Double.greatestFiniteMagnitude
   22|      0|    internal var _rightAxisMax: Double = -Double.greatestFiniteMagnitude
   23|      0|    internal var _rightAxisMin: Double = Double.greatestFiniteMagnitude
   24|       |    
   25|      0|    internal var _dataSets = [IChartDataSet]()
   26|       |    
   27|       |    public override init()
   28|      0|    {
   29|      0|        super.init()
   30|      0|        
   31|      0|        _dataSets = [IChartDataSet]()
   32|      0|    }
   33|       |    
   34|       |    @objc public init(dataSets: [IChartDataSet]?)
   35|      0|    {
   36|      0|        super.init()
   37|      0|        
   38|      0|        _dataSets = dataSets ?? [IChartDataSet]()
   39|      0|        
   40|      0|        self.initialize(dataSets: _dataSets)
   41|      0|    }
   42|       |    
   43|       |    @objc public convenience init(dataSet: IChartDataSet?)
   44|      0|    {
   45|      0|        self.init(dataSets: dataSet === nil ? nil : [dataSet!])
   46|      0|    }
   47|       |    
   48|       |    internal func initialize(dataSets: [IChartDataSet])
   49|      0|    {
   50|      0|        notifyDataChanged()
   51|      0|    }
   52|       |    
   53|       |    /// Call this method to let the ChartData know that the underlying data has changed.
   54|       |    /// Calling this performs all necessary recalculations needed when the contained data has changed.
   55|       |    @objc open func notifyDataChanged()
   56|      0|    {
   57|      0|        calcMinMax()
   58|      0|    }
   59|       |    
   60|       |    @objc open func calcMinMaxY(fromX: Double, toX: Double)
   61|      0|    {
   62|      0|        _dataSets.forEach { $0.calcMinMaxY(fromX: fromX, toX: toX) }
   63|      0|        // apply the new data
   64|      0|        calcMinMax()
   65|      0|    }
   66|       |    
   67|       |    /// calc minimum and maximum y value over all datasets
   68|       |    @objc open func calcMinMax()
   69|      0|    {
   70|      0|        _yMax = -Double.greatestFiniteMagnitude
   71|      0|        _yMin = Double.greatestFiniteMagnitude
   72|      0|        _xMax = -Double.greatestFiniteMagnitude
   73|      0|        _xMin = Double.greatestFiniteMagnitude
   74|      0|        
   75|      0|        _dataSets.forEach { calcMinMax(dataSet: $0) }
   76|      0|        
   77|      0|        _leftAxisMax = -Double.greatestFiniteMagnitude
   78|      0|        _leftAxisMin = Double.greatestFiniteMagnitude
   79|      0|        _rightAxisMax = -Double.greatestFiniteMagnitude
   80|      0|        _rightAxisMin = Double.greatestFiniteMagnitude
   81|      0|        
   82|      0|        // left axis
   83|      0|        let firstLeft = getFirstLeft(dataSets: dataSets)
   84|      0|        
   85|      0|        if firstLeft !== nil
   86|      0|        {
   87|      0|            _leftAxisMax = firstLeft!.yMax
   88|      0|            _leftAxisMin = firstLeft!.yMin
   89|      0|            
   90|      0|            for dataSet in _dataSets
   91|      0|            {
   92|      0|                if dataSet.axisDependency == .left
   93|      0|                {
   94|      0|                    if dataSet.yMin < _leftAxisMin
   95|      0|                    {
   96|      0|                        _leftAxisMin = dataSet.yMin
   97|      0|                    }
   98|      0|                    
   99|      0|                    if dataSet.yMax > _leftAxisMax
  100|      0|                    {
  101|      0|                        _leftAxisMax = dataSet.yMax
  102|      0|                    }
  103|      0|                }
  104|      0|            }
  105|      0|        }
  106|      0|        
  107|      0|        // right axis
  108|      0|        let firstRight = getFirstRight(dataSets: dataSets)
  109|      0|        
  110|      0|        if firstRight !== nil
  111|      0|        {
  112|      0|            _rightAxisMax = firstRight!.yMax
  113|      0|            _rightAxisMin = firstRight!.yMin
  114|      0|            
  115|      0|            for dataSet in _dataSets
  116|      0|            {
  117|      0|                if dataSet.axisDependency == .right
  118|      0|                {
  119|      0|                    if dataSet.yMin < _rightAxisMin
  120|      0|                    {
  121|      0|                        _rightAxisMin = dataSet.yMin
  122|      0|                    }
  123|      0|                    
  124|      0|                    if dataSet.yMax > _rightAxisMax
  125|      0|                    {
  126|      0|                        _rightAxisMax = dataSet.yMax
  127|      0|                    }
  128|      0|                }
  129|      0|            }
  130|      0|        }
  131|      0|    }
  132|       |    
  133|       |    /// Adjusts the current minimum and maximum values based on the provided Entry object.
  134|       |    @objc open func calcMinMax(entry e: ChartDataEntry, axis: YAxis.AxisDependency)
  135|      0|    {
  136|      0|        if _yMax < e.y
  137|      0|        {
  138|      0|            _yMax = e.y
  139|      0|        }
  140|      0|        
  141|      0|        if _yMin > e.y
  142|      0|        {
  143|      0|            _yMin = e.y
  144|      0|        }
  145|      0|        
  146|      0|        if _xMax < e.x
  147|      0|        {
  148|      0|            _xMax = e.x
  149|      0|        }
  150|      0|        
  151|      0|        if _xMin > e.x
  152|      0|        {
  153|      0|            _xMin = e.x
  154|      0|        }
  155|      0|        
  156|      0|        if axis == .left
  157|      0|        {
  158|      0|            if _leftAxisMax < e.y
  159|      0|            {
  160|      0|                _leftAxisMax = e.y
  161|      0|            }
  162|      0|            
  163|      0|            if _leftAxisMin > e.y
  164|      0|            {
  165|      0|                _leftAxisMin = e.y
  166|      0|            }
  167|      0|        }
  168|      0|        else
  169|      0|        {
  170|      0|            if _rightAxisMax < e.y
  171|      0|            {
  172|      0|                _rightAxisMax = e.y
  173|      0|            }
  174|      0|            
  175|      0|            if _rightAxisMin > e.y
  176|      0|            {
  177|      0|                _rightAxisMin = e.y
  178|      0|            }
  179|      0|        }
  180|      0|    }
  181|       |    
  182|       |    /// Adjusts the minimum and maximum values based on the given DataSet.
  183|       |    @objc open func calcMinMax(dataSet d: IChartDataSet)
  184|      0|    {
  185|      0|        if _yMax < d.yMax
  186|      0|        {
  187|      0|            _yMax = d.yMax
  188|      0|        }
  189|      0|        
  190|      0|        if _yMin > d.yMin
  191|      0|        {
  192|      0|            _yMin = d.yMin
  193|      0|        }
  194|      0|        
  195|      0|        if _xMax < d.xMax
  196|      0|        {
  197|      0|            _xMax = d.xMax
  198|      0|        }
  199|      0|        
  200|      0|        if _xMin > d.xMin
  201|      0|        {
  202|      0|            _xMin = d.xMin
  203|      0|        }
  204|      0|        
  205|      0|        if d.axisDependency == .left
  206|      0|        {
  207|      0|            if _leftAxisMax < d.yMax
  208|      0|            {
  209|      0|                _leftAxisMax = d.yMax
  210|      0|            }
  211|      0|            
  212|      0|            if _leftAxisMin > d.yMin
  213|      0|            {
  214|      0|                _leftAxisMin = d.yMin
  215|      0|            }
  216|      0|        }
  217|      0|        else
  218|      0|        {
  219|      0|            if _rightAxisMax < d.yMax
  220|      0|            {
  221|      0|                _rightAxisMax = d.yMax
  222|      0|            }
  223|      0|            
  224|      0|            if _rightAxisMin > d.yMin
  225|      0|            {
  226|      0|                _rightAxisMin = d.yMin
  227|      0|            }
  228|      0|        }
  229|      0|    }
  230|       |    
  231|       |    /// The number of LineDataSets this object contains
  232|       |    @objc open var dataSetCount: Int
  233|      0|    {
  234|      0|        return _dataSets.count
  235|      0|    }
  236|       |    
  237|       |    /// The smallest y-value the data object contains.
  238|       |    @objc open var yMin: Double
  239|      0|    {
  240|      0|        return _yMin
  241|      0|    }
  242|       |    
  243|       |    @nonobjc
  244|       |    open func getYMin() -> Double
  245|      0|    {
  246|      0|        return _yMin
  247|      0|    }
  248|       |    
  249|       |    @objc open func getYMin(axis: YAxis.AxisDependency) -> Double
  250|      0|    {
  251|      0|        if axis == .left
  252|      0|        {
  253|      0|            if _leftAxisMin == Double.greatestFiniteMagnitude
  254|      0|            {
  255|      0|                return _rightAxisMin
  256|      0|            }
  257|      0|            else
  258|      0|            {
  259|      0|                return _leftAxisMin
  260|      0|            }
  261|      0|        }
  262|      0|        else
  263|      0|        {
  264|      0|            if _rightAxisMin == Double.greatestFiniteMagnitude
  265|      0|            {
  266|      0|                return _leftAxisMin
  267|      0|            }
  268|      0|            else
  269|      0|            {
  270|      0|                return _rightAxisMin
  271|      0|            }
  272|      0|        }
  273|      0|    }
  274|       |    
  275|       |    /// The greatest y-value the data object contains.
  276|       |    @objc open var yMax: Double
  277|      0|    {
  278|      0|        return _yMax
  279|      0|    }
  280|       |    
  281|       |    @nonobjc
  282|       |    open func getYMax() -> Double
  283|      0|    {
  284|      0|        return _yMax
  285|      0|    }
  286|       |    
  287|       |    @objc open func getYMax(axis: YAxis.AxisDependency) -> Double
  288|      0|    {
  289|      0|        if axis == .left
  290|      0|        {
  291|      0|            if _leftAxisMax == -Double.greatestFiniteMagnitude
  292|      0|            {
  293|      0|                return _rightAxisMax
  294|      0|            }
  295|      0|            else
  296|      0|            {
  297|      0|                return _leftAxisMax
  298|      0|            }
  299|      0|        }
  300|      0|        else
  301|      0|        {
  302|      0|            if _rightAxisMax == -Double.greatestFiniteMagnitude
  303|      0|            {
  304|      0|                return _leftAxisMax
  305|      0|            }
  306|      0|            else
  307|      0|            {
  308|      0|                return _rightAxisMax
  309|      0|            }
  310|      0|        }
  311|      0|    }
  312|       |    
  313|       |    /// The minimum x-value the data object contains.
  314|       |    @objc open var xMin: Double
  315|      0|    {
  316|      0|        return _xMin
  317|      0|    }
  318|       |    /// The maximum x-value the data object contains.
  319|       |    @objc open var xMax: Double
  320|      0|    {
  321|      0|        return _xMax
  322|      0|    }
  323|       |    
  324|       |    /// All DataSet objects this ChartData object holds.
  325|       |    @objc open var dataSets: [IChartDataSet]
  326|       |    {
  327|       |        get
  328|      0|        {
  329|      0|            return _dataSets
  330|      0|        }
  331|       |        set
  332|      0|        {
  333|      0|            _dataSets = newValue
  334|      0|            notifyDataChanged()
  335|      0|        }
  336|       |    }
  337|       |    
  338|       |    /// Retrieve the index of a ChartDataSet with a specific label from the ChartData. Search can be case sensitive or not.
  339|       |    /// 
  340|       |    /// **IMPORTANT: This method does calculations at runtime, do not over-use in performance critical situations.**
  341|       |    ///
  342|       |    /// - Parameters:
  343|       |    ///   - dataSets: the DataSet array to search
  344|       |    ///   - type:
  345|       |    ///   - ignorecase: if true, the search is not case-sensitive
  346|       |    /// - Returns: The index of the DataSet Object with the given label. Sensitive or not.
  347|       |    internal func getDataSetIndexByLabel(_ label: String, ignorecase: Bool) -> Int
  348|      0|    {
  349|      0|        // TODO: Return nil instead of -1
  350|      0|        if ignorecase
  351|      0|        {
  352|      0|            return dataSets.firstIndex { $0.label?.caseInsensitiveCompare(label) == .orderedSame }
  353|      0|                ?? -1
  354|      0|        }
  355|      0|        else
  356|      0|        {
  357|      0|            return dataSets.firstIndex { $0.label == label }
  358|      0|                ?? -1
  359|      0|        }
  360|      0|    }
  361|       |
  362|       |    /// Get the Entry for a corresponding highlight object
  363|       |    ///
  364|       |    /// - Parameters:
  365|       |    ///   - highlight:
  366|       |    /// - Returns: The entry that is highlighted
  367|       |    @objc open func entryForHighlight(_ highlight: Highlight) -> ChartDataEntry?
  368|      0|    {
  369|      0|        if highlight.dataSetIndex >= dataSets.count
  370|      0|        {
  371|      0|            return nil
  372|      0|        }
  373|      0|        else
  374|      0|        {
  375|      0|            return dataSets[highlight.dataSetIndex].entryForXValue(highlight.x, closestToY: highlight.y)
  376|      0|        }
  377|      0|    }
  378|       |    
  379|       |    /// **IMPORTANT: This method does calculations at runtime. Use with care in performance critical situations.**
  380|       |    ///
  381|       |    /// - Parameters:
  382|       |    ///   - label:
  383|       |    ///   - ignorecase:
  384|       |    /// - Returns: The DataSet Object with the given label. Sensitive or not.
  385|       |    @objc open func getDataSetByLabel(_ label: String, ignorecase: Bool) -> IChartDataSet?
  386|      0|    {
  387|      0|        let index = getDataSetIndexByLabel(label, ignorecase: ignorecase)
  388|      0|        
  389|      0|        if index < 0 || index >= _dataSets.count
  390|      0|        {
  391|      0|            return nil
  392|      0|        }
  393|      0|        else
  394|      0|        {
  395|      0|            return _dataSets[index]
  396|      0|        }
  397|      0|    }
  398|       |    
  399|       |    @objc open func getDataSetByIndex(_ index: Int) -> IChartDataSet!
  400|      0|    {
  401|      0|        if index < 0 || index >= _dataSets.count
  402|      0|        {
  403|      0|            return nil
  404|      0|        }
  405|      0|        
  406|      0|        return _dataSets[index]
  407|      0|    }
  408|       |    
  409|       |    @objc open func addDataSet(_ dataSet: IChartDataSet!)
  410|      0|    {
  411|      0|        calcMinMax(dataSet: dataSet)
  412|      0|        
  413|      0|        _dataSets.append(dataSet)
  414|      0|    }
  415|       |    
  416|       |    /// Removes the given DataSet from this data object.
  417|       |    /// Also recalculates all minimum and maximum values.
  418|       |    ///
  419|       |    /// - Returns: `true` if a DataSet was removed, `false` ifno DataSet could be removed.
  420|       |    @objc @discardableResult open func removeDataSet(_ dataSet: IChartDataSet) -> Bool
  421|      0|    {
  422|      0|        guard let i = _dataSets.firstIndex(where: { $0 === dataSet }) else { return false }
  423|      0|        return removeDataSetByIndex(i)
  424|      0|    }
  425|       |    
  426|       |    /// Removes the DataSet at the given index in the DataSet array from the data object. 
  427|       |    /// Also recalculates all minimum and maximum values. 
  428|       |    ///
  429|       |    /// - Returns: `true` if a DataSet was removed, `false` ifno DataSet could be removed.
  430|       |    @objc @discardableResult open func removeDataSetByIndex(_ index: Int) -> Bool
  431|      0|    {
  432|      0|        if index >= _dataSets.count || index < 0
  433|      0|        {
  434|      0|            return false
  435|      0|        }
  436|      0|        
  437|      0|        _dataSets.remove(at: index)
  438|      0|        
  439|      0|        calcMinMax()
  440|      0|        
  441|      0|        return true
  442|      0|    }
  443|       |    
  444|       |    /// Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
  445|       |    @objc open func addEntry(_ e: ChartDataEntry, dataSetIndex: Int)
  446|      0|    {
  447|      0|        if _dataSets.count > dataSetIndex && dataSetIndex >= 0
  448|      0|        {
  449|      0|            let set = _dataSets[dataSetIndex]
  450|      0|            
  451|      0|            if !set.addEntry(e) { return }
  452|      0|            
  453|      0|            calcMinMax(entry: e, axis: set.axisDependency)
  454|      0|        }
  455|      0|        else
  456|      0|        {
  457|      0|            print("ChartData.addEntry() - Cannot add Entry because dataSetIndex too high or too low.", terminator: "\n")
  458|      0|        }
  459|      0|    }
  460|       |    
  461|       |    /// Removes the given Entry object from the DataSet at the specified index.
  462|       |    @objc @discardableResult open func removeEntry(_ entry: ChartDataEntry, dataSetIndex: Int) -> Bool
  463|      0|    {
  464|      0|        // entry outofbounds
  465|      0|        if dataSetIndex >= _dataSets.count
  466|      0|        {
  467|      0|            return false
  468|      0|        }
  469|      0|        
  470|      0|        // remove the entry from the dataset
  471|      0|        let removed = _dataSets[dataSetIndex].removeEntry(entry)
  472|      0|        
  473|      0|        if removed
  474|      0|        {
  475|      0|            calcMinMax()
  476|      0|        }
  477|      0|        
  478|      0|        return removed
  479|      0|    }
  480|       |    
  481|       |    /// Removes the Entry object closest to the given xIndex from the ChartDataSet at the
  482|       |    /// specified index. 
  483|       |    ///
  484|       |    /// - Returns: `true` if an entry was removed, `false` ifno Entry was found that meets the specified requirements.
  485|       |    @objc @discardableResult open func removeEntry(xValue: Double, dataSetIndex: Int) -> Bool
  486|      0|    {
  487|      0|        if dataSetIndex >= _dataSets.count
  488|      0|        {
  489|      0|            return false
  490|      0|        }
  491|      0|        
  492|      0|        if let entry = _dataSets[dataSetIndex].entryForXValue(xValue, closestToY: Double.nan)
  493|      0|        {
  494|      0|            return removeEntry(entry, dataSetIndex: dataSetIndex)
  495|      0|        }
  496|      0|        
  497|      0|        return false
  498|      0|    }
  499|       |    
  500|       |    /// - Returns: The DataSet that contains the provided Entry, or null, if no DataSet contains this entry.
  501|       |    @objc open func getDataSetForEntry(_ e: ChartDataEntry) -> IChartDataSet?
  502|      0|    {
  503|      0|        return _dataSets.first { $0.entryForXValue(e.x, closestToY: e.y) === e }
  504|      0|    }
  505|       |
  506|       |    /// - Returns: The index of the provided DataSet in the DataSet array of this data object, or -1 if it does not exist.
  507|       |    @objc open func indexOfDataSet(_ dataSet: IChartDataSet) -> Int
  508|      0|    {
  509|      0|        // TODO: Return nil instead of -1
  510|      0|        return _dataSets.firstIndex { $0 === dataSet } ?? -1
  511|      0|    }
  512|       |    
  513|       |    /// - Returns: The first DataSet from the datasets-array that has it's dependency on the left axis. Returns null if no DataSet with left dependency could be found.
  514|       |    @objc open func getFirstLeft(dataSets: [IChartDataSet]) -> IChartDataSet?
  515|      0|    {
  516|      0|        return dataSets.first { $0.axisDependency == .left }
  517|      0|    }
  518|       |    
  519|       |    /// - Returns: The first DataSet from the datasets-array that has it's dependency on the right axis. Returns null if no DataSet with right dependency could be found.
  520|       |    @objc open func getFirstRight(dataSets: [IChartDataSet]) -> IChartDataSet?
  521|      0|    {
  522|      0|        return dataSets.first { $0.axisDependency == .right }
  523|      0|    }
  524|       |    
  525|       |    /// - Returns: All colors used across all DataSet objects this object represents.
  526|       |    @objc open func getColors() -> [NSUIColor]?
  527|      0|    {
  528|      0|        // TODO: Don't return nil
  529|      0|        return _dataSets.flatMap { $0.colors }
  530|      0|    }
  531|       |    
  532|       |    /// Sets a custom IValueFormatter for all DataSets this data object contains.
  533|       |    @objc open func setValueFormatter(_ formatter: IValueFormatter)
  534|      0|    {
  535|      0|        dataSets.forEach { $0.valueFormatter = formatter }
  536|      0|    }
  537|       |    
  538|       |    /// Sets the color of the value-text (color in which the value-labels are drawn) for all DataSets this data object contains.
  539|       |    @objc open func setValueTextColor(_ color: NSUIColor)
  540|      0|    {
  541|      0|        dataSets.forEach { $0.valueTextColor = color }
  542|      0|    }
  543|       |    
  544|       |    /// Sets the font for all value-labels for all DataSets this data object contains.
  545|       |    @objc open func setValueFont(_ font: NSUIFont)
  546|      0|    {
  547|      0|        dataSets.forEach { $0.valueFont = font }
  548|      0|    }
  549|       |
  550|       |    /// Enables / disables drawing values (value-text) for all DataSets this data object contains.
  551|       |    @objc open func setDrawValues(_ enabled: Bool)
  552|      0|    {
  553|      0|        dataSets.forEach { $0.drawValuesEnabled = enabled }
  554|      0|    }
  555|       |    
  556|       |    /// Enables / disables highlighting values for all DataSets this data object contains.
  557|       |    /// If set to true, this means that values can be highlighted programmatically or by touch gesture.
  558|       |    @objc open var highlightEnabled: Bool
  559|       |    {
  560|      0|        get { return dataSets.allSatisfy { $0.highlightEnabled } }
  561|      0|        set { dataSets.forEach { $0.highlightEnabled = newValue } }
  562|       |    }
  563|       |    
  564|       |    /// if true, value highlightning is enabled
  565|      0|    @objc open var isHighlightEnabled: Bool { return highlightEnabled }
  566|       |    
  567|       |    /// Clears this data object from all DataSets and removes all Entries.
  568|       |    /// Don't forget to invalidate the chart after this.
  569|       |    @objc open func clearValues()
  570|      0|    {
  571|      0|        dataSets.removeAll(keepingCapacity: false)
  572|      0|        notifyDataChanged()
  573|      0|    }
  574|       |    
  575|       |    /// Checks if this data object contains the specified DataSet. 
  576|       |    ///
  577|       |    /// - Returns: `true` if so, `false` ifnot.
  578|       |    @objc open func contains(dataSet: IChartDataSet) -> Bool
  579|      0|    {
  580|      0|        return dataSets.contains { $0 === dataSet }
  581|      0|    }
  582|       |    
  583|       |    /// The total entry count across all DataSet objects this data object contains.
  584|       |    @objc open var entryCount: Int
  585|      0|    {
  586|      0|        return _dataSets.reduce(0) { $0 + $1.entryCount }
  587|      0|    }
  588|       |
  589|       |    /// The DataSet object with the maximum number of entries or null if there are no DataSets.
  590|       |    @objc open var maxEntryCountSet: IChartDataSet?
  591|      0|    {
  592|      0|        return dataSets.max { $0.entryCount < $1.entryCount }
  593|      0|    }
  594|       |
  595|       |    // MARK: - Accessibility
  596|       |
  597|       |    /// When the data entry labels are generated identifiers, set this property to prepend a string before each identifier
  598|       |    ///
  599|       |    /// For example, if a label is "#3", settings this property to "Item" allows it to be spoken as "Item #3"
  600|       |    @objc open var accessibilityEntryLabelPrefix: String?
  601|       |
  602|       |    /// When the data entry value requires a unit, use this property to append the string representation of the unit to the value
  603|       |    ///
  604|       |    /// For example, if a value is "44.1", setting this property to "m" allows it to be spoken as "44.1 m"
  605|       |    @objc open var accessibilityEntryLabelSuffix: String?
  606|       |
  607|       |    /// If the data entry value is a count, set this to true to allow plurals and other grammatical changes
  608|       |    /// **default**: false
  609|       |    @objc open var accessibilityEntryLabelSuffixIsCount: Bool = false
  610|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/ChartDataEntry.swift:
    1|       |//
    2|       |//  ChartDataEntry.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class ChartDataEntry: ChartDataEntryBase, NSCopying
   15|       |{
   16|       |    /// the x value
   17|       |    @objc open var x = 0.0
   18|       |    
   19|       |    public required init()
   20|      0|    {
   21|      0|        super.init()
   22|      0|    }
   23|       |    
   24|       |    /// An Entry represents one single entry in the chart.
   25|       |    ///
   26|       |    /// - Parameters:
   27|       |    ///   - x: the x value
   28|       |    ///   - y: the y value (the actual value of the entry)
   29|       |    @objc public init(x: Double, y: Double)
   30|      0|    {
   31|      0|        super.init(y: y)
   32|      0|        self.x = x
   33|      0|    }
   34|       |    
   35|       |    /// An Entry represents one single entry in the chart.
   36|       |    ///
   37|       |    /// - Parameters:
   38|       |    ///   - x: the x value
   39|       |    ///   - y: the y value (the actual value of the entry)
   40|       |    ///   - data: Space for additional data this Entry represents.
   41|       |    
   42|       |    @objc public convenience init(x: Double, y: Double, data: Any?)
   43|      0|    {
   44|      0|        self.init(x: x, y: y)
   45|      0|        self.data = data
   46|      0|    }
   47|       |    
   48|       |    /// An Entry represents one single entry in the chart.
   49|       |    ///
   50|       |    /// - Parameters:
   51|       |    ///   - x: the x value
   52|       |    ///   - y: the y value (the actual value of the entry)
   53|       |    ///   - icon: icon image
   54|       |    
   55|       |    @objc public convenience init(x: Double, y: Double, icon: NSUIImage?)
   56|      0|    {
   57|      0|        self.init(x: x, y: y)
   58|      0|        self.icon = icon
   59|      0|    }
   60|       |    
   61|       |    /// An Entry represents one single entry in the chart.
   62|       |    ///
   63|       |    /// - Parameters:
   64|       |    ///   - x: the x value
   65|       |    ///   - y: the y value (the actual value of the entry)
   66|       |    ///   - icon: icon image
   67|       |    ///   - data: Space for additional data this Entry represents.
   68|       |    
   69|       |    @objc public convenience init(x: Double, y: Double, icon: NSUIImage?, data: Any?)
   70|      0|    {
   71|      0|        self.init(x: x, y: y)
   72|      0|        self.icon = icon
   73|      0|        self.data = data
   74|      0|    }
   75|       |        
   76|       |    // MARK: NSObject
   77|       |    
   78|       |    open override var description: String
   79|      0|    {
   80|      0|        return "ChartDataEntry, x: \(x), y \(y)"
   81|      0|    }
   82|       |    
   83|       |    // MARK: NSCopying
   84|       |    
   85|       |    open func copy(with zone: NSZone? = nil) -> Any
   86|      0|    {
   87|      0|        let copy = type(of: self).init()
   88|      0|        
   89|      0|        copy.x = x
   90|      0|        copy.y = y
   91|      0|        copy.data = data
   92|      0|        
   93|      0|        return copy
   94|      0|    }
   95|       |}
   96|       |
   97|       |// MARK: Equatable
   98|       |extension ChartDataEntry/*: Equatable*/ {
   99|      0|    open override func isEqual(_ object: Any?) -> Bool {
  100|      0|        guard let object = object as? ChartDataEntry else { return false }
  101|      0|
  102|      0|        if self === object
  103|      0|        {
  104|      0|            return true
  105|      0|        }
  106|      0|
  107|      0|        return y == object.y
  108|      0|            && x == object.x
  109|      0|    }
  110|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/ChartDataEntryBase.swift:
    1|       |//
    2|       |//  ChartDataEntryBase.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class ChartDataEntryBase: NSObject
   15|       |{
   16|       |    /// the y value
   17|       |    @objc open var y = 0.0
   18|       |    
   19|       |    /// optional spot for additional data this Entry represents
   20|       |    @objc open var data: Any?
   21|       |    
   22|       |    /// optional icon image
   23|       |    @objc open var icon: NSUIImage?
   24|       |    
   25|       |    public override required init()
   26|      0|    {
   27|      0|        super.init()
   28|      0|    }
   29|       |    
   30|       |    /// An Entry represents one single entry in the chart.
   31|       |    ///
   32|       |    /// - Parameters:
   33|       |    ///   - y: the y value (the actual value of the entry)
   34|       |    @objc public init(y: Double)
   35|      0|    {
   36|      0|        super.init()
   37|      0|        
   38|      0|        self.y = y
   39|      0|    }
   40|       |    
   41|       |    /// - Parameters:
   42|       |    ///   - y: the y value (the actual value of the entry)
   43|       |    ///   - data: Space for additional data this Entry represents.
   44|       |    
   45|       |    @objc public convenience init(y: Double, data: Any?)
   46|      0|    {
   47|      0|        self.init(y: y)
   48|      0|        
   49|      0|        self.data = data
   50|      0|    }
   51|       |    
   52|       |    /// - Parameters:
   53|       |    ///   - y: the y value (the actual value of the entry)
   54|       |    ///   - icon: icon image
   55|       |    
   56|       |    @objc public convenience init(y: Double, icon: NSUIImage?)
   57|      0|    {
   58|      0|        self.init(y: y)
   59|      0|
   60|      0|        self.icon = icon
   61|      0|    }
   62|       |    
   63|       |    /// - Parameters:
   64|       |    ///   - y: the y value (the actual value of the entry)
   65|       |    ///   - icon: icon image
   66|       |    ///   - data: Space for additional data this Entry represents.
   67|       |    
   68|       |    @objc public convenience init(y: Double, icon: NSUIImage?, data: Any?)
   69|      0|    {
   70|      0|        self.init(y: y)
   71|      0|
   72|      0|        self.icon = icon
   73|      0|        self.data = data
   74|      0|    }
   75|       |
   76|       |    // MARK: NSObject
   77|       |    
   78|       |    open override var description: String
   79|      0|    {
   80|      0|        return "ChartDataEntryBase, y \(y)"
   81|      0|    }
   82|       |}
   83|       |
   84|       |// MARK: Equatable
   85|       |extension ChartDataEntryBase/*: Equatable*/ {
   86|      0|    open override func isEqual(_ object: Any?) -> Bool {
   87|      0|        guard let object = object as? ChartDataEntryBase else { return false }
   88|      0|
   89|      0|        if self === object
   90|      0|        {
   91|      0|            return true
   92|      0|        }
   93|      0|
   94|      0|        return y == object.y
   95|      0|    }
   96|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/ChartDataSet.swift:
    1|       |//
    2|       |//  ChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |/// Determines how to round DataSet index values for `ChartDataSet.entryIndex(x, rounding)` when an exact x-value is not found.
   15|       |@objc
   16|       |public enum ChartDataSetRounding: Int
   17|       |{
   18|       |    case up = 0
   19|       |    case down = 1
   20|       |    case closest = 2
   21|       |}
   22|       |
   23|       |/// The DataSet class represents one group or type of entries (Entry) in the Chart that belong together.
   24|       |/// It is designed to logically separate different groups of values inside the Chart (e.g. the values for a specific line in the LineChart, or the values of a specific group of bars in the BarChart).
   25|       |open class ChartDataSet: ChartBaseDataSet
   26|       |{
   27|       |    public required init()
   28|      0|    {
   29|      0|        entries = []
   30|      0|
   31|      0|        super.init()
   32|      0|    }
   33|       |    
   34|       |    public override convenience init(label: String?)
   35|      0|    {
   36|      0|        self.init(entries: nil, label: label)
   37|      0|    }
   38|       |    
   39|       |    @objc public init(entries: [ChartDataEntry]?, label: String?)
   40|      0|    {
   41|      0|        self.entries = entries ?? []
   42|      0|
   43|      0|        super.init(label: label)
   44|      0|
   45|      0|        self.calcMinMax()
   46|      0|    }
   47|       |    
   48|       |    @objc public convenience init(entries: [ChartDataEntry]?)
   49|      0|    {
   50|      0|        self.init(entries: entries, label: "DataSet")
   51|      0|    }
   52|       |    
   53|       |    // MARK: - Data functions and accessors
   54|       |
   55|       |    /// - Note: Calls `notifyDataSetChanged()` after setting a new value.
   56|       |    /// - Returns: The array of y-values that this DataSet represents.
   57|       |    /// the entries that this dataset represents / holds together
   58|       |    @available(*, unavailable, renamed: "entries")
   59|       |    @objc
   60|      0|    open var values: [ChartDataEntry] { return entries }
   61|       |
   62|       |    @objc
   63|       |    open private(set) var entries: [ChartDataEntry]
   64|       |
   65|       |    /// Used to replace all entries of a data set while retaining styling properties.
   66|       |    /// This is a separate method from a setter on `entries` to encourage usage
   67|       |    /// of `Collection` conformances.
   68|       |    ///
   69|       |    /// - Parameter entries: new entries to replace existing entries in the dataset
   70|       |    @objc
   71|      0|    public func replaceEntries(_ entries: [ChartDataEntry]) {
   72|      0|        self.entries = entries
   73|      0|        notifyDataSetChanged()
   74|      0|    }
   75|       |
   76|       |    /// maximum y-value in the value array
   77|      0|    internal var _yMax: Double = -Double.greatestFiniteMagnitude
   78|       |    
   79|       |    /// minimum y-value in the value array
   80|      0|    internal var _yMin: Double = Double.greatestFiniteMagnitude
   81|       |    
   82|       |    /// maximum x-value in the value array
   83|      0|    internal var _xMax: Double = -Double.greatestFiniteMagnitude
   84|       |    
   85|       |    /// minimum x-value in the value array
   86|      0|    internal var _xMin: Double = Double.greatestFiniteMagnitude
   87|       |    
   88|       |    open override func calcMinMax()
   89|      0|    {
   90|      0|        _yMax = -Double.greatestFiniteMagnitude
   91|      0|        _yMin = Double.greatestFiniteMagnitude
   92|      0|        _xMax = -Double.greatestFiniteMagnitude
   93|      0|        _xMin = Double.greatestFiniteMagnitude
   94|      0|
   95|      0|        guard !isEmpty else { return }
   96|      0|
   97|      0|        forEach(calcMinMax)
   98|      0|    }
   99|       |    
  100|       |    open override func calcMinMaxY(fromX: Double, toX: Double)
  101|      0|    {
  102|      0|        _yMax = -Double.greatestFiniteMagnitude
  103|      0|        _yMin = Double.greatestFiniteMagnitude
  104|      0|
  105|      0|        guard !isEmpty else { return }
  106|      0|        
  107|      0|        let indexFrom = entryIndex(x: fromX, closestToY: Double.nan, rounding: .down)
  108|      0|        let indexTo = entryIndex(x: toX, closestToY: Double.nan, rounding: .up)
  109|      0|        
  110|      0|        guard !(indexTo < indexFrom) else { return }
  111|      0|        // only recalculate y
  112|      0|        self[indexFrom...indexTo].forEach(calcMinMaxY)
  113|      0|    }
  114|       |    
  115|       |    @objc open func calcMinMaxX(entry e: ChartDataEntry)
  116|      0|    {
  117|      0|        if e.x < _xMin
  118|      0|        {
  119|      0|            _xMin = e.x
  120|      0|        }
  121|      0|        if e.x > _xMax
  122|      0|        {
  123|      0|            _xMax = e.x
  124|      0|        }
  125|      0|    }
  126|       |    
  127|       |    @objc open func calcMinMaxY(entry e: ChartDataEntry)
  128|      0|    {
  129|      0|        if e.y < _yMin
  130|      0|        {
  131|      0|            _yMin = e.y
  132|      0|        }
  133|      0|        if e.y > _yMax
  134|      0|        {
  135|      0|            _yMax = e.y
  136|      0|        }
  137|      0|    }
  138|       |    
  139|       |    /// Updates the min and max x and y value of this DataSet based on the given Entry.
  140|       |    ///
  141|       |    /// - Parameters:
  142|       |    ///   - e:
  143|       |    internal func calcMinMax(entry e: ChartDataEntry)
  144|      0|    {
  145|      0|        calcMinMaxX(entry: e)
  146|      0|        calcMinMaxY(entry: e)
  147|      0|    }
  148|       |    
  149|       |    /// The minimum y-value this DataSet holds
  150|      0|    open override var yMin: Double { return _yMin }
  151|       |    
  152|       |    /// The maximum y-value this DataSet holds
  153|      0|    open override var yMax: Double { return _yMax }
  154|       |    
  155|       |    /// The minimum x-value this DataSet holds
  156|      0|    open override var xMin: Double { return _xMin }
  157|       |    
  158|       |    /// The maximum x-value this DataSet holds
  159|      0|    open override var xMax: Double { return _xMax }
  160|       |    
  161|       |    /// The number of y-values this DataSet represents
  162|       |    @available(*, deprecated, message: "Use `count` instead")
  163|      0|    open override var entryCount: Int { return count }
  164|       |    
  165|       |    /// - Throws: out of bounds
  166|       |    /// if `i` is out of bounds, it may throw an out-of-bounds exception
  167|       |    /// - Returns: The entry object found at the given index (not x-value!)
  168|       |    @available(*, deprecated, message: "Use `subscript(index:)` instead.")
  169|       |    open override func entryForIndex(_ i: Int) -> ChartDataEntry?
  170|      0|    {
  171|      0|        guard i >= startIndex, i < endIndex else {
  172|      0|            return nil
  173|      0|        }
  174|      0|        return self[i]
  175|      0|    }
  176|       |    
  177|       |    /// - Parameters:
  178|       |    ///   - xValue: the x-value
  179|       |    ///   - closestToY: If there are multiple y-values for the specified x-value,
  180|       |    ///   - rounding: determine whether to round up/down/closest if there is no Entry matching the provided x-value
  181|       |    /// - Returns: The first Entry object found at the given x-value with binary search.
  182|       |    /// If the no Entry at the specified x-value is found, this method returns the Entry at the closest x-value according to the rounding.
  183|       |    /// nil if no Entry object at that x-value.
  184|       |    open override func entryForXValue(
  185|       |        _ xValue: Double,
  186|       |        closestToY yValue: Double,
  187|       |        rounding: ChartDataSetRounding) -> ChartDataEntry?
  188|      0|    {
  189|      0|        let index = entryIndex(x: xValue, closestToY: yValue, rounding: rounding)
  190|      0|        if index > -1
  191|      0|        {
  192|      0|            return self[index]
  193|      0|        }
  194|      0|        return nil
  195|      0|    }
  196|       |    
  197|       |    /// - Parameters:
  198|       |    ///   - xValue: the x-value
  199|       |    ///   - closestToY: If there are multiple y-values for the specified x-value,
  200|       |    /// - Returns: The first Entry object found at the given x-value with binary search.
  201|       |    /// If the no Entry at the specified x-value is found, this method returns the Entry at the closest x-value.
  202|       |    /// nil if no Entry object at that x-value.
  203|       |    open override func entryForXValue(
  204|       |        _ xValue: Double,
  205|       |        closestToY yValue: Double) -> ChartDataEntry?
  206|      0|    {
  207|      0|        return entryForXValue(xValue, closestToY: yValue, rounding: .closest)
  208|      0|    }
  209|       |    
  210|       |    /// - Returns: All Entry objects found at the given xIndex with binary search.
  211|       |    /// An empty array if no Entry object at that index.
  212|       |    open override func entriesForXValue(_ xValue: Double) -> [ChartDataEntry]
  213|      0|    {
  214|      0|        var entries = [ChartDataEntry]()
  215|      0|        
  216|      0|        var low = startIndex
  217|      0|        var high = endIndex - 1
  218|      0|        
  219|      0|        while low <= high
  220|      0|        {
  221|      0|            var m = (high + low) / 2
  222|      0|            var entry = self[m]
  223|      0|            
  224|      0|            // if we have a match
  225|      0|            if xValue == entry.x
  226|      0|            {
  227|      0|                while m > 0 && self[m - 1].x == xValue
  228|      0|                {
  229|      0|                    m -= 1
  230|      0|                }
  231|      0|                
  232|      0|                high = endIndex
  233|      0|                
  234|      0|                // loop over all "equal" entries
  235|      0|                while m < high
  236|      0|                {
  237|      0|                    entry = self[m]
  238|      0|                    if entry.x == xValue
  239|      0|                    {
  240|      0|                        entries.append(entry)
  241|      0|                    }
  242|      0|                    else
  243|      0|                    {
  244|      0|                        break
  245|      0|                    }
  246|      0|                    
  247|      0|                    m += 1
  248|      0|                }
  249|      0|                
  250|      0|                break
  251|      0|            }
  252|      0|            else
  253|      0|            {
  254|      0|                if xValue > entry.x
  255|      0|                {
  256|      0|                    low = m + 1
  257|      0|                }
  258|      0|                else
  259|      0|                {
  260|      0|                    high = m - 1
  261|      0|                }
  262|      0|            }
  263|      0|        }
  264|      0|        
  265|      0|        return entries
  266|      0|    }
  267|       |    
  268|       |    /// - Parameters:
  269|       |    ///   - xValue: x-value of the entry to search for
  270|       |    ///   - closestToY: If there are multiple y-values for the specified x-value,
  271|       |    ///   - rounding: Rounding method if exact value was not found
  272|       |    /// - Returns: The array-index of the specified entry.
  273|       |    /// If the no Entry at the specified x-value is found, this method returns the index of the Entry at the closest x-value according to the rounding.
  274|       |    open override func entryIndex(
  275|       |        x xValue: Double,
  276|       |        closestToY yValue: Double,
  277|       |        rounding: ChartDataSetRounding) -> Int
  278|      0|    {
  279|      0|        var low = startIndex
  280|      0|        var high = endIndex - 1
  281|      0|        var closest = high
  282|      0|        
  283|      0|        while low < high
  284|      0|        {
  285|      0|            let m = (low + high) / 2
  286|      0|            
  287|      0|            let d1 = self[m].x - xValue
  288|      0|            let d2 = self[m + 1].x - xValue
  289|      0|            let ad1 = abs(d1), ad2 = abs(d2)
  290|      0|            
  291|      0|            if ad2 < ad1
  292|      0|            {
  293|      0|                // [m + 1] is closer to xValue
  294|      0|                // Search in an higher place
  295|      0|                low = m + 1
  296|      0|            }
  297|      0|            else if ad1 < ad2
  298|      0|            {
  299|      0|                // [m] is closer to xValue
  300|      0|                // Search in a lower place
  301|      0|                high = m
  302|      0|            }
  303|      0|            else
  304|      0|            {
  305|      0|                // We have multiple sequential x-value with same distance
  306|      0|                
  307|      0|                if d1 >= 0.0
  308|      0|                {
  309|      0|                    // Search in a lower place
  310|      0|                    high = m
  311|      0|                }
  312|      0|                else if d1 < 0.0
  313|      0|                {
  314|      0|                    // Search in an higher place
  315|      0|                    low = m + 1
  316|      0|                }
  317|      0|            }
  318|      0|            
  319|      0|            closest = high
  320|      0|        }
  321|      0|        
  322|      0|        if closest != -1
  323|      0|        {
  324|      0|            let closestXValue = self[closest].x
  325|      0|            
  326|      0|            if rounding == .up
  327|      0|            {
  328|      0|                // If rounding up, and found x-value is lower than specified x, and we can go upper...
  329|      0|                if closestXValue < xValue && closest < endIndex - 1
  330|      0|                {
  331|      0|                    closest += 1
  332|      0|                }
  333|      0|            }
  334|      0|            else if rounding == .down
  335|      0|            {
  336|      0|                // If rounding down, and found x-value is upper than specified x, and we can go lower...
  337|      0|                if closestXValue > xValue && closest > 0
  338|      0|                {
  339|      0|                    closest -= 1
  340|      0|                }
  341|      0|            }
  342|      0|            
  343|      0|            // Search by closest to y-value
  344|      0|            if !yValue.isNaN
  345|      0|            {
  346|      0|                while closest > 0 && self[closest - 1].x == closestXValue
  347|      0|                {
  348|      0|                    closest -= 1
  349|      0|                }
  350|      0|                
  351|      0|                var closestYValue = self[closest].y
  352|      0|                var closestYIndex = closest
  353|      0|                
  354|      0|                while true
  355|      0|                {
  356|      0|                    closest += 1
  357|      0|                    if closest >= endIndex { break }
  358|      0|                    
  359|      0|                    let value = self[closest]
  360|      0|                    
  361|      0|                    if value.x != closestXValue { break }
  362|      0|                    if abs(value.y - yValue) <= abs(closestYValue - yValue)
  363|      0|                    {
  364|      0|                        closestYValue = yValue
  365|      0|                        closestYIndex = closest
  366|      0|                    }
  367|      0|                }
  368|      0|                
  369|      0|                closest = closestYIndex
  370|      0|            }
  371|      0|        }
  372|      0|        
  373|      0|        return closest
  374|      0|    }
  375|       |    
  376|       |    /// - Parameters:
  377|       |    ///   - e: the entry to search for
  378|       |    /// - Returns: The array-index of the specified entry
  379|       |    @available(*, deprecated, message: "Use `firstIndex(of:)` or `lastIndex(of:)`")
  380|       |    open override func entryIndex(entry e: ChartDataEntry) -> Int
  381|      0|    {
  382|      0|        return firstIndex(of: e) ?? -1
  383|      0|    }
  384|       |    
  385|       |    /// Adds an Entry to the DataSet dynamically.
  386|       |    /// Entries are added to the end of the list.
  387|       |    /// This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
  388|       |    ///
  389|       |    /// - Parameters:
  390|       |    ///   - e: the entry to add
  391|       |    /// - Returns: True
  392|       |    @available(*, deprecated, message: "Use `append(_:)` instead")
  393|       |    open override func addEntry(_ e: ChartDataEntry) -> Bool
  394|      0|    {
  395|      0|        append(e)
  396|      0|        return true
  397|      0|    }
  398|       |    
  399|       |    /// Adds an Entry to the DataSet dynamically.
  400|       |    /// Entries are added to their appropriate index respective to it's x-index.
  401|       |    /// This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
  402|       |    ///
  403|       |    /// - Parameters:
  404|       |    ///   - e: the entry to add
  405|       |    /// - Returns: True
  406|       |    open override func addEntryOrdered(_ e: ChartDataEntry) -> Bool
  407|      0|    {
  408|      0|        calcMinMax(entry: e)
  409|      0|        
  410|      0|        if let last = last, last.x > e.x
  411|      0|        {
  412|      0|            var closestIndex = entryIndex(x: e.x, closestToY: e.y, rounding: .up)
  413|      0|            while self[closestIndex].x < e.x
  414|      0|            {
  415|      0|                closestIndex += 1
  416|      0|            }
  417|      0|            entries.insert(e, at: closestIndex)
  418|      0|        }
  419|      0|        else
  420|      0|        {
  421|      0|            append(e)
  422|      0|        }
  423|      0|        
  424|      0|        return true
  425|      0|    }
  426|       |    
  427|       |    @available(*, renamed: "remove(_:)")
  428|       |    open override func removeEntry(_ entry: ChartDataEntry) -> Bool
  429|      0|    {
  430|      0|        return remove(entry)
  431|      0|    }
  432|       |
  433|       |    /// Removes an Entry from the DataSet dynamically.
  434|       |    /// This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
  435|       |    ///
  436|       |    /// - Parameters:
  437|       |    ///   - entry: the entry to remove
  438|       |    /// - Returns: `true` if the entry was removed successfully, else if the entry does not exist
  439|       |    open func remove(_ entry: ChartDataEntry) -> Bool
  440|      0|    {
  441|      0|        guard let index = firstIndex(of: entry) else { return false }
  442|      0|        _ = remove(at: index)
  443|      0|        return true
  444|      0|    }
  445|       |
  446|       |    /// Removes the first Entry (at index 0) of this DataSet from the entries array.
  447|       |    ///
  448|       |    /// - Returns: `true` if successful, `false` if not.
  449|       |    @available(*, deprecated, message: "Use `func removeFirst() -> ChartDataEntry` instead.")
  450|       |    open override func removeFirst() -> Bool
  451|      0|    {
  452|      0|        let entry: ChartDataEntry? = isEmpty ? nil : removeFirst()
  453|      0|        return entry != nil
  454|      0|    }
  455|       |    
  456|       |    /// Removes the last Entry (at index size-1) of this DataSet from the entries array.
  457|       |    ///
  458|       |    /// - Returns: `true` if successful, `false` if not.
  459|       |    @available(*, deprecated, message: "Use `func removeLast() -> ChartDataEntry` instead.")
  460|       |    open override func removeLast() -> Bool
  461|      0|    {
  462|      0|        let entry: ChartDataEntry? = isEmpty ? nil : removeLast()
  463|      0|        return entry != nil
  464|      0|    }
  465|       |
  466|       |    /// Removes all values from this DataSet and recalculates min and max value.
  467|       |    @available(*, deprecated, message: "Use `removeAll(keepingCapacity:)` instead.")
  468|       |    open override func clear()
  469|      0|    {
  470|      0|        removeAll(keepingCapacity: true)
  471|      0|    }
  472|       |    
  473|       |    // MARK: - Data functions and accessors
  474|       |
  475|       |    // MARK: - NSCopying
  476|       |    
  477|       |    open override func copy(with zone: NSZone? = nil) -> Any
  478|      0|    {
  479|      0|        let copy = super.copy(with: zone) as! ChartDataSet
  480|      0|        
  481|      0|        copy.entries = entries
  482|      0|        copy._yMax = _yMax
  483|      0|        copy._yMin = _yMin
  484|      0|        copy._xMax = _xMax
  485|      0|        copy._xMin = _xMin
  486|      0|
  487|      0|        return copy
  488|      0|    }
  489|       |}
  490|       |
  491|       |// MARK: MutableCollection
  492|       |extension ChartDataSet: MutableCollection {
  493|       |    public typealias Index = Int
  494|       |    public typealias Element = ChartDataEntry
  495|       |
  496|      0|    public var startIndex: Index {
  497|      0|        return entries.startIndex
  498|      0|    }
  499|       |
  500|      0|    public var endIndex: Index {
  501|      0|        return entries.endIndex
  502|      0|    }
  503|       |
  504|      0|    public func index(after: Index) -> Index {
  505|      0|        return entries.index(after: after)
  506|      0|    }
  507|       |
  508|       |    @objc
  509|       |    public subscript(position: Index) -> Element {
  510|      0|        get {
  511|      0|            // This is intentionally not a safe subscript to mirror
  512|      0|            // the behaviour of the built in Swift Collection Types
  513|      0|            return entries[position]
  514|      0|        }
  515|      0|        set {
  516|      0|            calcMinMax(entry: newValue)
  517|      0|            entries[position] = newValue
  518|      0|        }
  519|       |    }
  520|       |}
  521|       |
  522|       |// MARK: RandomAccessCollection
  523|       |extension ChartDataSet: RandomAccessCollection {
  524|      0|    public func index(before: Index) -> Index {
  525|      0|        return entries.index(before: before)
  526|      0|    }
  527|       |}
  528|       |
  529|       |// MARK: RangeReplaceableCollection
  530|       |extension ChartDataSet: RangeReplaceableCollection {
  531|      0|    public func append(_ newElement: Element) {
  532|      0|        calcMinMax(entry: newElement)
  533|      0|        entries.append(newElement)
  534|      0|    }
  535|       |
  536|      0|    public func remove(at position: Index) -> Element {
  537|      0|        let element = entries.remove(at: position)
  538|      0|        notifyDataSetChanged()
  539|      0|        return element
  540|      0|    }
  541|       |
  542|      0|    public func removeFirst() -> Element {
  543|      0|        let element = entries.removeFirst()
  544|      0|        notifyDataSetChanged()
  545|      0|        return element
  546|      0|    }
  547|       |
  548|      0|    public func removeFirst(_ n: Int) {
  549|      0|        entries.removeFirst(n)
  550|      0|        notifyDataSetChanged()
  551|      0|    }
  552|       |
  553|      0|    public func removeLast() -> Element {
  554|      0|        let element = entries.removeLast()
  555|      0|        notifyDataSetChanged()
  556|      0|        return element
  557|      0|    }
  558|       |
  559|      0|    public func removeLast(_ n: Int) {
  560|      0|        entries.removeLast(n)
  561|      0|        notifyDataSetChanged()
  562|      0|    }
  563|       |
  564|      0|    public func removeSubrange<R>(_ bounds: R) where R : RangeExpression, Index == R.Bound {
  565|      0|        entries.removeSubrange(bounds)
  566|      0|        notifyDataSetChanged()
  567|      0|    }
  568|       |
  569|       |    @objc
  570|      0|    public func removeAll(keepingCapacity keepCapacity: Bool) {
  571|      0|        entries.removeAll(keepingCapacity: keepCapacity)
  572|      0|        notifyDataSetChanged()
  573|      0|    }
  574|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/CombinedChartData.swift:
    1|       |//
    2|       |//  CombinedChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class CombinedChartData: BarLineScatterCandleBubbleChartData
   15|       |{
   16|       |    private var _lineData: LineChartData!
   17|       |    private var _barData: BarChartData!
   18|       |    private var _scatterData: ScatterChartData!
   19|       |    private var _candleData: CandleChartData!
   20|       |    private var _bubbleData: BubbleChartData!
   21|       |    
   22|       |    public override init()
   23|      0|    {
   24|      0|        super.init()
   25|      0|    }
   26|       |    
   27|       |    public override init(dataSets: [IChartDataSet]?)
   28|      0|    {
   29|      0|        super.init(dataSets: dataSets)
   30|      0|    }
   31|       |    
   32|       |    @objc open var lineData: LineChartData!
   33|       |    {
   34|       |        get
   35|      0|        {
   36|      0|            return _lineData
   37|      0|        }
   38|       |        set
   39|      0|        {
   40|      0|            _lineData = newValue
   41|      0|            notifyDataChanged()
   42|      0|        }
   43|       |    }
   44|       |    
   45|       |    @objc open var barData: BarChartData!
   46|       |    {
   47|       |        get
   48|      0|        {
   49|      0|            return _barData
   50|      0|        }
   51|       |        set
   52|      0|        {
   53|      0|            _barData = newValue
   54|      0|            notifyDataChanged()
   55|      0|        }
   56|       |    }
   57|       |    
   58|       |    @objc open var scatterData: ScatterChartData!
   59|       |    {
   60|       |        get
   61|      0|        {
   62|      0|            return _scatterData
   63|      0|        }
   64|       |        set
   65|      0|        {
   66|      0|            _scatterData = newValue
   67|      0|            notifyDataChanged()
   68|      0|        }
   69|       |    }
   70|       |    
   71|       |    @objc open var candleData: CandleChartData!
   72|       |    {
   73|       |        get
   74|      0|        {
   75|      0|            return _candleData
   76|      0|        }
   77|       |        set
   78|      0|        {
   79|      0|            _candleData = newValue
   80|      0|            notifyDataChanged()
   81|      0|        }
   82|       |    }
   83|       |    
   84|       |    @objc open var bubbleData: BubbleChartData!
   85|       |    {
   86|       |        get
   87|      0|        {
   88|      0|            return _bubbleData
   89|      0|        }
   90|       |        set
   91|      0|        {
   92|      0|            _bubbleData = newValue
   93|      0|            notifyDataChanged()
   94|      0|        }
   95|       |    }
   96|       |    
   97|       |    open override func calcMinMax()
   98|      0|    {
   99|      0|        _dataSets.removeAll()
  100|      0|        
  101|      0|        _yMax = -Double.greatestFiniteMagnitude
  102|      0|        _yMin = Double.greatestFiniteMagnitude
  103|      0|        _xMax = -Double.greatestFiniteMagnitude
  104|      0|        _xMin = Double.greatestFiniteMagnitude
  105|      0|        
  106|      0|        _leftAxisMax = -Double.greatestFiniteMagnitude
  107|      0|        _leftAxisMin = Double.greatestFiniteMagnitude
  108|      0|        _rightAxisMax = -Double.greatestFiniteMagnitude
  109|      0|        _rightAxisMin = Double.greatestFiniteMagnitude
  110|      0|        
  111|      0|        let allData = self.allData
  112|      0|        
  113|      0|        for data in allData
  114|      0|        {
  115|      0|            data.calcMinMax()
  116|      0|            
  117|      0|            let sets = data.dataSets
  118|      0|            _dataSets.append(contentsOf: sets)
  119|      0|            
  120|      0|            if data.yMax > _yMax
  121|      0|            {
  122|      0|                _yMax = data.yMax
  123|      0|            }
  124|      0|            
  125|      0|            if data.yMin < _yMin
  126|      0|            {
  127|      0|                _yMin = data.yMin
  128|      0|            }
  129|      0|            
  130|      0|            if data.xMax > _xMax
  131|      0|            {
  132|      0|                _xMax = data.xMax
  133|      0|            }
  134|      0|            
  135|      0|            if data.xMin < _xMin
  136|      0|            {
  137|      0|                _xMin = data.xMin
  138|      0|            }
  139|      0|
  140|      0|            for dataset in sets
  141|      0|            {
  142|      0|                if dataset.axisDependency == .left
  143|      0|                {
  144|      0|                    if dataset.yMax > _leftAxisMax
  145|      0|                    {
  146|      0|                        _leftAxisMax = dataset.yMax
  147|      0|                    }
  148|      0|                    if dataset.yMin < _leftAxisMin
  149|      0|                    {
  150|      0|                        _leftAxisMin = dataset.yMin
  151|      0|                    }
  152|      0|                }
  153|      0|                else
  154|      0|                {
  155|      0|                    if dataset.yMax > _rightAxisMax
  156|      0|                    {
  157|      0|                        _rightAxisMax = dataset.yMax
  158|      0|                    }
  159|      0|                    if dataset.yMin < _rightAxisMin
  160|      0|                    {
  161|      0|                        _rightAxisMin = dataset.yMin
  162|      0|                    }
  163|      0|                }
  164|      0|            }
  165|      0|        }
  166|      0|    }
  167|       |    
  168|       |    /// All data objects in row: line-bar-scatter-candle-bubble if not null.
  169|       |    @objc open var allData: [ChartData]
  170|      0|    {
  171|      0|        var data = [ChartData]()
  172|      0|        
  173|      0|        if lineData !== nil
  174|      0|        {
  175|      0|            data.append(lineData)
  176|      0|        }
  177|      0|        if barData !== nil
  178|      0|        {
  179|      0|            data.append(barData)
  180|      0|        }
  181|      0|        if scatterData !== nil
  182|      0|        {
  183|      0|            data.append(scatterData)
  184|      0|        }
  185|      0|        if candleData !== nil
  186|      0|        {
  187|      0|            data.append(candleData)
  188|      0|        }
  189|      0|        if bubbleData !== nil
  190|      0|        {
  191|      0|            data.append(bubbleData)
  192|      0|        }
  193|      0|        
  194|      0|        return data
  195|      0|    }
  196|       |    
  197|       |    @objc open func dataByIndex(_ index: Int) -> ChartData
  198|      0|    {
  199|      0|        return allData[index]
  200|      0|    }
  201|       |    
  202|       |    open func dataIndex(_ data: ChartData) -> Int?
  203|      0|    {
  204|      0|        return allData.firstIndex(of: data)
  205|      0|    }
  206|       |    
  207|       |    open override func removeDataSet(_ dataSet: IChartDataSet) -> Bool
  208|      0|    {
  209|      0|        return allData.contains { $0.removeDataSet(dataSet) }
  210|      0|    }
  211|       |    
  212|       |    open override func removeDataSetByIndex(_ index: Int) -> Bool
  213|      0|    {
  214|      0|        print("removeDataSet(index) not supported for CombinedData", terminator: "\n")
  215|      0|        return false
  216|      0|    }
  217|       |    
  218|       |    open override func removeEntry(_ entry: ChartDataEntry, dataSetIndex: Int) -> Bool
  219|      0|    {
  220|      0|        print("removeEntry(entry, dataSetIndex) not supported for CombinedData", terminator: "\n")
  221|      0|        return false
  222|      0|    }
  223|       |    
  224|       |    open override func removeEntry(xValue: Double, dataSetIndex: Int) -> Bool
  225|      0|    {
  226|      0|        print("removeEntry(xValue, dataSetIndex) not supported for CombinedData", terminator: "\n")
  227|      0|        return false
  228|      0|    }
  229|       |    
  230|       |    open override func notifyDataChanged()
  231|      0|    {
  232|      0|        if _lineData !== nil
  233|      0|        {
  234|      0|            _lineData.notifyDataChanged()
  235|      0|        }
  236|      0|        if _barData !== nil
  237|      0|        {
  238|      0|            _barData.notifyDataChanged()
  239|      0|        }
  240|      0|        if _scatterData !== nil
  241|      0|        {
  242|      0|            _scatterData.notifyDataChanged()
  243|      0|        }
  244|      0|        if _candleData !== nil
  245|      0|        {
  246|      0|            _candleData.notifyDataChanged()
  247|      0|        }
  248|      0|        if _bubbleData !== nil
  249|      0|        {
  250|      0|            _bubbleData.notifyDataChanged()
  251|      0|        }
  252|      0|        
  253|      0|        super.notifyDataChanged() // recalculate everything
  254|      0|    }
  255|       |    
  256|       |    /// Get the Entry for a corresponding highlight object
  257|       |    ///
  258|       |    /// - Parameters:
  259|       |    ///   - highlight:
  260|       |    /// - Returns: The entry that is highlighted
  261|       |    open override func entryForHighlight(_ highlight: Highlight) -> ChartDataEntry?
  262|      0|    {
  263|      0|        if highlight.dataIndex >= allData.count
  264|      0|        {
  265|      0|            return nil
  266|      0|        }
  267|      0|        
  268|      0|        let data = dataByIndex(highlight.dataIndex)
  269|      0|        
  270|      0|        if highlight.dataSetIndex >= data.dataSetCount
  271|      0|        {
  272|      0|            return nil
  273|      0|        }
  274|      0|        
  275|      0|        // The value of the highlighted entry could be NaN - if we are not interested in highlighting a specific value.
  276|      0|        let entries = data.getDataSetByIndex(highlight.dataSetIndex).entriesForXValue(highlight.x)
  277|      0|        return entries.first { $0.y == highlight.y || highlight.y.isNaN }
  278|      0|    }
  279|       |    
  280|       |    /// Get dataset for highlight
  281|       |    ///
  282|       |    /// - Parameters:
  283|       |    ///   - highlight: current highlight
  284|       |    /// - Returns: dataset related to highlight
  285|       |    @objc open func getDataSetByHighlight(_ highlight: Highlight) -> IChartDataSet!
  286|      0|    {  
  287|      0|        if highlight.dataIndex >= allData.count
  288|      0|        {
  289|      0|            return nil
  290|      0|        }
  291|      0|        
  292|      0|        let data = dataByIndex(highlight.dataIndex)
  293|      0|        
  294|      0|        if highlight.dataSetIndex >= data.dataSetCount
  295|      0|        {
  296|      0|            return nil
  297|      0|        }
  298|      0|        
  299|      0|        return data.dataSets[highlight.dataSetIndex]
  300|      0|    }
  301|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/LineChartData.swift:
    1|       |//
    2|       |//  LineChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |/// Data object that encapsulates all data associated with a LineChart.
   15|       |open class LineChartData: ChartData
   16|       |{
   17|       |    public override init()
   18|      0|    {
   19|      0|        super.init()
   20|      0|    }
   21|       |    
   22|       |    public override init(dataSets: [IChartDataSet]?)
   23|      0|    {
   24|      0|        super.init(dataSets: dataSets)
   25|      0|    }
   26|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/LineChartDataSet.swift:
    1|       |//
    2|       |//  LineChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class LineChartDataSet: LineRadarChartDataSet, ILineChartDataSet
   17|       |{
   18|       |    @objc(LineChartMode)
   19|       |    public enum Mode: Int
   20|       |    {
   21|       |        case linear
   22|       |        case stepped
   23|       |        case cubicBezier
   24|       |        case horizontalBezier
   25|       |    }
   26|       |    
   27|       |    private func initialize()
   28|      0|    {
   29|      0|        // default color
   30|      0|        circleColors.append(NSUIColor(red: 140.0/255.0, green: 234.0/255.0, blue: 255.0/255.0, alpha: 1.0))
   31|      0|    }
   32|       |    
   33|       |    public required init()
   34|      0|    {
   35|      0|        super.init()
   36|      0|        initialize()
   37|      0|    }
   38|       |    
   39|       |    public override init(entries: [ChartDataEntry]?, label: String?)
   40|      0|    {
   41|      0|        super.init(entries: entries, label: label)
   42|      0|        initialize()
   43|      0|    }
   44|       |    
   45|       |    // MARK: - Data functions and accessors
   46|       |    
   47|       |    // MARK: - Styling functions and accessors
   48|       |    
   49|       |    /// The drawing mode for this line dataset
   50|       |    ///
   51|       |    /// **default**: Linear
   52|      0|    open var mode: Mode = Mode.linear
   53|       |    
   54|      0|    private var _cubicIntensity = CGFloat(0.2)
   55|       |    
   56|       |    /// Intensity for cubic lines (min = 0.05, max = 1)
   57|       |    ///
   58|       |    /// **default**: 0.2
   59|       |    open var cubicIntensity: CGFloat
   60|       |    {
   61|       |        get
   62|      0|        {
   63|      0|            return _cubicIntensity
   64|      0|        }
   65|       |        set
   66|      0|        {
   67|      0|            _cubicIntensity = newValue.clamped(to: 0.05...1)
   68|      0|        }
   69|       |    }
   70|       |        
   71|       |    /// The radius of the drawn circles.
   72|      0|    open var circleRadius = CGFloat(8.0)
   73|       |    
   74|       |    /// The hole radius of the drawn circles
   75|      0|    open var circleHoleRadius = CGFloat(4.0)
   76|       |    
   77|      0|    open var circleColors = [NSUIColor]()
   78|       |    
   79|       |    /// - Returns: The color at the given index of the DataSet's circle-color array.
   80|       |    /// Performs a IndexOutOfBounds check by modulus.
   81|       |    open func getCircleColor(atIndex index: Int) -> NSUIColor?
   82|      0|    {
   83|      0|        let size = circleColors.count
   84|      0|        let index = index % size
   85|      0|        if index >= size
   86|      0|        {
   87|      0|            return nil
   88|      0|        }
   89|      0|        return circleColors[index]
   90|      0|    }
   91|       |    
   92|       |    /// Sets the one and ONLY color that should be used for this DataSet.
   93|       |    /// Internally, this recreates the colors array and adds the specified color.
   94|       |    open func setCircleColor(_ color: NSUIColor)
   95|      0|    {
   96|      0|        circleColors.removeAll(keepingCapacity: false)
   97|      0|        circleColors.append(color)
   98|      0|    }
   99|       |    
  100|       |    open func setCircleColors(_ colors: NSUIColor...)
  101|      0|    {
  102|      0|        circleColors.removeAll(keepingCapacity: false)
  103|      0|        circleColors.append(contentsOf: colors)
  104|      0|    }
  105|       |    
  106|       |    /// Resets the circle-colors array and creates a new one
  107|       |    open func resetCircleColors(_ index: Int)
  108|      0|    {
  109|      0|        circleColors.removeAll(keepingCapacity: false)
  110|      0|    }
  111|       |    
  112|       |    /// If true, drawing circles is enabled
  113|       |    open var drawCirclesEnabled = true
  114|       |    
  115|       |    /// `true` if drawing circles for this DataSet is enabled, `false` ifnot
  116|      0|    open var isDrawCirclesEnabled: Bool { return drawCirclesEnabled }
  117|       |    
  118|       |    /// The color of the inner circle (the circle-hole).
  119|      0|    open var circleHoleColor: NSUIColor? = NSUIColor.white
  120|       |    
  121|       |    /// `true` if drawing circles for this DataSet is enabled, `false` ifnot
  122|       |    open var drawCircleHoleEnabled = true
  123|       |    
  124|       |    /// `true` if drawing the circle-holes is enabled, `false` ifnot.
  125|      0|    open var isDrawCircleHoleEnabled: Bool { return drawCircleHoleEnabled }
  126|       |    
  127|       |    /// This is how much (in pixels) into the dash pattern are we starting from.
  128|      0|    open var lineDashPhase = CGFloat(0.0)
  129|       |    
  130|       |    /// This is the actual dash pattern.
  131|       |    /// I.e. [2, 3] will paint [--   --   ]
  132|       |    /// [1, 3, 4, 2] will paint [-   ----  -   ----  ]
  133|       |    open var lineDashLengths: [CGFloat]?
  134|       |    
  135|       |    /// Line cap type, default is CGLineCap.Butt
  136|      0|    open var lineCapType = CGLineCap.butt
  137|       |    
  138|       |    /// formatter for customizing the position of the fill-line
  139|      0|    private var _fillFormatter: IFillFormatter = DefaultFillFormatter()
  140|       |    
  141|       |    /// Sets a custom IFillFormatter to the chart that handles the position of the filled-line for each DataSet. Set this to null to use the default logic.
  142|       |    open var fillFormatter: IFillFormatter?
  143|       |    {
  144|       |        get
  145|      0|        {
  146|      0|            return _fillFormatter
  147|      0|        }
  148|       |        set
  149|      0|        {
  150|      0|            _fillFormatter = newValue ?? DefaultFillFormatter()
  151|      0|        }
  152|       |    }
  153|       |    
  154|       |    // MARK: NSCopying
  155|       |    
  156|       |    open override func copy(with zone: NSZone? = nil) -> Any
  157|      0|    {
  158|      0|        let copy = super.copy(with: zone) as! LineChartDataSet
  159|      0|        copy.circleColors = circleColors
  160|      0|        copy.circleHoleColor = circleHoleColor
  161|      0|        copy.circleRadius = circleRadius
  162|      0|        copy.circleHoleRadius = circleHoleRadius
  163|      0|        copy.cubicIntensity = cubicIntensity
  164|      0|        copy.lineDashPhase = lineDashPhase
  165|      0|        copy.lineDashLengths = lineDashLengths
  166|      0|        copy.lineCapType = lineCapType
  167|      0|        copy.drawCirclesEnabled = drawCirclesEnabled
  168|      0|        copy.drawCircleHoleEnabled = drawCircleHoleEnabled
  169|      0|        copy.mode = mode
  170|      0|        copy._fillFormatter = _fillFormatter
  171|      0|        return copy
  172|      0|    }
  173|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/LineRadarChartDataSet.swift:
    1|       |//
    2|       |//  LineRadarChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class LineRadarChartDataSet: LineScatterCandleRadarChartDataSet, ILineRadarChartDataSet
   17|       |{
   18|       |    // MARK: - Data functions and accessors
   19|       |    
   20|       |    // MARK: - Styling functions and accessors
   21|       |    
   22|       |    /// The color that is used for filling the line surface area.
   23|      0|    private var _fillColor = NSUIColor(red: 140.0/255.0, green: 234.0/255.0, blue: 255.0/255.0, alpha: 1.0)
   24|       |    
   25|       |    /// The color that is used for filling the line surface area.
   26|       |    open var fillColor: NSUIColor
   27|       |    {
   28|      0|        get { return _fillColor }
   29|       |        set
   30|      0|        {
   31|      0|            _fillColor = newValue
   32|      0|            fill = nil
   33|      0|        }
   34|       |    }
   35|       |    
   36|       |    /// The object that is used for filling the area below the line.
   37|       |    /// **default**: nil
   38|       |    open var fill: Fill?
   39|       |    
   40|       |    /// The alpha value that is used for filling the line surface,
   41|       |    /// **default**: 0.33
   42|      0|    open var fillAlpha = CGFloat(0.33)
   43|       |    
   44|      0|    private var _lineWidth = CGFloat(1.0)
   45|       |    
   46|       |    /// line width of the chart (min = 0.0, max = 10)
   47|       |    ///
   48|       |    /// **default**: 1
   49|       |    open var lineWidth: CGFloat
   50|       |    {
   51|       |        get
   52|      0|        {
   53|      0|            return _lineWidth
   54|      0|        }
   55|       |        set
   56|      0|        {
   57|      0|            _lineWidth = newValue.clamped(to: 0...10)
   58|      0|        }
   59|       |    }
   60|       |    
   61|       |    /// Set to `true` if the DataSet should be drawn filled (surface), and not just as a line.
   62|       |    /// Disabling this will give great performance boost.
   63|       |    /// Please note that this method uses the path clipping for drawing the filled area (with images, gradients and layers).
   64|       |    open var drawFilledEnabled = false
   65|       |    
   66|       |    /// `true` if filled drawing is enabled, `false` ifnot
   67|       |    open var isDrawFilledEnabled: Bool
   68|      0|    {
   69|      0|        return drawFilledEnabled
   70|      0|    }
   71|       |    
   72|       |    // MARK: NSCopying
   73|       |    
   74|       |    open override func copy(with zone: NSZone? = nil) -> Any
   75|      0|    {
   76|      0|        let copy = super.copy(with: zone) as! LineRadarChartDataSet
   77|      0|        copy.fill = fill
   78|      0|        copy.fillAlpha = fillAlpha
   79|      0|        copy._fillColor = _fillColor
   80|      0|        copy._lineWidth = _lineWidth
   81|      0|        copy.drawFilledEnabled = drawFilledEnabled
   82|      0|        return copy
   83|      0|    }
   84|       |    
   85|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/LineScatterCandleRadarChartDataSet.swift:
    1|       |//
    2|       |//  LineScatterCandleRadarChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |
   15|       |open class LineScatterCandleRadarChartDataSet: BarLineScatterCandleBubbleChartDataSet, ILineScatterCandleRadarChartDataSet
   16|       |{
   17|       |    // MARK: - Data functions and accessors
   18|       |    
   19|       |    // MARK: - Styling functions and accessors
   20|       |    
   21|       |    /// Enables / disables the horizontal highlight-indicator. If disabled, the indicator is not drawn.
   22|       |    open var drawHorizontalHighlightIndicatorEnabled = true
   23|       |    
   24|       |    /// Enables / disables the vertical highlight-indicator. If disabled, the indicator is not drawn.
   25|       |    open var drawVerticalHighlightIndicatorEnabled = true
   26|       |    
   27|       |    /// `true` if horizontal highlight indicator lines are enabled (drawn)
   28|      0|    open var isHorizontalHighlightIndicatorEnabled: Bool { return drawHorizontalHighlightIndicatorEnabled }
   29|       |    
   30|       |    /// `true` if vertical highlight indicator lines are enabled (drawn)
   31|      0|    open var isVerticalHighlightIndicatorEnabled: Bool { return drawVerticalHighlightIndicatorEnabled }
   32|       |    
   33|       |    /// Enables / disables both vertical and horizontal highlight-indicators.
   34|       |    /// :param: enabled
   35|       |    open func setDrawHighlightIndicators(_ enabled: Bool)
   36|      0|    {
   37|      0|        drawHorizontalHighlightIndicatorEnabled = enabled
   38|      0|        drawVerticalHighlightIndicatorEnabled = enabled
   39|      0|    }
   40|       |    
   41|       |    // MARK: NSCopying
   42|       |    
   43|       |    open override func copy(with zone: NSZone? = nil) -> Any
   44|      0|    {
   45|      0|        let copy = super.copy(with: zone) as! LineScatterCandleRadarChartDataSet
   46|      0|        copy.drawHorizontalHighlightIndicatorEnabled = drawHorizontalHighlightIndicatorEnabled
   47|      0|        copy.drawVerticalHighlightIndicatorEnabled = drawVerticalHighlightIndicatorEnabled
   48|      0|        return copy
   49|      0|    }
   50|       |    
   51|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/PieChartData.swift:
    1|       |//
    2|       |//  PieData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |open class PieChartData: ChartData
   15|       |{
   16|       |    public override init()
   17|      0|    {
   18|      0|        super.init()
   19|      0|    }
   20|       |    
   21|       |    public override init(dataSets: [IChartDataSet]?)
   22|      0|    {
   23|      0|        super.init(dataSets: dataSets)
   24|      0|    }
   25|       |
   26|       |    /// All DataSet objects this ChartData object holds.
   27|       |    @objc open override var dataSets: [IChartDataSet]
   28|       |    {
   29|       |        get
   30|      0|        {
   31|      0|            assert(super.dataSets.count <= 1, "Found multiple data sets while pie chart only allows one")
   32|      0|            return super.dataSets
   33|      0|        }
   34|       |        set
   35|      0|        {
   36|      0|            super.dataSets = newValue
   37|      0|        }
   38|       |    }
   39|       |
   40|       |    @objc var dataSet: IPieChartDataSet?
   41|       |    {
   42|       |        get
   43|      0|        {
   44|      0|            return dataSets.count > 0 ? dataSets[0] as? IPieChartDataSet : nil
   45|      0|        }
   46|       |        set
   47|      0|        {
   48|      0|            if let newValue = newValue
   49|      0|            {
   50|      0|                dataSets = [newValue]
   51|      0|            }
   52|      0|            else
   53|      0|            {
   54|      0|                dataSets = []
   55|      0|            }
   56|      0|        }
   57|       |    }
   58|       |    
   59|       |    open override func getDataSetByIndex(_ index: Int) -> IChartDataSet?
   60|      0|    {
   61|      0|        if index != 0
   62|      0|        {
   63|      0|            return nil
   64|      0|        }
   65|      0|        return super.getDataSetByIndex(index)
   66|      0|    }
   67|       |    
   68|       |    open override func getDataSetByLabel(_ label: String, ignorecase: Bool) -> IChartDataSet?
   69|      0|    {
   70|      0|        if dataSets.count == 0 || dataSets[0].label == nil
   71|      0|        {
   72|      0|            return nil
   73|      0|        }
   74|      0|        
   75|      0|        if ignorecase
   76|      0|        {
   77|      0|            if let label = dataSets[0].label, label.caseInsensitiveCompare(label) == .orderedSame
   78|      0|            {
   79|      0|                return dataSets[0]
   80|      0|            }
   81|      0|        }
   82|      0|        else
   83|      0|        {
   84|      0|            if label == dataSets[0].label
   85|      0|            {
   86|      0|                return dataSets[0]
   87|      0|            }
   88|      0|        }
   89|      0|        return nil
   90|      0|    }
   91|       |    
   92|       |    open override func entryForHighlight(_ highlight: Highlight) -> ChartDataEntry?
   93|      0|    {
   94|      0|        return dataSet?.entryForIndex(Int(highlight.x))
   95|      0|    }
   96|       |    
   97|       |    open override func addDataSet(_ d: IChartDataSet!)
   98|      0|    {   
   99|      0|        super.addDataSet(d)
  100|      0|    }
  101|       |    
  102|       |    /// Removes the DataSet at the given index in the DataSet array from the data object.
  103|       |    /// Also recalculates all minimum and maximum values.
  104|       |    ///
  105|       |    /// - Returns: `true` if a DataSet was removed, `false` ifno DataSet could be removed.
  106|       |    open override func removeDataSetByIndex(_ index: Int) -> Bool
  107|      0|    {
  108|      0|        if index >= _dataSets.count || index < 0
  109|      0|        {
  110|      0|            return false
  111|      0|        }
  112|      0|        
  113|      0|        return false
  114|      0|    }
  115|       |    
  116|       |    /// The total y-value sum across all DataSet objects the this object represents.
  117|       |    @objc open var yValueSum: Double
  118|      0|    {
  119|      0|        guard let dataSet = dataSet else { return 0.0 }
  120|      0|        return (0..<dataSet.entryCount).reduce(into: 0) {
  121|      0|            $0 += dataSet.entryForIndex($1)?.y ?? 0
  122|      0|        }
  123|      0|    }
  124|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/PieChartDataEntry.swift:
    1|       |//
    2|       |//  PieChartDataEntry.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class PieChartDataEntry: ChartDataEntry
   16|       |{
   17|       |    public required init()
   18|      0|    {
   19|      0|        super.init()
   20|      0|    }
   21|       |    
   22|       |
   23|       |    /// - Parameters:
   24|       |    ///   - value: The value on the y-axis
   25|       |    @objc public init(value: Double)
   26|      0|    {
   27|      0|        super.init(x: .nan, y: value)
   28|      0|    }
   29|       |
   30|       |    /// - Parameters:
   31|       |    ///   - value: The value on the y-axis
   32|       |    ///   - label: The label for the x-axis
   33|       |    @objc public convenience init(value: Double, label: String?)
   34|      0|    {
   35|      0|        self.init(value: value)
   36|      0|        self.label = label
   37|      0|    }
   38|       |    
   39|       |    /// - Parameters:
   40|       |    ///   - value: The value on the y-axis
   41|       |    ///   - label: The label for the x-axis
   42|       |    ///   - data: Spot for additional data this Entry represents
   43|       |    @objc public convenience init(value: Double, label: String?, data: Any?)
   44|      0|    {
   45|      0|        self.init(value: value, label: label, icon: nil, data: data)
   46|      0|    }
   47|       |    
   48|       |    /// - Parameters:
   49|       |    ///   - value: The value on the y-axis
   50|       |    ///   - label: The label for the x-axis
   51|       |    ///   - icon: icon image
   52|       |    @objc public convenience init(value: Double, label: String?, icon: NSUIImage?)
   53|      0|    {
   54|      0|        self.init(value: value)
   55|      0|        self.label = label
   56|      0|        self.icon = icon
   57|      0|    }
   58|       |    
   59|       |    /// - Parameters:
   60|       |    ///   - value: The value on the y-axis
   61|       |    ///   - label: The label for the x-axis
   62|       |    ///   - icon: icon image
   63|       |    ///   - data: Spot for additional data this Entry represents
   64|       |    @objc public convenience init(value: Double, label: String?, icon: NSUIImage?, data: Any?)
   65|      0|    {
   66|      0|        self.init(value: value)
   67|      0|        self.label = label
   68|      0|        self.icon = icon
   69|      0|        self.data = data
   70|      0|    }
   71|       |
   72|       |    /// - Parameters:
   73|       |    ///   - value: The value on the y-axis
   74|       |    ///   - data: Spot for additional data this Entry represents
   75|       |    @objc public convenience init(value: Double, data: Any?)
   76|      0|    {
   77|      0|        self.init(value: value)
   78|      0|        self.data = data
   79|      0|    }
   80|       |    
   81|       |    /// - Parameters:
   82|       |    ///   - value: The value on the y-axis
   83|       |    ///   - icon: icon image
   84|       |    @objc public convenience init(value: Double, icon: NSUIImage?)
   85|      0|    {
   86|      0|        self.init(value: value)
   87|      0|        self.icon = icon
   88|      0|    }
   89|       |    
   90|       |    /// - Parameters:
   91|       |    ///   - value: The value on the y-axis
   92|       |    ///   - icon: icon image
   93|       |    ///   - data: Spot for additional data this Entry represents
   94|       |    @objc public convenience init(value: Double, icon: NSUIImage?, data: Any?)
   95|      0|    {
   96|      0|        self.init(value: value)
   97|      0|        self.icon = icon
   98|      0|        self.data = data
   99|      0|    }
  100|       |    
  101|       |    // MARK: Data property accessors
  102|       |    
  103|       |    @objc open var label: String?
  104|       |    
  105|       |    @objc open var value: Double
  106|       |    {
  107|      0|        get { return y }
  108|      0|        set { y = newValue }
  109|       |    }
  110|       |        
  111|       |    // MARK: NSCopying
  112|       |    
  113|       |    open override func copy(with zone: NSZone? = nil) -> Any
  114|      0|    {
  115|      0|        let copy = super.copy(with: zone) as! PieChartDataEntry
  116|      0|        copy.label = label
  117|      0|        return copy
  118|      0|    }
  119|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/PieChartDataSet.swift:
    1|       |//
    2|       |//  PieChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class PieChartDataSet: ChartDataSet, IPieChartDataSet
   16|       |{
   17|       |    @objc(PieChartValuePosition)
   18|       |    public enum ValuePosition: Int
   19|       |    {
   20|       |        case insideSlice
   21|       |        case outsideSlice
   22|       |    }
   23|       |
   24|       |    private func initialize()
   25|      0|    {
   26|      0|        self.valueTextColor = NSUIColor.white
   27|      0|        self.valueFont = NSUIFont.systemFont(ofSize: 13.0)
   28|      0|    }
   29|       |
   30|       |    public required init()
   31|      0|    {
   32|      0|        super.init()
   33|      0|        initialize()
   34|      0|    }
   35|       |
   36|       |    public override init(entries: [ChartDataEntry]?, label: String?)
   37|      0|    {
   38|      0|        super.init(entries: entries, label: label)
   39|      0|        initialize()
   40|      0|    }
   41|       |
   42|       |    internal override func calcMinMax(entry e: ChartDataEntry)
   43|      0|    {
   44|      0|        calcMinMaxY(entry: e)
   45|      0|    }
   46|       |
   47|       |    // MARK: - Styling functions and accessors
   48|       |
   49|      0|    private var _sliceSpace = CGFloat(0.0)
   50|       |
   51|       |    /// the space in pixels between the pie-slices
   52|       |    /// **default**: 0
   53|       |    /// **maximum**: 20
   54|       |    open var sliceSpace: CGFloat
   55|       |    {
   56|       |        get
   57|      0|        {
   58|      0|            return _sliceSpace
   59|      0|        }
   60|       |        set
   61|      0|        {
   62|      0|            var space = newValue
   63|      0|            if space > 20.0
   64|      0|            {
   65|      0|                space = 20.0
   66|      0|            }
   67|      0|            if space < 0.0
   68|      0|            {
   69|      0|                space = 0.0
   70|      0|            }
   71|      0|            _sliceSpace = space
   72|      0|        }
   73|       |    }
   74|       |
   75|       |    /// When enabled, slice spacing will be 0.0 when the smallest value is going to be smaller than the slice spacing itself.
   76|       |    open var automaticallyDisableSliceSpacing: Bool = false
   77|       |
   78|       |    /// indicates the selection distance of a pie slice
   79|      0|    open var selectionShift = CGFloat(18.0)
   80|       |
   81|      0|    open var xValuePosition: ValuePosition = .insideSlice
   82|      0|    open var yValuePosition: ValuePosition = .insideSlice
   83|       |
   84|       |    /// When valuePosition is OutsideSlice, indicates line color
   85|      0|    open var valueLineColor: NSUIColor? = NSUIColor.black
   86|       |
   87|       |    /// When valuePosition is OutsideSlice and enabled, line will have the same color as the slice
   88|       |    open var useValueColorForLine: Bool = false
   89|       |
   90|       |    /// When valuePosition is OutsideSlice, indicates line width
   91|       |    open var valueLineWidth: CGFloat = 1.0
   92|       |
   93|       |    /// When valuePosition is OutsideSlice, indicates offset as percentage out of the slice size
   94|       |    open var valueLinePart1OffsetPercentage: CGFloat = 0.75
   95|       |
   96|       |    /// When valuePosition is OutsideSlice, indicates length of first half of the line
   97|       |    open var valueLinePart1Length: CGFloat = 0.3
   98|       |
   99|       |    /// When valuePosition is OutsideSlice, indicates length of second half of the line
  100|       |    open var valueLinePart2Length: CGFloat = 0.4
  101|       |
  102|       |    /// When valuePosition is OutsideSlice, this allows variable line length
  103|       |    open var valueLineVariableLength: Bool = true
  104|       |
  105|       |    /// the font for the slice-text labels
  106|       |    open var entryLabelFont: NSUIFont? = nil
  107|       |
  108|       |    /// the color for the slice-text labels
  109|       |    open var entryLabelColor: NSUIColor? = nil
  110|       |
  111|       |    /// the color for the highlighted sector
  112|       |    open var highlightColor: NSUIColor? = nil
  113|       |
  114|       |    // MARK: - NSCopying
  115|       |
  116|       |    open override func copy(with zone: NSZone? = nil) -> Any
  117|      0|    {
  118|      0|        let copy = super.copy(with: zone) as! PieChartDataSet
  119|      0|        copy._sliceSpace = _sliceSpace
  120|      0|        copy.automaticallyDisableSliceSpacing = automaticallyDisableSliceSpacing
  121|      0|        copy.selectionShift = selectionShift
  122|      0|        copy.xValuePosition = xValuePosition
  123|      0|        copy.yValuePosition = yValuePosition
  124|      0|        copy.valueLineColor = valueLineColor
  125|      0|        copy.valueLineWidth = valueLineWidth
  126|      0|        copy.valueLinePart1OffsetPercentage = valueLinePart1OffsetPercentage
  127|      0|        copy.valueLinePart1Length = valueLinePart1Length
  128|      0|        copy.valueLinePart2Length = valueLinePart2Length
  129|      0|        copy.valueLineVariableLength = valueLineVariableLength
  130|      0|        copy.entryLabelFont = entryLabelFont
  131|      0|        copy.entryLabelColor = entryLabelColor
  132|      0|        copy.highlightColor = highlightColor
  133|      0|        return copy
  134|      0|    }
  135|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/RadarChartData.swift:
    1|       |//
    2|       |//  RadarChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class RadarChartData: ChartData
   17|       |{
   18|      0|    @objc open var highlightColor = NSUIColor(red: 255.0/255.0, green: 187.0/255.0, blue: 115.0/255.0, alpha: 1.0)
   19|      0|    @objc open var highlightLineWidth = CGFloat(1.0)
   20|      0|    @objc open var highlightLineDashPhase = CGFloat(0.0)
   21|       |    @objc open var highlightLineDashLengths: [CGFloat]?
   22|       |    
   23|       |    /// Sets labels that should be drawn around the RadarChart at the end of each web line.
   24|      0|    @objc open var labels = [String]()
   25|       |    
   26|       |    /// Sets the labels that should be drawn around the RadarChart at the end of each web line.
   27|       |    open func setLabels(_ labels: String...)
   28|      0|    {
   29|      0|        self.labels = labels
   30|      0|    }
   31|       |    
   32|       |    public override init()
   33|      0|    {
   34|      0|        super.init()
   35|      0|    }
   36|       |    
   37|       |    public override init(dataSets: [IChartDataSet]?)
   38|      0|    {
   39|      0|        super.init(dataSets: dataSets)
   40|      0|    }
   41|       |    
   42|       |    open override func entryForHighlight(_ highlight: Highlight) -> ChartDataEntry?
   43|      0|    {
   44|      0|        return getDataSetByIndex(highlight.dataSetIndex)?.entryForIndex(Int(highlight.x))
   45|      0|    }
   46|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/RadarChartDataEntry.swift:
    1|       |//
    2|       |//  RadarChartDataEntry.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class RadarChartDataEntry: ChartDataEntry
   16|       |{
   17|       |    public required init()
   18|      0|    {
   19|      0|        super.init()
   20|      0|    }
   21|       |
   22|       |    /// - Parameters:
   23|       |    ///   - value: The value on the y-axis.
   24|       |    @objc public init(value: Double)
   25|      0|    {
   26|      0|        super.init(x: .nan, y: value)
   27|      0|    }
   28|       |
   29|       |    /// - Parameters:
   30|       |    ///   - value: The value on the y-axis.
   31|       |    ///   - data: Spot for additional data this Entry represents.
   32|       |    @objc public convenience init(value: Double, data: Any?)
   33|      0|    {
   34|      0|        self.init(value: value)
   35|      0|        self.data = data
   36|      0|    }
   37|       |    
   38|       |    // MARK: Data property accessors
   39|       |    
   40|       |    @objc open var value: Double
   41|       |    {
   42|      0|        get { return y }
   43|      0|        set { y = newValue }
   44|       |    }
   45|       |    
   46|       |    // MARK: NSCopying
   47|       |    
   48|       |    open override func copy(with zone: NSZone? = nil) -> Any
   49|      0|    {
   50|      0|        let copy = super.copy(with: zone) as! RadarChartDataEntry
   51|      0|        
   52|      0|        return copy
   53|      0|    }
   54|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/RadarChartDataSet.swift:
    1|       |//
    2|       |//  RadarChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |
   16|       |open class RadarChartDataSet: LineRadarChartDataSet, IRadarChartDataSet
   17|       |{
   18|       |    private func initialize()
   19|      0|    {
   20|      0|        self.valueFont = NSUIFont.systemFont(ofSize: 13.0)
   21|      0|    }
   22|       |    
   23|       |    public required init()
   24|      0|    {
   25|      0|        super.init()
   26|      0|        initialize()
   27|      0|    }
   28|       |    
   29|       |    public required override init(entries: [ChartDataEntry]?, label: String?)
   30|      0|    {
   31|      0|        super.init(entries: entries, label: label)
   32|      0|        initialize()
   33|      0|    }
   34|       |    
   35|       |    // MARK: - Data functions and accessors
   36|       |    
   37|       |    // MARK: - Styling functions and accessors
   38|       |    
   39|       |    /// flag indicating whether highlight circle should be drawn or not
   40|       |    /// **default**: false
   41|       |    open var drawHighlightCircleEnabled: Bool = false
   42|       |    
   43|       |    /// `true` if highlight circle should be drawn, `false` ifnot
   44|      0|    open var isDrawHighlightCircleEnabled: Bool { return drawHighlightCircleEnabled }
   45|       |    
   46|      0|    open var highlightCircleFillColor: NSUIColor? = NSUIColor.white
   47|       |    
   48|       |    /// The stroke color for highlight circle.
   49|       |    /// If `nil`, the color of the dataset is taken.
   50|       |    open var highlightCircleStrokeColor: NSUIColor?
   51|       |    
   52|       |    open var highlightCircleStrokeAlpha: CGFloat = 0.3
   53|       |    
   54|       |    open var highlightCircleInnerRadius: CGFloat = 3.0
   55|       |    
   56|       |    open var highlightCircleOuterRadius: CGFloat = 4.0
   57|       |    
   58|       |    open var highlightCircleStrokeWidth: CGFloat = 2.0
   59|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/ScatterChartData.swift:
    1|       |//
    2|       |//  ScatterChartData.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class ScatterChartData: BarLineScatterCandleBubbleChartData
   16|       |{
   17|       |    public override init()
   18|      0|    {
   19|      0|        super.init()
   20|      0|    }
   21|       |    
   22|       |    public override init(dataSets: [IChartDataSet]?)
   23|      0|    {
   24|      0|        super.init(dataSets: dataSets)
   25|      0|    }
   26|       |    
   27|       |    /// - Returns: The maximum shape-size across all DataSets.
   28|       |    @objc open func getGreatestShapeSize() -> CGFloat
   29|      0|    {
   30|      0|        return (_dataSets as? [IScatterChartDataSet])?
   31|      0|            .max { $0.scatterShapeSize < $1.scatterShapeSize }?
   32|      0|            .scatterShapeSize ?? 0
   33|      0|    }
   34|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Data/Implementations/Standard/ScatterChartDataSet.swift:
    1|       |//
    2|       |//  ScatterChartDataSet.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class ScatterChartDataSet: LineScatterCandleRadarChartDataSet, IScatterChartDataSet
   16|       |{
   17|       |    
   18|       |    @objc(ScatterShape)
   19|       |    public enum Shape: Int
   20|       |    {
   21|       |        case square
   22|       |        case circle
   23|       |        case triangle
   24|       |        case cross
   25|       |        case x
   26|       |        case chevronUp
   27|       |        case chevronDown
   28|       |    }
   29|       |    
   30|       |    /// The size the scatter shape will have
   31|      0|    open var scatterShapeSize = CGFloat(10.0)
   32|       |    
   33|       |    /// The radius of the hole in the shape (applies to Square, Circle and Triangle)
   34|       |    /// **default**: 0.0
   35|       |    open var scatterShapeHoleRadius: CGFloat = 0.0
   36|       |    
   37|       |    /// Color for the hole in the shape. Setting to `nil` will behave as transparent.
   38|       |    /// **default**: nil
   39|       |    open var scatterShapeHoleColor: NSUIColor? = nil
   40|       |    
   41|       |    /// Sets the ScatterShape this DataSet should be drawn with.
   42|       |    /// This will search for an available IShapeRenderer and set this renderer for the DataSet
   43|       |    @objc open func setScatterShape(_ shape: Shape)
   44|      0|    {
   45|      0|        self.shapeRenderer = ScatterChartDataSet.renderer(forShape: shape)
   46|      0|    }
   47|       |    
   48|       |    /// The IShapeRenderer responsible for rendering this DataSet.
   49|       |    /// This can also be used to set a custom IShapeRenderer aside from the default ones.
   50|       |    /// **default**: `SquareShapeRenderer`
   51|      0|    open var shapeRenderer: IShapeRenderer? = SquareShapeRenderer()
   52|       |    
   53|       |    @objc open class func renderer(forShape shape: Shape) -> IShapeRenderer
   54|      0|    {
   55|      0|        switch shape
   56|      0|        {
   57|      0|        case .square: return SquareShapeRenderer()
   58|      0|        case .circle: return CircleShapeRenderer()
   59|      0|        case .triangle: return TriangleShapeRenderer()
   60|      0|        case .cross: return CrossShapeRenderer()
   61|      0|        case .x: return XShapeRenderer()
   62|      0|        case .chevronUp: return ChevronUpShapeRenderer()
   63|      0|        case .chevronDown: return ChevronDownShapeRenderer()
   64|      0|        }
   65|      0|    }
   66|       |    
   67|       |    // MARK: NSCopying
   68|       |    
   69|       |    open override func copy(with zone: NSZone? = nil) -> Any
   70|      0|    {
   71|      0|        let copy = super.copy(with: zone) as! ScatterChartDataSet
   72|      0|        copy.scatterShapeSize = scatterShapeSize
   73|      0|        copy.scatterShapeHoleRadius = scatterShapeHoleRadius
   74|      0|        copy.scatterShapeHoleColor = scatterShapeHoleColor
   75|      0|        copy.shapeRenderer = shapeRenderer
   76|      0|        return copy
   77|      0|    }
   78|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Filters/DataApproximator+N.swift:
    1|       |//
    2|       |//  DataApproximator+N.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Created by M Ivaniushchenko on 9/6/17.
    6|       |//  Licensed under Apache License 2.0
    7|       |//
    8|       |//  https://github.com/danielgindi/Charts
    9|       |//
   10|       |
   11|       |import Foundation
   12|       |import CoreGraphics
   13|       |
   14|       |extension CGPoint {
   15|      0|    fileprivate func distanceToLine(from linePoint1: CGPoint, to linePoint2: CGPoint) -> CGFloat {
   16|      0|        let dx = linePoint2.x - linePoint1.x
   17|      0|        let dy = linePoint2.y - linePoint1.y
   18|      0|        
   19|      0|        let dividend = abs(dy * self.x - dx * self.y - linePoint1.x * linePoint2.y + linePoint2.x * linePoint1.y)
   20|      0|        let divisor = sqrt(dx * dx + dy * dy)
   21|      0|        
   22|      0|        return dividend / divisor
   23|      0|    }
   24|       |}
   25|       |
   26|       |private struct LineAlt {
   27|       |    let start: Int
   28|       |    let end: Int
   29|       |    
   30|       |    var distance: CGFloat = 0
   31|       |    var index: Int = 0
   32|       |    
   33|      0|    init(start: Int, end: Int, points: [CGPoint]) {
   34|      0|        self.start = start
   35|      0|        self.end = end
   36|      0|        
   37|      0|        let startPoint = points[start]
   38|      0|        let endPoint = points[end]
   39|      0|        
   40|      0|        guard (end > start + 1) else {
   41|      0|            return
   42|      0|        }
   43|      0|        
   44|      0|        for i in start + 1 ..< end {
   45|      0|            let currentPoint = points[i]
   46|      0|            
   47|      0|            let distance = currentPoint.distanceToLine(from: startPoint, to: endPoint)
   48|      0|            
   49|      0|            if distance > self.distance {
   50|      0|                self.index = i
   51|      0|                self.distance = distance
   52|      0|            }
   53|      0|        }
   54|      0|    }
   55|       |}
   56|       |
   57|       |extension LineAlt: Comparable {
   58|      0|    static func ==(lhs: LineAlt, rhs: LineAlt) -> Bool {
   59|      0|        return (lhs.start == rhs.start) && (lhs.end == rhs.end) && (lhs.index == rhs.index)
   60|      0|    }
   61|       |    
   62|      0|    static func <(lhs: LineAlt, rhs: LineAlt) -> Bool {
   63|      0|        return lhs.distance < rhs.distance
   64|      0|    }
   65|       |}
   66|       |
   67|       |
   68|       |extension DataApproximator {
   69|       |    /// uses the douglas peuker algorithm to reduce the given arraylist of entries to given number of points
   70|       |    /// More algorithm details here - http://psimpl.sourceforge.net/douglas-peucker.html
   71|       |    @objc open class func reduceWithDouglasPeukerN(_ points: [CGPoint], resultCount: Int) -> [CGPoint]
   72|      0|    {
   73|      0|        // if a shape has 2 or less points it cannot be reduced
   74|      0|        if resultCount <= 2 || resultCount >= points.count
   75|      0|        {
   76|      0|            return points
   77|      0|        }
   78|      0|        var keep = [Bool](repeating: false, count: points.count)
   79|      0|        
   80|      0|        // first and last always stay
   81|      0|        keep[0] = true
   82|      0|        keep[points.count - 1] = true
   83|      0|        var currentStoredPoints = 2
   84|      0|        
   85|      0|        var queue = [LineAlt]()
   86|      0|        let line = LineAlt(start: 0, end: points.count - 1, points: points)
   87|      0|        queue.append(line)
   88|      0|        
   89|      0|        repeat {
   90|      0|            let line = queue.popLast()!
   91|      0|            
   92|      0|            // store the key
   93|      0|            keep[line.index] = true
   94|      0|            
   95|      0|            // check point count tolerance
   96|      0|            currentStoredPoints += 1
   97|      0|            
   98|      0|            if (currentStoredPoints == resultCount) {
   99|      0|                break;
  100|      0|            }
  101|      0|            
  102|      0|            // split the polyline at the key and recurse
  103|      0|            let left = LineAlt(start: line.start, end: line.index, points: points)
  104|      0|            if (left.index > 0) {
  105|      0|                self.insertLine(left, into: &queue)
  106|      0|            }
  107|      0|            
  108|      0|            let right = LineAlt(start: line.index, end: line.end, points: points)
  109|      0|            if (right.index > 0) {
  110|      0|                self.insertLine(right, into: &queue)
  111|      0|            }
  112|      0|            
  113|      0|        } while !queue.isEmpty
  114|      0|        
  115|      0|        // create a new array with series, only take the kept ones
  116|      0|        let reducedEntries = points.enumerated().compactMap { (index: Int, point: CGPoint) -> CGPoint? in
  117|      0|            return keep[index] ? point : nil
  118|      0|        }
  119|      0|        
  120|      0|        return reducedEntries
  121|      0|    }
  122|       |    
  123|       |    // Keeps array sorted
  124|      0|    private static func insertLine(_ line: LineAlt, into array: inout [LineAlt]) {
  125|      0|        let insertionIndex = self.insertionIndex(for: line, into: &array)
  126|      0|        array.insert(line, at: insertionIndex)
  127|      0|    }
  128|       |    
  129|      0|    private static func insertionIndex(for line: LineAlt, into array: inout [LineAlt]) -> Int {
  130|      0|        var indices = array.indices
  131|      0|        
  132|      0|        while !indices.isEmpty {
  133|      0|            let midIndex = indices.lowerBound.advanced(by: indices.count / 2)
  134|      0|            let midLine = array[midIndex]
  135|      0|            
  136|      0|            if midLine == line {
  137|      0|                return midIndex
  138|      0|            }
  139|      0|            else if (line < midLine) {
  140|      0|                // perform search in left half
  141|      0|                indices = indices.lowerBound..<midIndex
  142|      0|            }
  143|      0|            else {
  144|      0|                // perform search in right half
  145|      0|                indices = (midIndex + 1)..<indices.upperBound
  146|      0|            }
  147|      0|        }
  148|      0|        
  149|      0|        return indices.lowerBound
  150|      0|    }
  151|       |}
  152|       |
  153|       |

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Filters/DataApproximator.swift:
    1|       |//
    2|       |//  DataApproximator.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartDataApproximator)
   16|       |open class DataApproximator: NSObject
   17|       |{
   18|       |    /// uses the douglas peuker algorithm to reduce the given arraylist of entries
   19|       |    @objc open class func reduceWithDouglasPeuker(_ points: [CGPoint], tolerance: CGFloat) -> [CGPoint]
   20|      0|    {
   21|      0|        // if a shape has 2 or less points it cannot be reduced
   22|      0|        if tolerance <= 0 || points.count < 3
   23|      0|        {
   24|      0|            return points
   25|      0|        }
   26|      0|        
   27|      0|        var keep = [Bool](repeating: false, count: points.count)
   28|      0|        
   29|      0|        // first and last always stay
   30|      0|        keep[0] = true
   31|      0|        keep[points.count - 1] = true
   32|      0|        
   33|      0|        // first and last entry are entry point to recursion
   34|      0|        reduceWithDouglasPeuker(points: points,
   35|      0|                                tolerance: tolerance,
   36|      0|                                start: 0,
   37|      0|                                end: points.count - 1,
   38|      0|                                keep: &keep)
   39|      0|        
   40|      0|        // create a new array with series, only take the kept ones
   41|      0|        return zip(keep, points).compactMap { $0 ? nil : $1 }
   42|      0|    }
   43|       |
   44|       |    /// apply the Douglas-Peucker-Reduction to an array of `CGPoint`s with a given tolerance
   45|       |    ///
   46|       |    /// - Parameters:
   47|       |    ///   - points:
   48|       |    ///   - tolerance:
   49|       |    ///   - start:
   50|       |    ///   - end:
   51|       |    open class func reduceWithDouglasPeuker(
   52|       |        points: [CGPoint],
   53|       |        tolerance: CGFloat,
   54|       |        start: Int,
   55|       |        end: Int,
   56|       |        keep: inout [Bool])
   57|      0|    {
   58|      0|        if end <= start + 1
   59|      0|        {
   60|      0|            // recursion finished
   61|      0|            return
   62|      0|        }
   63|      0|        
   64|      0|        var greatestIndex = Int(0)
   65|      0|        var greatestDistance = CGFloat(0.0)
   66|      0|        
   67|      0|        let line = Line(pt1: points[start], pt2: points[end])
   68|      0|        
   69|      0|        for i in start + 1 ..< end
   70|      0|        {
   71|      0|            let distance = line.distance(toPoint: points[i])
   72|      0|            
   73|      0|            if distance > greatestDistance
   74|      0|            {
   75|      0|                greatestDistance = distance
   76|      0|                greatestIndex = i
   77|      0|            }
   78|      0|        }
   79|      0|        
   80|      0|        if greatestDistance > tolerance
   81|      0|        {
   82|      0|            // keep max dist point
   83|      0|            keep[greatestIndex] = true
   84|      0|            
   85|      0|            // recursive call
   86|      0|            reduceWithDouglasPeuker(points: points, tolerance: tolerance, start: start, end: greatestIndex, keep: &keep)
   87|      0|            reduceWithDouglasPeuker(points: points, tolerance: tolerance, start: greatestIndex, end: end, keep: &keep)
   88|      0|        } // else don't keep the point...
   89|      0|    }
   90|       |    
   91|       |    private class Line
   92|       |    {
   93|       |        var sxey: CGFloat
   94|       |        var exsy: CGFloat
   95|       |        
   96|       |        var dx: CGFloat
   97|       |        var dy: CGFloat
   98|       |        
   99|       |        var length: CGFloat
  100|       |        
  101|       |        init(pt1: CGPoint, pt2: CGPoint)
  102|      0|        {
  103|      0|            dx = pt1.x - pt2.x
  104|      0|            dy = pt1.y - pt2.y
  105|      0|            sxey = pt1.x * pt2.y
  106|      0|            exsy = pt2.x * pt1.y
  107|      0|            length = sqrt(dx * dx + dy * dy)
  108|      0|        }
  109|       |        
  110|       |        func distance(toPoint pt: CGPoint) -> CGFloat
  111|      0|        {
  112|      0|            return abs(dy * pt.x - dx * pt.y + sxey - exsy) / length
  113|      0|        }
  114|       |    }
  115|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Formatters/DefaultAxisValueFormatter.swift:
    1|       |//
    2|       |//  DefaultAxisValueFormatter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |@objc(ChartDefaultAxisValueFormatter)
   15|       |open class DefaultAxisValueFormatter: NSObject, IAxisValueFormatter
   16|       |{
   17|       |    public typealias Block = (
   18|       |        _ value: Double,
   19|       |        _ axis: AxisBase?) -> String
   20|       |    
   21|       |    @objc open var block: Block?
   22|       |    
   23|       |    @objc open var hasAutoDecimals: Bool = false
   24|       |    
   25|       |    private var _formatter: NumberFormatter?
   26|       |    @objc open var formatter: NumberFormatter?
   27|       |    {
   28|      0|        get { return _formatter }
   29|       |        set
   30|      0|        {
   31|      0|            hasAutoDecimals = false
   32|      0|            _formatter = newValue
   33|      0|        }
   34|       |    }
   35|       |
   36|       |    // TODO: Documentation. Especially the nil case
   37|       |    private var _decimals: Int?
   38|       |    open var decimals: Int?
   39|       |    {
   40|      0|        get { return _decimals }
   41|       |        set
   42|      0|        {
   43|      0|            _decimals = newValue
   44|      0|            
   45|      0|            if let digits = newValue
   46|      0|            {
   47|      0|                self.formatter?.minimumFractionDigits = digits
   48|      0|                self.formatter?.maximumFractionDigits = digits
   49|      0|                self.formatter?.usesGroupingSeparator = true
   50|      0|            }
   51|      0|        }
   52|       |    }
   53|       |    
   54|       |    public override init()
   55|      0|    {
   56|      0|        super.init()
   57|      0|        
   58|      0|        self.formatter = NumberFormatter()
   59|      0|        hasAutoDecimals = true
   60|      0|    }
   61|       |    
   62|       |    @objc public init(formatter: NumberFormatter)
   63|      0|    {
   64|      0|        super.init()
   65|      0|        
   66|      0|        self.formatter = formatter
   67|      0|    }
   68|       |    
   69|       |    @objc public init(decimals: Int)
   70|      0|    {
   71|      0|        super.init()
   72|      0|        
   73|      0|        self.formatter = NumberFormatter()
   74|      0|        self.formatter?.usesGroupingSeparator = true
   75|      0|        self.decimals = decimals
   76|      0|        hasAutoDecimals = true
   77|      0|    }
   78|       |    
   79|       |    @objc public init(block: @escaping Block)
   80|      0|    {
   81|      0|        super.init()
   82|      0|        
   83|      0|        self.block = block
   84|      0|    }
   85|       |    
   86|       |    @objc public static func with(block: @escaping Block) -> DefaultAxisValueFormatter?
   87|      0|    {
   88|      0|        return DefaultAxisValueFormatter(block: block)
   89|      0|    }
   90|       |    
   91|       |    open func stringForValue(_ value: Double,
   92|       |                               axis: AxisBase?) -> String
   93|      0|    {
   94|      0|        if let block = block {
   95|      0|            return block(value, axis)
   96|      0|        } else {
   97|      0|            return formatter?.string(from: NSNumber(floatLiteral: value)) ?? ""
   98|      0|        }
   99|      0|    }
  100|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Formatters/DefaultFillFormatter.swift:
    1|       |//
    2|       |//  DefaultFillFormatter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// Default formatter that calculates the position of the filled line.
   16|       |@objc(ChartDefaultFillFormatter)
   17|       |open class DefaultFillFormatter: NSObject, IFillFormatter
   18|       |{
   19|       |    public typealias Block = (
   20|       |        _ dataSet: ILineChartDataSet,
   21|       |        _ dataProvider: LineChartDataProvider) -> CGFloat
   22|       |    
   23|       |    @objc open var block: Block?
   24|       |    
   25|      0|    public override init() { }
   26|       |    
   27|       |    @objc public init(block: @escaping Block)
   28|      0|    {
   29|      0|        self.block = block
   30|      0|    }
   31|       |    
   32|       |    @objc public static func with(block: @escaping Block) -> DefaultFillFormatter?
   33|      0|    {
   34|      0|        return DefaultFillFormatter(block: block)
   35|      0|    }
   36|       |    
   37|       |    open func getFillLinePosition(
   38|       |        dataSet: ILineChartDataSet,
   39|       |        dataProvider: LineChartDataProvider) -> CGFloat
   40|      0|    {
   41|      0|        guard block == nil else { return block!(dataSet, dataProvider) }
   42|      0|        var fillMin: CGFloat = 0.0
   43|      0|
   44|      0|        if dataSet.yMax > 0.0 && dataSet.yMin < 0.0
   45|      0|        {
   46|      0|            fillMin = 0.0
   47|      0|        }
   48|      0|        else if let data = dataProvider.data
   49|      0|        {
   50|      0|            let max = data.yMax > 0.0 ? 0.0 : dataProvider.chartYMax
   51|      0|            let min = data.yMin < 0.0 ? 0.0 : dataProvider.chartYMin
   52|      0|
   53|      0|            fillMin = CGFloat(dataSet.yMin >= 0.0 ? min : max)
   54|      0|        }
   55|      0|
   56|      0|        return fillMin
   57|      0|    }
   58|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Formatters/DefaultValueFormatter.swift:
    1|       |//
    2|       |//  DefaultValueFormatter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |@objc(ChartDefaultValueFormatter)
   15|       |open class DefaultValueFormatter: NSObject, IValueFormatter
   16|       |{
   17|       |    public typealias Block = (
   18|       |        _ value: Double,
   19|       |        _ entry: ChartDataEntry,
   20|       |        _ dataSetIndex: Int,
   21|       |        _ viewPortHandler: ViewPortHandler?) -> String
   22|       |    
   23|       |    @objc open var block: Block?
   24|       |    
   25|       |    @objc open var hasAutoDecimals: Bool = false
   26|       |    
   27|       |    private var _formatter: NumberFormatter?
   28|       |    @objc open var formatter: NumberFormatter?
   29|       |    {
   30|      0|        get { return _formatter }
   31|       |        set
   32|      0|        {
   33|      0|            hasAutoDecimals = false
   34|      0|            _formatter = newValue
   35|      0|        }
   36|       |    }
   37|       |    
   38|       |    private var _decimals: Int?
   39|       |    open var decimals: Int?
   40|       |    {
   41|      0|        get { return _decimals }
   42|       |        set
   43|      0|        {
   44|      0|            _decimals = newValue
   45|      0|            
   46|      0|            if let digits = newValue
   47|      0|            {
   48|      0|                self.formatter?.minimumFractionDigits = digits
   49|      0|                self.formatter?.maximumFractionDigits = digits
   50|      0|                self.formatter?.usesGroupingSeparator = true
   51|      0|            }
   52|      0|        }
   53|       |    }
   54|       |    
   55|       |    public override init()
   56|      0|    {
   57|      0|        super.init()
   58|      0|        
   59|      0|        self.formatter = NumberFormatter()
   60|      0|        hasAutoDecimals = true
   61|      0|    }
   62|       |    
   63|       |    @objc public init(formatter: NumberFormatter)
   64|      0|    {
   65|      0|        super.init()
   66|      0|        
   67|      0|        self.formatter = formatter
   68|      0|    }
   69|       |    
   70|       |    @objc public init(decimals: Int)
   71|      0|    {
   72|      0|        super.init()
   73|      0|        
   74|      0|        self.formatter = NumberFormatter()
   75|      0|        self.formatter?.usesGroupingSeparator = true
   76|      0|        self.decimals = decimals
   77|      0|        hasAutoDecimals = true
   78|      0|    }
   79|       |    
   80|       |    @objc public init(block: @escaping Block)
   81|      0|    {
   82|      0|        super.init()
   83|      0|        
   84|      0|        self.block = block
   85|      0|    }
   86|       |    
   87|       |    @objc public static func with(block: @escaping Block) -> DefaultValueFormatter?
   88|      0|    {
   89|      0|        return DefaultValueFormatter(block: block)
   90|      0|    }
   91|       |    
   92|       |    open func stringForValue(_ value: Double,
   93|       |                             entry: ChartDataEntry,
   94|       |                             dataSetIndex: Int,
   95|       |                             viewPortHandler: ViewPortHandler?) -> String
   96|      0|    {
   97|      0|        if let block = block {
   98|      0|            return block(value, entry, dataSetIndex, viewPortHandler)
   99|      0|        } else {
  100|      0|            return formatter?.string(from: NSNumber(floatLiteral: value)) ?? ""
  101|      0|        }
  102|      0|    }
  103|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Formatters/IndexAxisValueFormatter.swift:
    1|       |//
    2|       |//  IndexAxisValueFormatter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |/// This formatter is used for passing an array of x-axis labels, on whole x steps.
   15|       |@objc(ChartIndexAxisValueFormatter)
   16|       |open class IndexAxisValueFormatter: NSObject, IAxisValueFormatter
   17|       |{
   18|      0|    private var _values: [String] = [String]()
   19|       |    private var _valueCount: Int = 0
   20|       |    
   21|       |    @objc public var values: [String]
   22|       |    {
   23|       |        get
   24|      0|        {
   25|      0|            return _values
   26|      0|        }
   27|       |        set
   28|      0|        {
   29|      0|            _values = newValue
   30|      0|            _valueCount = _values.count
   31|      0|        }
   32|       |    }
   33|       |    
   34|       |    public override init()
   35|      0|    {
   36|      0|        super.init()
   37|      0|        
   38|      0|    }
   39|       |    
   40|       |    @objc public init(values: [String])
   41|      0|    {
   42|      0|        super.init()
   43|      0|        
   44|      0|        self.values = values
   45|      0|    }
   46|       |    
   47|       |    @objc public static func with(values: [String]) -> IndexAxisValueFormatter?
   48|      0|    {
   49|      0|        return IndexAxisValueFormatter(values: values)
   50|      0|    }
   51|       |    
   52|       |    open func stringForValue(_ value: Double,
   53|       |                             axis: AxisBase?) -> String
   54|      0|    {
   55|      0|        let index = Int(value.rounded())
   56|      0|        guard values.indices.contains(index), index == Int(value) else { return "" }
   57|      0|        return _values[index]
   58|      0|    }
   59|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/BarHighlighter.swift:
    1|       |//
    2|       |//  BarHighlighter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(BarChartHighlighter)
   16|       |open class BarHighlighter: ChartHighlighter
   17|       |{
   18|       |    open override func getHighlight(x: CGFloat, y: CGFloat) -> Highlight?
   19|      0|    {
   20|      0|        guard
   21|      0|            let barData = (self.chart as? BarChartDataProvider)?.barData,
   22|      0|            let high = super.getHighlight(x: x, y: y)
   23|      0|            else { return nil }
   24|      0|        
   25|      0|        let pos = getValsForTouch(x: x, y: y)
   26|      0|
   27|      0|        if let set = barData.getDataSetByIndex(high.dataSetIndex) as? IBarChartDataSet,
   28|      0|            set.isStacked
   29|      0|        {
   30|      0|            return getStackedHighlight(high: high,
   31|      0|                                       set: set,
   32|      0|                                       xValue: Double(pos.x),
   33|      0|                                       yValue: Double(pos.y))
   34|      0|        }
   35|      0|        else
   36|      0|        {
   37|      0|            return high
   38|      0|        }
   39|      0|    }
   40|       |    
   41|       |    internal override func getDistance(x1: CGFloat, y1: CGFloat, x2: CGFloat, y2: CGFloat) -> CGFloat
   42|      0|    {
   43|      0|        return abs(x1 - x2)
   44|      0|    }
   45|       |    
   46|       |    internal override var data: ChartData?
   47|      0|    {
   48|      0|        return (chart as? BarChartDataProvider)?.barData
   49|      0|    }
   50|       |    
   51|       |    /// This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
   52|       |    ///
   53|       |    /// - Parameters:
   54|       |    ///   - high: the Highlight to work with looking for stacked values
   55|       |    ///   - set:
   56|       |    ///   - xIndex:
   57|       |    ///   - yValue:
   58|       |    /// - Returns:
   59|       |    @objc open func getStackedHighlight(high: Highlight,
   60|       |                                  set: IBarChartDataSet,
   61|       |                                  xValue: Double,
   62|       |                                  yValue: Double) -> Highlight?
   63|      0|    {
   64|      0|        guard
   65|      0|            let chart = self.chart as? BarLineScatterCandleBubbleChartDataProvider,
   66|      0|            let entry = set.entryForXValue(xValue, closestToY: yValue) as? BarChartDataEntry
   67|      0|            else { return nil }
   68|      0|        
   69|      0|        // Not stacked
   70|      0|        if entry.yValues == nil
   71|      0|        {
   72|      0|            return high
   73|      0|        }
   74|      0|        
   75|      0|        guard
   76|      0|            let ranges = entry.ranges,
   77|      0|            ranges.count > 0
   78|      0|            else { return nil }
   79|      0|
   80|      0|        let stackIndex = getClosestStackIndex(ranges: ranges, value: yValue)
   81|      0|        let pixel = chart
   82|      0|            .getTransformer(forAxis: set.axisDependency)
   83|      0|            .pixelForValues(x: high.x, y: ranges[stackIndex].to)
   84|      0|
   85|      0|        return Highlight(x: entry.x,
   86|      0|                         y: entry.y,
   87|      0|                         xPx: pixel.x,
   88|      0|                         yPx: pixel.y,
   89|      0|                         dataSetIndex: high.dataSetIndex,
   90|      0|                         stackIndex: stackIndex,
   91|      0|                         axis: high.axis)
   92|      0|    }
   93|       |    
   94|       |    /// - Parameters:
   95|       |    ///   - entry:
   96|       |    ///   - value:
   97|       |    /// - Returns: The index of the closest value inside the values array / ranges (stacked barchart) to the value given as a parameter.
   98|       |    @objc open func getClosestStackIndex(ranges: [Range]?, value: Double) -> Int
   99|      0|    {
  100|      0|        guard let ranges = ranges else { return 0 }
  101|      0|        if let stackIndex = ranges.firstIndex(where: { $0.contains(value) }) {
  102|      0|            return stackIndex
  103|      0|        } else {
  104|      0|            let length = max(ranges.count - 1, 0)
  105|      0|            return (value > ranges[length].to) ? length : 0
  106|      0|        }
  107|      0|    }
  108|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/ChartHighlighter.swift:
    1|       |//
    2|       |//  ChartHighlighter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class ChartHighlighter : NSObject, IHighlighter
   16|       |{
   17|       |    /// instance of the data-provider
   18|       |    @objc open weak var chart: ChartDataProvider?
   19|       |    
   20|       |    @objc public init(chart: ChartDataProvider)
   21|      0|    {
   22|      0|        self.chart = chart
   23|      0|    }
   24|       |    
   25|       |    open func getHighlight(x: CGFloat, y: CGFloat) -> Highlight?
   26|      0|    {
   27|      0|        let xVal = Double(getValsForTouch(x: x, y: y).x)
   28|      0|        return getHighlight(xValue: xVal, x: x, y: y)
   29|      0|    }
   30|       |    
   31|       |    /// - Parameters:
   32|       |    ///   - x:
   33|       |    /// - Returns: The corresponding x-pos for a given touch-position in pixels.
   34|       |    @objc open func getValsForTouch(x: CGFloat, y: CGFloat) -> CGPoint
   35|      0|    {
   36|      0|        guard let chart = self.chart as? BarLineScatterCandleBubbleChartDataProvider else { return .zero }
   37|      0|        
   38|      0|        // take any transformer to determine the values
   39|      0|        return chart.getTransformer(forAxis: .left).valueForTouchPoint(x: x, y: y)
   40|      0|    }
   41|       |    
   42|       |    /// - Parameters:
   43|       |    ///   - xValue:
   44|       |    ///   - x:
   45|       |    ///   - y:
   46|       |    /// - Returns: The corresponding ChartHighlight for a given x-value and xy-touch position in pixels.
   47|       |    @objc open func getHighlight(xValue xVal: Double, x: CGFloat, y: CGFloat) -> Highlight?
   48|      0|    {
   49|      0|        guard let chart = chart else { return nil }
   50|      0|        
   51|      0|        let closestValues = getHighlights(xValue: xVal, x: x, y: y)
   52|      0|        guard !closestValues.isEmpty else { return nil }
   53|      0|        
   54|      0|        let leftAxisMinDist = getMinimumDistance(closestValues: closestValues, y: y, axis: .left)
   55|      0|        let rightAxisMinDist = getMinimumDistance(closestValues: closestValues, y: y, axis: .right)
   56|      0|        
   57|      0|        let axis: YAxis.AxisDependency = leftAxisMinDist < rightAxisMinDist ? .left : .right
   58|      0|        
   59|      0|        let detail = closestSelectionDetailByPixel(closestValues: closestValues, x: x, y: y, axis: axis, minSelectionDistance: chart.maxHighlightDistance)
   60|      0|        
   61|      0|        return detail
   62|      0|    }
   63|       |    
   64|       |    /// - Parameters:
   65|       |    ///   - xValue: the transformed x-value of the x-touch position
   66|       |    ///   - x: touch position
   67|       |    ///   - y: touch position
   68|       |    /// - Returns: A list of Highlight objects representing the entries closest to the given xVal.
   69|       |    /// The returned list contains two objects per DataSet (closest rounding up, closest rounding down).
   70|       |    @objc open func getHighlights(xValue: Double, x: CGFloat, y: CGFloat) -> [Highlight]
   71|      0|    {
   72|      0|        var vals = [Highlight]()
   73|      0|        
   74|      0|        guard let data = self.data else { return vals }
   75|      0|        
   76|      0|        for i in 0 ..< data.dataSetCount
   77|      0|        {
   78|      0|            guard
   79|      0|                let dataSet = data.getDataSetByIndex(i),
   80|      0|                dataSet.isHighlightEnabled      // don't include datasets that cannot be highlighted
   81|      0|                else { continue }
   82|      0|            
   83|      0|
   84|      0|            // extract all y-values from all DataSets at the given x-value.
   85|      0|            // some datasets (i.e bubble charts) make sense to have multiple values for an x-value. We'll have to find a way to handle that later on. It's more complicated now when x-indices are floating point.
   86|      0|            vals.append(contentsOf: buildHighlights(dataSet: dataSet, dataSetIndex: i, xValue: xValue, rounding: .closest))
   87|      0|        }
   88|      0|        
   89|      0|        return vals
   90|      0|    }
   91|       |    
   92|       |    /// - Returns: An array of `Highlight` objects corresponding to the selected xValue and dataSetIndex.
   93|       |    internal func buildHighlights(
   94|       |        dataSet set: IChartDataSet,
   95|       |        dataSetIndex: Int,
   96|       |        xValue: Double,
   97|       |        rounding: ChartDataSetRounding) -> [Highlight]
   98|      0|    {
   99|      0|        guard let chart = self.chart as? BarLineScatterCandleBubbleChartDataProvider else { return [] }
  100|      0|        
  101|      0|        var entries = set.entriesForXValue(xValue)
  102|      0|        if entries.count == 0, let closest = set.entryForXValue(xValue, closestToY: .nan, rounding: rounding)
  103|      0|        {
  104|      0|            // Try to find closest x-value and take all entries for that x-value
  105|      0|            entries = set.entriesForXValue(closest.x)
  106|      0|        }
  107|      0|
  108|      0|        return entries.map { e in
  109|      0|            let px = chart.getTransformer(forAxis: set.axisDependency)
  110|      0|                .pixelForValues(x: e.x, y: e.y)
  111|      0|            
  112|      0|            return Highlight(x: e.x, y: e.y, xPx: px.x, yPx: px.y, dataSetIndex: dataSetIndex, axis: set.axisDependency)
  113|      0|        }
  114|      0|    }
  115|       |
  116|       |    // - MARK: - Utilities
  117|       |    
  118|       |    /// - Returns: The `ChartHighlight` of the closest value on the x-y cartesian axes
  119|       |    internal func closestSelectionDetailByPixel(
  120|       |        closestValues: [Highlight],
  121|       |        x: CGFloat,
  122|       |        y: CGFloat,
  123|       |        axis: YAxis.AxisDependency?,
  124|       |        minSelectionDistance: CGFloat) -> Highlight?
  125|      0|    {
  126|      0|        var distance = minSelectionDistance
  127|      0|        var closest: Highlight?
  128|      0|        
  129|      0|        for high in closestValues
  130|      0|        {
  131|      0|            if axis == nil || high.axis == axis
  132|      0|            {
  133|      0|                let cDistance = getDistance(x1: x, y1: y, x2: high.xPx, y2: high.yPx)
  134|      0|
  135|      0|                if cDistance < distance
  136|      0|                {
  137|      0|                    closest = high
  138|      0|                    distance = cDistance
  139|      0|                }
  140|      0|            }
  141|      0|        }
  142|      0|        
  143|      0|        return closest
  144|      0|    }
  145|       |    
  146|       |    /// - Returns: The minimum distance from a touch-y-value (in pixels) to the closest y-value (in pixels) that is displayed in the chart.
  147|       |    internal func getMinimumDistance(
  148|       |        closestValues: [Highlight],
  149|       |        y: CGFloat,
  150|       |        axis: YAxis.AxisDependency
  151|      0|    ) -> CGFloat {
  152|      0|        var distance = CGFloat.greatestFiniteMagnitude
  153|      0|        
  154|      0|        for high in closestValues where high.axis == axis
  155|      0|        {
  156|      0|            let tempDistance = abs(getHighlightPos(high: high) - y)
  157|      0|            if tempDistance < distance
  158|      0|            {
  159|      0|                distance = tempDistance
  160|      0|            }
  161|      0|        }
  162|      0|        
  163|      0|        return distance
  164|      0|    }
  165|       |    
  166|       |    internal func getHighlightPos(high: Highlight) -> CGFloat
  167|      0|    {
  168|      0|        return high.yPx
  169|      0|    }
  170|       |    
  171|       |    internal func getDistance(x1: CGFloat, y1: CGFloat, x2: CGFloat, y2: CGFloat) -> CGFloat
  172|      0|    {
  173|      0|        return hypot(x1 - x2, y1 - y2)
  174|      0|    }
  175|       |    
  176|       |    internal var data: ChartData?
  177|      0|    {
  178|      0|        return chart?.data
  179|      0|    }
  180|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/CombinedHighlighter.swift:
    1|       |//
    2|       |//  CombinedHighlighter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(CombinedChartHighlighter)
   16|       |open class CombinedHighlighter: ChartHighlighter
   17|       |{
   18|       |    /// bar highlighter for supporting stacked highlighting
   19|       |    private var barHighlighter: BarHighlighter?
   20|       |    
   21|       |    @objc public init(chart: CombinedChartDataProvider, barDataProvider: BarChartDataProvider)
   22|      0|    {
   23|      0|        super.init(chart: chart)
   24|      0|        
   25|      0|        // if there is BarData, create a BarHighlighter
   26|      0|        self.barHighlighter = barDataProvider.barData == nil ? nil : BarHighlighter(chart: barDataProvider)
   27|      0|    }
   28|       |    
   29|       |    open override func getHighlights(xValue: Double, x: CGFloat, y: CGFloat) -> [Highlight]
   30|      0|    {
   31|      0|        var vals = [Highlight]()
   32|      0|        
   33|      0|        guard
   34|      0|            let chart = self.chart as? CombinedChartDataProvider,
   35|      0|            let dataObjects = chart.combinedData?.allData
   36|      0|            else { return vals }
   37|      0|        
   38|      0|        for i in 0..<dataObjects.count
   39|      0|        {
   40|      0|            let dataObject = dataObjects[i]
   41|      0|
   42|      0|            // in case of BarData, let the BarHighlighter take over
   43|      0|            if barHighlighter != nil && dataObject is BarChartData,
   44|      0|                let high = barHighlighter?.getHighlight(x: x, y: y)
   45|      0|            {
   46|      0|                high.dataIndex = i
   47|      0|                vals.append(high)
   48|      0|            }
   49|      0|            else
   50|      0|            {
   51|      0|                for j in 0..<dataObject.dataSetCount
   52|      0|                {
   53|      0|                    guard let dataSet = dataObject.getDataSetByIndex(j),
   54|      0|                        dataSet.isHighlightEnabled      // don't include datasets that cannot be highlighted
   55|      0|                        else { continue }
   56|      0|
   57|      0|                    let highs = buildHighlights(dataSet: dataSet, dataSetIndex: j, xValue: xValue, rounding: .closest)
   58|      0|
   59|      0|                    for high in highs
   60|      0|                    {
   61|      0|                        high.dataIndex = i
   62|      0|                        vals.append(high)
   63|      0|                    }
   64|      0|                }
   65|      0|            }
   66|      0|        }
   67|      0|        
   68|      0|        return vals
   69|      0|    }
   70|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/Highlight.swift:
    1|       |//
    2|       |//  Highlight.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartHighlight)
   16|       |open class Highlight: NSObject
   17|       |{
   18|       |    /// the x-value of the highlighted value
   19|      0|    fileprivate var _x = Double.nan
   20|       |    
   21|       |    /// the y-value of the highlighted value
   22|      0|    fileprivate var _y = Double.nan
   23|       |    
   24|       |    /// the x-pixel of the highlight
   25|      0|    private var _xPx = CGFloat.nan
   26|       |    
   27|       |    /// the y-pixel of the highlight
   28|      0|    private var _yPx = CGFloat.nan
   29|       |    
   30|       |    /// the index of the data object - in case it refers to more than one
   31|      0|    @objc open var dataIndex = Int(-1)
   32|       |    
   33|       |    /// the index of the dataset the highlighted value is in
   34|      0|    fileprivate var _dataSetIndex = Int(0)
   35|       |    
   36|       |    /// index which value of a stacked bar entry is highlighted
   37|       |    /// 
   38|       |    /// **default**: -1
   39|      0|    fileprivate var _stackIndex = Int(-1)
   40|       |    
   41|       |    /// the axis the highlighted value belongs to
   42|      0|    private var _axis: YAxis.AxisDependency = YAxis.AxisDependency.left
   43|       |    
   44|       |    /// the x-position (pixels) on which this highlight object was last drawn
   45|       |    @objc open var drawX: CGFloat = 0.0
   46|       |    
   47|       |    /// the y-position (pixels) on which this highlight object was last drawn
   48|       |    @objc open var drawY: CGFloat = 0.0
   49|       |    
   50|       |    public override init()
   51|      0|    {
   52|      0|        super.init()
   53|      0|    }
   54|       |    
   55|       |    /// - Parameters:
   56|       |    ///   - x: the x-value of the highlighted value
   57|       |    ///   - y: the y-value of the highlighted value
   58|       |    ///   - xPx: the x-pixel of the highlighted value
   59|       |    ///   - yPx: the y-pixel of the highlighted value
   60|       |    ///   - dataIndex: the index of the Data the highlighted value belongs to
   61|       |    ///   - dataSetIndex: the index of the DataSet the highlighted value belongs to
   62|       |    ///   - stackIndex: references which value of a stacked-bar entry has been selected
   63|       |    ///   - axis: the axis the highlighted value belongs to
   64|       |    @objc public init(
   65|       |        x: Double, y: Double,
   66|       |        xPx: CGFloat, yPx: CGFloat,
   67|       |        dataIndex: Int,
   68|       |        dataSetIndex: Int,
   69|       |        stackIndex: Int,
   70|       |        axis: YAxis.AxisDependency)
   71|      0|    {
   72|      0|        super.init()
   73|      0|        
   74|      0|        _x = x
   75|      0|        _y = y
   76|      0|        _xPx = xPx
   77|      0|        _yPx = yPx
   78|      0|        self.dataIndex = dataIndex
   79|      0|        _dataSetIndex = dataSetIndex
   80|      0|        _stackIndex = stackIndex
   81|      0|        _axis = axis
   82|      0|    }
   83|       |    
   84|       |    /// - Parameters:
   85|       |    ///   - x: the x-value of the highlighted value
   86|       |    ///   - y: the y-value of the highlighted value
   87|       |    ///   - xPx: the x-pixel of the highlighted value
   88|       |    ///   - yPx: the y-pixel of the highlighted value
   89|       |    ///   - dataSetIndex: the index of the DataSet the highlighted value belongs to
   90|       |    ///   - stackIndex: references which value of a stacked-bar entry has been selected
   91|       |    ///   - axis: the axis the highlighted value belongs to
   92|       |    @objc public convenience init(
   93|       |        x: Double, y: Double,
   94|       |        xPx: CGFloat, yPx: CGFloat,
   95|       |        dataSetIndex: Int,
   96|       |        stackIndex: Int,
   97|       |        axis: YAxis.AxisDependency)
   98|      0|    {
   99|      0|        self.init(x: x, y: y, xPx: xPx, yPx: yPx,
  100|      0|                  dataIndex: 0,
  101|      0|                  dataSetIndex: dataSetIndex,
  102|      0|                  stackIndex: stackIndex,
  103|      0|                  axis: axis)
  104|      0|    }
  105|       |    
  106|       |    /// - Parameters:
  107|       |    ///   - x: the x-value of the highlighted value
  108|       |    ///   - y: the y-value of the highlighted value
  109|       |    ///   - xPx: the x-pixel of the highlighted value
  110|       |    ///   - yPx: the y-pixel of the highlighted value
  111|       |    ///   - dataIndex: the index of the Data the highlighted value belongs to
  112|       |    ///   - dataSetIndex: the index of the DataSet the highlighted value belongs to
  113|       |    ///   - stackIndex: references which value of a stacked-bar entry has been selected
  114|       |    ///   - axis: the axis the highlighted value belongs to
  115|       |    @objc public init(
  116|       |        x: Double, y: Double,
  117|       |        xPx: CGFloat, yPx: CGFloat,
  118|       |        dataSetIndex: Int,
  119|       |        axis: YAxis.AxisDependency)
  120|      0|    {
  121|      0|        super.init()
  122|      0|        
  123|      0|        _x = x
  124|      0|        _y = y
  125|      0|        _xPx = xPx
  126|      0|        _yPx = yPx
  127|      0|        _dataSetIndex = dataSetIndex
  128|      0|        _axis = axis
  129|      0|    }
  130|       |    
  131|       |    /// - Parameters:
  132|       |    ///   - x: the x-value of the highlighted value
  133|       |    ///   - y: the y-value of the highlighted value
  134|       |    ///   - dataSetIndex: the index of the DataSet the highlighted value belongs to
  135|       |    ///   - dataIndex: The data index to search in (only used in CombinedChartView currently)
  136|       |    @objc public init(x: Double, y: Double, dataSetIndex: Int, dataIndex: Int = -1)
  137|      0|    {
  138|      0|        _x = x
  139|      0|        _y = y
  140|      0|        _dataSetIndex = dataSetIndex
  141|      0|        self.dataIndex = dataIndex
  142|      0|    }
  143|       |    
  144|       |    /// - Parameters:
  145|       |    ///   - x: the x-value of the highlighted value
  146|       |    ///   - dataSetIndex: the index of the DataSet the highlighted value belongs to
  147|       |    ///   - stackIndex: references which value of a stacked-bar entry has been selected
  148|       |    @objc public convenience init(x: Double, dataSetIndex: Int, stackIndex: Int)
  149|      0|    {
  150|      0|        self.init(x: x, y: Double.nan, dataSetIndex: dataSetIndex)
  151|      0|        _stackIndex = stackIndex
  152|      0|    }
  153|       |    
  154|      0|    @objc open var x: Double { return _x }
  155|      0|    @objc open var y: Double { return _y }
  156|      0|    @objc open var xPx: CGFloat { return _xPx }
  157|      0|    @objc open var yPx: CGFloat { return _yPx }
  158|      0|    @objc open var dataSetIndex: Int { return _dataSetIndex }
  159|      0|    @objc open var stackIndex: Int { return _stackIndex }
  160|      0|    @objc open var axis: YAxis.AxisDependency { return _axis }
  161|       |    
  162|      0|    @objc open var isStacked: Bool { return _stackIndex >= 0 }
  163|       |    
  164|       |    /// Sets the x- and y-position (pixels) where this highlight was last drawn.
  165|       |    @objc open func setDraw(x: CGFloat, y: CGFloat)
  166|      0|    {
  167|      0|        self.drawX = x
  168|      0|        self.drawY = y
  169|      0|    }
  170|       |    
  171|       |    /// Sets the x- and y-position (pixels) where this highlight was last drawn.
  172|       |    @objc open func setDraw(pt: CGPoint)
  173|      0|    {
  174|      0|        self.drawX = pt.x
  175|      0|        self.drawY = pt.y
  176|      0|    }
  177|       |
  178|       |    // MARK: NSObject
  179|       |    
  180|       |    open override var description: String
  181|      0|    {
  182|      0|        return "Highlight, x: \(_x), y: \(_y), dataIndex (combined charts): \(dataIndex), dataSetIndex: \(_dataSetIndex), stackIndex (only stacked barentry): \(_stackIndex)"
  183|      0|    }
  184|       |}
  185|       |
  186|       |
  187|       |// MARK: Equatable
  188|       |extension Highlight /*: Equatable*/ {
  189|      0|    open override func isEqual(_ object: Any?) -> Bool {
  190|      0|        guard let object = object as? Highlight else { return false }
  191|      0|
  192|      0|        if self === object
  193|      0|        {
  194|      0|            return true
  195|      0|        }
  196|      0|
  197|      0|        return _x == object._x
  198|      0|            && _y == object._y
  199|      0|            && dataIndex == object.dataIndex
  200|      0|            && _dataSetIndex == object._dataSetIndex
  201|      0|            && _stackIndex == object._stackIndex
  202|      0|    }
  203|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/HorizontalBarHighlighter.swift:
    1|       |//
    2|       |//  HorizontalBarHighlighter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(HorizontalBarChartHighlighter)
   16|       |open class HorizontalBarHighlighter: BarHighlighter
   17|       |{
   18|       |    open override func getHighlight(x: CGFloat, y: CGFloat) -> Highlight?
   19|      0|    {
   20|      0|        guard let barData = self.chart?.data as? BarChartData else { return nil }
   21|      0|
   22|      0|        let pos = getValsForTouch(x: y, y: x)
   23|      0|        guard let high = getHighlight(xValue: Double(pos.y), x: y, y: x) else { return nil }
   24|      0|
   25|      0|        if let set = barData.getDataSetByIndex(high.dataSetIndex) as? IBarChartDataSet,
   26|      0|            set.isStacked
   27|      0|        {
   28|      0|            return getStackedHighlight(high: high,
   29|      0|                                       set: set,
   30|      0|                                       xValue: Double(pos.y),
   31|      0|                                       yValue: Double(pos.x))
   32|      0|        }
   33|      0|
   34|      0|        return high
   35|      0|    }
   36|       |    
   37|       |    internal override func buildHighlights(
   38|       |        dataSet set: IChartDataSet,
   39|       |        dataSetIndex: Int,
   40|       |        xValue: Double,
   41|       |        rounding: ChartDataSetRounding) -> [Highlight]
   42|      0|    {
   43|      0|        guard let chart = self.chart as? BarLineScatterCandleBubbleChartDataProvider else { return [] }
   44|      0|        
   45|      0|        var entries = set.entriesForXValue(xValue)
   46|      0|        if entries.count == 0, let closest = set.entryForXValue(xValue, closestToY: .nan, rounding: rounding)
   47|      0|        {
   48|      0|            // Try to find closest x-value and take all entries for that x-value
   49|      0|            entries = set.entriesForXValue(closest.x)
   50|      0|        }
   51|      0|
   52|      0|        return entries.map { e in
   53|      0|            let px = chart.getTransformer(forAxis: set.axisDependency)
   54|      0|                .pixelForValues(x: e.y, y: e.x)
   55|      0|            return Highlight(x: e.x, y: e.y, xPx: px.x, yPx: px.y, dataSetIndex: dataSetIndex, axis: set.axisDependency)
   56|      0|        }
   57|      0|    }
   58|       |    
   59|       |    internal override func getDistance(x1: CGFloat, y1: CGFloat, x2: CGFloat, y2: CGFloat) -> CGFloat
   60|      0|    {
   61|      0|        return abs(y1 - y2)
   62|      0|    }
   63|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/PieHighlighter.swift:
    1|       |//
    2|       |//  PieHighlighter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(PieChartHighlighter)
   16|       |open class PieHighlighter: PieRadarHighlighter
   17|       |{
   18|       |    open override func closestHighlight(index: Int, x: CGFloat, y: CGFloat) -> Highlight?
   19|      0|    {
   20|      0|        guard
   21|      0|            let set = chart?.data?.dataSets[0],
   22|      0|            let entry = set.entryForIndex(index)
   23|      0|            else { return nil }
   24|      0|                
   25|      0|        return Highlight(x: Double(index), y: entry.y, xPx: x, yPx: y, dataSetIndex: 0, axis: set.axisDependency)
   26|      0|    }
   27|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/PieRadarHighlighter.swift:
    1|       |//
    2|       |//  PieRadarHighlighter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(PieRadarChartHighlighter)
   16|       |open class PieRadarHighlighter: ChartHighlighter
   17|       |{    
   18|       |    open override func getHighlight(x: CGFloat, y: CGFloat) -> Highlight?
   19|      0|    {
   20|      0|        guard let chart = self.chart as? PieRadarChartViewBase else { return nil }
   21|      0|        
   22|      0|        let touchDistanceToCenter = chart.distanceToCenter(x: x, y: y)
   23|      0|        
   24|      0|        // check if a slice was touched
   25|      0|        guard touchDistanceToCenter <= chart.radius else
   26|      0|        {
   27|      0|            // if no slice was touched, highlight nothing
   28|      0|            return nil
   29|      0|        }
   30|      0|
   31|      0|        var angle = chart.angleForPoint(x: x ,y: y)
   32|      0|
   33|      0|        if chart is PieChartView
   34|      0|        {
   35|      0|            angle /= CGFloat(chart.chartAnimator.phaseY)
   36|      0|        }
   37|      0|
   38|      0|        let index = chart.indexForAngle(angle)
   39|      0|
   40|      0|        // check if the index could be found
   41|      0|        if index < 0 || index >= chart.data?.maxEntryCountSet?.entryCount ?? 0
   42|      0|        {
   43|      0|            return nil
   44|      0|        }
   45|      0|        else
   46|      0|        {
   47|      0|            return closestHighlight(index: index, x: x, y: y)
   48|      0|        }
   49|      0|
   50|      0|    }
   51|       |    
   52|       |    /// - Parameters:
   53|       |    ///   - index:
   54|       |    ///   - x:
   55|       |    ///   - y:
   56|       |    /// - Returns: The closest Highlight object of the given objects based on the touch position inside the chart.
   57|       |    @objc open func closestHighlight(index: Int, x: CGFloat, y: CGFloat) -> Highlight?
   58|      0|    {
   59|      0|        fatalError("closestHighlight(index, x, y) cannot be called on PieRadarChartHighlighter")
   60|      0|    }
   61|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/RadarHighlighter.swift:
    1|       |//
    2|       |//  RadarHighlighter.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(RadarChartHighlighter)
   16|       |open class RadarHighlighter: PieRadarHighlighter
   17|       |{
   18|       |    open override func closestHighlight(index: Int, x: CGFloat, y: CGFloat) -> Highlight?
   19|      0|    {
   20|      0|        guard let chart = self.chart as? RadarChartView else { return nil }
   21|      0|        
   22|      0|        let highlights = getHighlights(forIndex: index)
   23|      0|        
   24|      0|        let distanceToCenter = Double(chart.distanceToCenter(x: x, y: y) / chart.factor)
   25|      0|        
   26|      0|        var closest: Highlight?
   27|      0|        var distance = Double.greatestFiniteMagnitude
   28|      0|        
   29|      0|        for high in highlights
   30|      0|        {
   31|      0|            let cdistance = abs(high.y - distanceToCenter)
   32|      0|            if cdistance < distance
   33|      0|            {
   34|      0|                closest = high
   35|      0|                distance = cdistance
   36|      0|            }
   37|      0|        }
   38|      0|        
   39|      0|        return closest
   40|      0|    }
   41|       |    
   42|       |    /// - Parameters:
   43|       |    ///   - index:
   44|       |    /// - Returns: An array of Highlight objects for the given index.
   45|       |    /// The Highlight objects give information about the value at the selected index and DataSet it belongs to.
   46|       |    internal func getHighlights(forIndex index: Int) -> [Highlight]
   47|      0|    {
   48|      0|        var vals = [Highlight]()
   49|      0|        
   50|      0|        guard
   51|      0|            let chart = self.chart as? RadarChartView,
   52|      0|            let chartData = chart.data
   53|      0|            else { return vals }
   54|      0|        
   55|      0|        let phaseX = chart.chartAnimator.phaseX
   56|      0|        let phaseY = chart.chartAnimator.phaseY
   57|      0|        let sliceangle = chart.sliceAngle
   58|      0|        let factor = chart.factor
   59|      0|
   60|      0|        for i in chartData.dataSets.indices
   61|      0|        {
   62|      0|            guard
   63|      0|                let dataSet = chartData.getDataSetByIndex(i),
   64|      0|                let entry = dataSet.entryForIndex(index)
   65|      0|                else { continue }
   66|      0|            
   67|      0|            let y = (entry.y - chart.chartYMin)
   68|      0|            
   69|      0|            let p = chart.centerOffsets.moving(distance: CGFloat(y) * factor * CGFloat(phaseY),
   70|      0|                                               atAngle: sliceangle * CGFloat(index) * CGFloat(phaseX) + chart.rotationAngle)
   71|      0|
   72|      0|            let highlight = Highlight(x: Double(index), y: entry.y, xPx: p.x, yPx: p.y, dataSetIndex: i, axis: dataSet.axisDependency)
   73|      0|            vals.append(highlight)
   74|      0|        }
   75|      0|        
   76|      0|        return vals
   77|      0|    }
   78|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Highlight/Range.swift:
    1|       |//
    2|       |//  Range.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |@objc(ChartRange)
   15|       |open class Range: NSObject
   16|       |{
   17|       |    @objc open var from: Double
   18|       |    @objc open var to: Double
   19|       |    
   20|       |    @objc public init(from: Double, to: Double)
   21|      0|    {
   22|      0|        self.from = from
   23|      0|        self.to = to
   24|      0|        
   25|      0|        super.init()
   26|      0|    }
   27|       |
   28|       |    /// - Parameters:
   29|       |    ///   - value:
   30|       |    /// - Returns: `true` if this range contains (if the value is in between) the given value, `false` ifnot.
   31|       |    @objc open func contains(_ value: Double) -> Bool
   32|      0|    {
   33|      0|        if value > from && value <= to
   34|      0|        {
   35|      0|            return true
   36|      0|        }
   37|      0|        else
   38|      0|        {
   39|      0|            return false
   40|      0|        }
   41|      0|    }
   42|       |    
   43|       |    @objc open func isLarger(_ value: Double) -> Bool
   44|      0|    {
   45|      0|        return value > to
   46|      0|    }
   47|       |    
   48|       |    @objc open func isSmaller(_ value: Double) -> Bool
   49|      0|    {
   50|      0|        return value < from
   51|      0|    }
   52|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Jobs/AnimatedMoveViewJob.swift:
    1|       |//
    2|       |//  AnimatedMoveViewJob.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class AnimatedMoveViewJob: AnimatedViewPortJob
   16|       |{
   17|       |    internal override func animationUpdate()
   18|      0|    {
   19|      0|        guard
   20|      0|            let viewPortHandler = viewPortHandler,
   21|      0|            let transformer = transformer,
   22|      0|            let view = view
   23|      0|            else { return }
   24|      0|        
   25|      0|        var pt = CGPoint(
   26|      0|            x: xOrigin + (CGFloat(xValue) - xOrigin) * phase,
   27|      0|            y: yOrigin + (CGFloat(yValue) - yOrigin) * phase
   28|      0|        )
   29|      0|        
   30|      0|        transformer.pointValueToPixel(&pt)
   31|      0|        viewPortHandler.centerViewPort(pt: pt, chart: view)
   32|      0|    }
   33|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Jobs/AnimatedViewPortJob.swift:
    1|       |//
    2|       |//  AnimatedViewPortJob.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |import QuartzCore
   15|       |
   16|       |open class AnimatedViewPortJob: ViewPortJob
   17|       |{
   18|       |    internal var phase: CGFloat = 1.0
   19|       |    internal var xOrigin: CGFloat = 0.0
   20|       |    internal var yOrigin: CGFloat = 0.0
   21|       |    
   22|       |    private var _startTime: TimeInterval = 0.0
   23|       |    private var _displayLink: NSUIDisplayLink!
   24|       |    private var _duration: TimeInterval = 0.0
   25|       |    private var _endTime: TimeInterval = 0.0
   26|       |    
   27|       |    private var _easing: ChartEasingFunctionBlock?
   28|       |    
   29|       |    @objc public init(
   30|       |        viewPortHandler: ViewPortHandler,
   31|       |        xValue: Double,
   32|       |        yValue: Double,
   33|       |        transformer: Transformer,
   34|       |        view: ChartViewBase,
   35|       |        xOrigin: CGFloat,
   36|       |        yOrigin: CGFloat,
   37|       |        duration: TimeInterval,
   38|       |        easing: ChartEasingFunctionBlock?)
   39|      0|    {
   40|      0|        super.init(viewPortHandler: viewPortHandler,
   41|      0|            xValue: xValue,
   42|      0|            yValue: yValue,
   43|      0|            transformer: transformer,
   44|      0|            view: view)
   45|      0|        
   46|      0|        self.xOrigin = xOrigin
   47|      0|        self.yOrigin = yOrigin
   48|      0|        self._duration = duration
   49|      0|        self._easing = easing
   50|      0|    }
   51|       |    
   52|       |    deinit
   53|      0|    {
   54|      0|        stop(finish: false)
   55|      0|    }
   56|       |    
   57|       |    open override func doJob()
   58|      0|    {
   59|      0|        start()
   60|      0|    }
   61|       |    
   62|       |    @objc open func start()
   63|      0|    {
   64|      0|        _startTime = CACurrentMediaTime()
   65|      0|        _endTime = _startTime + _duration
   66|      0|        _endTime = _endTime > _endTime ? _endTime : _endTime
   67|      0|        
   68|      0|        updateAnimationPhase(_startTime)
   69|      0|        
   70|      0|        _displayLink = NSUIDisplayLink(target: self, selector: #selector(animationLoop))
   71|      0|        _displayLink.add(to: .main, forMode: RunLoop.Mode.common)
   72|      0|    }
   73|       |    
   74|       |    @objc open func stop(finish: Bool)
   75|      0|    {
   76|      0|        guard _displayLink != nil else { return }
   77|      0|
   78|      0|        _displayLink.remove(from: .main, forMode: RunLoop.Mode.common)
   79|      0|        _displayLink = nil
   80|      0|
   81|      0|        if finish
   82|      0|        {
   83|      0|            if phase != 1.0
   84|      0|            {
   85|      0|                phase = 1.0
   86|      0|                animationUpdate()
   87|      0|            }
   88|      0|
   89|      0|            animationEnd()
   90|      0|        }
   91|      0|    }
   92|       |    
   93|       |    private func updateAnimationPhase(_ currentTime: TimeInterval)
   94|      0|    {
   95|      0|        let elapsedTime = currentTime - _startTime
   96|      0|        let duration = _duration
   97|      0|        var elapsed = elapsedTime
   98|      0|
   99|      0|        elapsed = min(elapsed, duration)
  100|      0|
  101|      0|        phase = CGFloat(_easing?(elapsed, duration) ?? elapsed / duration)
  102|      0|    }
  103|       |    
  104|       |    @objc private func animationLoop()
  105|      0|    {
  106|      0|        let currentTime: TimeInterval = CACurrentMediaTime()
  107|      0|        
  108|      0|        updateAnimationPhase(currentTime)
  109|      0|        
  110|      0|        animationUpdate()
  111|      0|        
  112|      0|        if currentTime >= _endTime
  113|      0|        {
  114|      0|            stop(finish: true)
  115|      0|        }
  116|      0|    }
  117|       |    
  118|       |    internal func animationUpdate()
  119|      0|    {
  120|      0|       // Override this
  121|      0|    }
  122|       |    
  123|       |    internal func animationEnd()
  124|      0|    {
  125|      0|        // Override this
  126|      0|    }
  127|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Jobs/AnimatedZoomViewJob.swift:
    1|       |//
    2|       |//  AnimatedZoomViewJob.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class AnimatedZoomViewJob: AnimatedViewPortJob
   16|       |{
   17|       |    internal var yAxis: YAxis?
   18|       |    internal var xAxisRange: Double = 0.0
   19|       |    internal var scaleX: CGFloat = 0.0
   20|       |    internal var scaleY: CGFloat = 0.0
   21|       |    internal var zoomOriginX: CGFloat = 0.0
   22|       |    internal var zoomOriginY: CGFloat = 0.0
   23|       |    internal var zoomCenterX: CGFloat = 0.0
   24|       |    internal var zoomCenterY: CGFloat = 0.0
   25|       |
   26|       |    @objc public init(
   27|       |        viewPortHandler: ViewPortHandler,
   28|       |        transformer: Transformer,
   29|       |        view: ChartViewBase,
   30|       |        yAxis: YAxis,
   31|       |        xAxisRange: Double,
   32|       |        scaleX: CGFloat,
   33|       |        scaleY: CGFloat,
   34|       |        xOrigin: CGFloat,
   35|       |        yOrigin: CGFloat,
   36|       |        zoomCenterX: CGFloat,
   37|       |        zoomCenterY: CGFloat,
   38|       |        zoomOriginX: CGFloat,
   39|       |        zoomOriginY: CGFloat,
   40|       |        duration: TimeInterval,
   41|       |        easing: ChartEasingFunctionBlock?)
   42|      0|    {
   43|      0|        super.init(viewPortHandler: viewPortHandler,
   44|      0|            xValue: 0.0,
   45|      0|            yValue: 0.0,
   46|      0|            transformer: transformer,
   47|      0|            view: view,
   48|      0|            xOrigin: xOrigin,
   49|      0|            yOrigin: yOrigin,
   50|      0|            duration: duration,
   51|      0|            easing: easing)
   52|      0|        
   53|      0|        self.yAxis = yAxis
   54|      0|        self.xAxisRange = xAxisRange
   55|      0|        self.scaleX = scaleX
   56|      0|        self.scaleY = scaleY
   57|      0|        self.zoomCenterX = zoomCenterX
   58|      0|        self.zoomCenterY = zoomCenterY
   59|      0|        self.zoomOriginX = zoomOriginX
   60|      0|        self.zoomOriginY = zoomOriginY
   61|      0|    }
   62|       |    
   63|       |    internal override func animationUpdate()
   64|      0|    {
   65|      0|        guard
   66|      0|            let viewPortHandler = viewPortHandler,
   67|      0|            let transformer = transformer,
   68|      0|            let view = view
   69|      0|            else { return }
   70|      0|        
   71|      0|        let scaleX = xOrigin + (self.scaleX - xOrigin) * phase
   72|      0|        let scaleY = yOrigin + (self.scaleY - yOrigin) * phase
   73|      0|        
   74|      0|        var matrix = viewPortHandler.setZoom(scaleX: scaleX, scaleY: scaleY)
   75|      0|        viewPortHandler.refresh(newMatrix: matrix, chart: view, invalidate: false)
   76|      0|        
   77|      0|        let valsInView = CGFloat(yAxis?.axisRange ?? 0.0) / viewPortHandler.scaleY
   78|      0|        let xsInView = CGFloat(xAxisRange) / viewPortHandler.scaleX
   79|      0|        
   80|      0|        var pt = CGPoint(
   81|      0|            x: zoomOriginX + ((zoomCenterX - xsInView / 2.0) - zoomOriginX) * phase,
   82|      0|            y: zoomOriginY + ((zoomCenterY + valsInView / 2.0) - zoomOriginY) * phase
   83|      0|        )
   84|      0|        
   85|      0|        transformer.pointValueToPixel(&pt)
   86|      0|        
   87|      0|        matrix = viewPortHandler.translate(pt: pt)
   88|      0|        viewPortHandler.refresh(newMatrix: matrix, chart: view, invalidate: true)
   89|      0|    }
   90|       |    
   91|       |    internal override func animationEnd()
   92|      0|    {
   93|      0|        (view as? BarLineChartViewBase)?.calculateOffsets()
   94|      0|        view?.setNeedsDisplay()
   95|      0|    }
   96|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Jobs/MoveViewJob.swift:
    1|       |//
    2|       |//  MoveViewJob.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(MoveChartViewJob)
   16|       |open class MoveViewJob: ViewPortJob
   17|       |{    
   18|       |    open override func doJob()
   19|      0|    {
   20|      0|        guard
   21|      0|            let viewPortHandler = viewPortHandler,
   22|      0|            let transformer = transformer,
   23|      0|            let view = view
   24|      0|            else { return }
   25|      0|        
   26|      0|        var pt = CGPoint(
   27|      0|            x: xValue,
   28|      0|            y: yValue
   29|      0|        )
   30|      0|        
   31|      0|        transformer.pointValueToPixel(&pt)
   32|      0|        viewPortHandler.centerViewPort(pt: pt, chart: view)
   33|      0|    }
   34|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Jobs/ViewPortJob.swift:
    1|       |//
    2|       |//  ViewPortJob.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |// This defines a viewport modification job, used for delaying or animating viewport changes
   16|       |@objc(ChartViewPortJob)
   17|       |open class ViewPortJob: NSObject
   18|       |{
   19|      0|    internal var point: CGPoint = CGPoint()
   20|       |    internal weak var viewPortHandler: ViewPortHandler?
   21|       |    internal var xValue: Double = 0.0
   22|       |    internal var yValue: Double = 0.0
   23|       |    internal weak var transformer: Transformer?
   24|       |    internal weak var view: ChartViewBase?
   25|       |    
   26|       |    @objc public init(
   27|       |        viewPortHandler: ViewPortHandler,
   28|       |        xValue: Double,
   29|       |        yValue: Double,
   30|       |        transformer: Transformer,
   31|       |        view: ChartViewBase)
   32|      0|    {
   33|      0|        super.init()
   34|      0|        
   35|      0|        self.viewPortHandler = viewPortHandler
   36|      0|        self.xValue = xValue
   37|      0|        self.yValue = yValue
   38|      0|        self.transformer = transformer
   39|      0|        self.view = view
   40|      0|    }
   41|       |    
   42|       |    @objc open func doJob()
   43|      0|    {
   44|      0|        fatalError("`doJob()` must be overridden by subclasses")
   45|      0|    }
   46|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Jobs/ZoomViewJob.swift:
    1|       |//
    2|       |//  ZoomViewJob.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ZoomChartViewJob)
   16|       |open class ZoomViewJob: ViewPortJob
   17|       |{
   18|       |    internal var scaleX: CGFloat = 0.0
   19|       |    internal var scaleY: CGFloat = 0.0
   20|      0|    internal var axisDependency: YAxis.AxisDependency = .left
   21|       |    
   22|       |    @objc public init(
   23|       |        viewPortHandler: ViewPortHandler,
   24|       |        scaleX: CGFloat,
   25|       |        scaleY: CGFloat,
   26|       |        xValue: Double,
   27|       |        yValue: Double,
   28|       |        transformer: Transformer,
   29|       |        axis: YAxis.AxisDependency,
   30|       |        view: ChartViewBase)
   31|      0|    {
   32|      0|        super.init(
   33|      0|            viewPortHandler: viewPortHandler,
   34|      0|            xValue: xValue,
   35|      0|            yValue: yValue,
   36|      0|            transformer: transformer,
   37|      0|            view: view)
   38|      0|        
   39|      0|        self.scaleX = scaleX
   40|      0|        self.scaleY = scaleY
   41|      0|        self.axisDependency = axis
   42|      0|    }
   43|       |    
   44|       |    open override func doJob()
   45|      0|    {
   46|      0|        guard
   47|      0|            let viewPortHandler = viewPortHandler,
   48|      0|            let transformer = transformer,
   49|      0|            let view = view
   50|      0|            else { return }
   51|      0|        
   52|      0|        var matrix = viewPortHandler.setZoom(scaleX: scaleX, scaleY: scaleY)
   53|      0|        viewPortHandler.refresh(newMatrix: matrix, chart: view, invalidate: false)
   54|      0|        
   55|      0|        let yValsInView = (view as! BarLineChartViewBase).getAxis(axisDependency).axisRange / Double(viewPortHandler.scaleY)
   56|      0|        let xValsInView = (view as! BarLineChartViewBase).xAxis.axisRange / Double(viewPortHandler.scaleX)
   57|      0|        
   58|      0|        var pt = CGPoint(
   59|      0|            x: CGFloat(xValue - xValsInView / 2.0),
   60|      0|            y: CGFloat(yValue + yValsInView / 2.0)
   61|      0|        )
   62|      0|        
   63|      0|        transformer.pointValueToPixel(&pt)
   64|      0|        
   65|      0|        matrix = viewPortHandler.translate(pt: pt)
   66|      0|        viewPortHandler.refresh(newMatrix: matrix, chart: view, invalidate: false)
   67|      0|        
   68|      0|        (view as! BarLineChartViewBase).calculateOffsets()
   69|      0|        view.setNeedsDisplay()
   70|      0|    }
   71|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/AxisRendererBase.swift:
    1|       |//
    2|       |//  AxisRendererBase.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartAxisRendererBase)
   16|       |open class AxisRendererBase: Renderer
   17|       |{
   18|       |    /// base axis this axis renderer works with
   19|       |    @objc open var axis: AxisBase?
   20|       |    
   21|       |    /// transformer to transform values to screen pixels and return
   22|       |    @objc open var transformer: Transformer?
   23|       |
   24|       |    @objc public init(viewPortHandler: ViewPortHandler, transformer: Transformer?, axis: AxisBase?)
   25|      0|    {
   26|      0|        super.init(viewPortHandler: viewPortHandler)
   27|      0|        
   28|      0|        self.transformer = transformer
   29|      0|        self.axis = axis
   30|      0|    }
   31|       |    
   32|       |    /// Draws the axis labels on the specified context
   33|       |    @objc open func renderAxisLabels(context: CGContext)
   34|      0|    {
   35|      0|        fatalError("renderAxisLabels() cannot be called on AxisRendererBase")
   36|      0|    }
   37|       |    
   38|       |    /// Draws the grid lines belonging to the axis.
   39|       |    @objc open func renderGridLines(context: CGContext)
   40|      0|    {
   41|      0|        fatalError("renderGridLines() cannot be called on AxisRendererBase")
   42|      0|    }
   43|       |    
   44|       |    /// Draws the line that goes alongside the axis.
   45|       |    @objc open func renderAxisLine(context: CGContext)
   46|      0|    {
   47|      0|        fatalError("renderAxisLine() cannot be called on AxisRendererBase")
   48|      0|    }
   49|       |    
   50|       |    /// Draws the LimitLines associated with this axis to the screen.
   51|       |    @objc open func renderLimitLines(context: CGContext)
   52|      0|    {
   53|      0|        fatalError("renderLimitLines() cannot be called on AxisRendererBase")
   54|      0|    }
   55|       |    
   56|       |    /// Computes the axis values.
   57|       |    ///
   58|       |    /// - Parameters:
   59|       |    ///   - min: the minimum value in the data object for this axis
   60|       |    ///   - max: the maximum value in the data object for this axis
   61|       |    @objc open func computeAxis(min: Double, max: Double, inverted: Bool)
   62|      0|    {
   63|      0|        var min = min, max = max
   64|      0|        
   65|      0|        if let transformer = self.transformer
   66|      0|        {
   67|      0|            // calculate the starting and entry point of the y-labels (depending on zoom / contentrect bounds)
   68|      0|            if viewPortHandler.contentWidth > 10.0 && !viewPortHandler.isFullyZoomedOutY
   69|      0|            {
   70|      0|                let p1 = transformer.valueForTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
   71|      0|                let p2 = transformer.valueForTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentBottom))
   72|      0|                
   73|      0|                if !inverted
   74|      0|                {
   75|      0|                    min = Double(p2.y)
   76|      0|                    max = Double(p1.y)
   77|      0|                }
   78|      0|                else
   79|      0|                {
   80|      0|                    min = Double(p1.y)
   81|      0|                    max = Double(p2.y)
   82|      0|                }
   83|      0|            }
   84|      0|        }
   85|      0|        
   86|      0|        computeAxisValues(min: min, max: max)
   87|      0|    }
   88|       |    
   89|       |    /// Sets up the axis values. Computes the desired number of labels between the two given extremes.
   90|       |    @objc open func computeAxisValues(min: Double, max: Double)
   91|      0|    {
   92|      0|        guard let axis = self.axis else { return }
   93|      0|        
   94|      0|        let yMin = min
   95|      0|        let yMax = max
   96|      0|        
   97|      0|        let labelCount = axis.labelCount
   98|      0|        let range = abs(yMax - yMin)
   99|      0|        
  100|      0|        if labelCount == 0 || range <= 0 || range.isInfinite
  101|      0|        {
  102|      0|            axis.entries = [Double]()
  103|      0|            axis.centeredEntries = [Double]()
  104|      0|            return
  105|      0|        }
  106|      0|        
  107|      0|        // Find out how much spacing (in y value space) between axis values
  108|      0|        let rawInterval = range / Double(labelCount)
  109|      0|        var interval = rawInterval.roundedToNextSignficant()
  110|      0|        
  111|      0|        // If granularity is enabled, then do not allow the interval to go below specified granularity.
  112|      0|        // This is used to avoid repeated values when rounding values for display.
  113|      0|        if axis.granularityEnabled
  114|      0|        {
  115|      0|            interval = interval < axis.granularity ? axis.granularity : interval
  116|      0|        }
  117|      0|        
  118|      0|        // Normalize interval
  119|      0|        let intervalMagnitude = pow(10.0, Double(Int(log10(interval)))).roundedToNextSignficant()
  120|      0|        let intervalSigDigit = Int(interval / intervalMagnitude)
  121|      0|        if intervalSigDigit > 5
  122|      0|        {
  123|      0|            // Use one order of magnitude higher, to avoid intervals like 0.9 or 90
  124|      0|            // if it's 0.0 after floor(), we use the old value
  125|      0|            interval = floor(10.0 * intervalMagnitude) == 0.0 ? interval : floor(10.0 * intervalMagnitude)
  126|      0|        }
  127|      0|        
  128|      0|        var n = axis.centerAxisLabelsEnabled ? 1 : 0
  129|      0|        
  130|      0|        // force label count
  131|      0|        if axis.isForceLabelsEnabled
  132|      0|        {
  133|      0|            interval = Double(range) / Double(labelCount - 1)
  134|      0|            
  135|      0|            // Ensure stops contains at least n elements.
  136|      0|            axis.entries.removeAll(keepingCapacity: true)
  137|      0|            axis.entries.reserveCapacity(labelCount)
  138|      0|            
  139|      0|            var v = yMin
  140|      0|            
  141|      0|            for _ in 0 ..< labelCount
  142|      0|            {
  143|      0|                axis.entries.append(v)
  144|      0|                v += interval
  145|      0|            }
  146|      0|            
  147|      0|            n = labelCount
  148|      0|        }
  149|      0|        else
  150|      0|        {
  151|      0|            // no forced count
  152|      0|        
  153|      0|            var first = interval == 0.0 ? 0.0 : ceil(yMin / interval) * interval
  154|      0|            
  155|      0|            if axis.centerAxisLabelsEnabled
  156|      0|            {
  157|      0|                first -= interval
  158|      0|            }
  159|      0|            
  160|      0|            let last = interval == 0.0 ? 0.0 : (floor(yMax / interval) * interval).nextUp
  161|      0|            
  162|      0|            if interval != 0.0 && last != first
  163|      0|            {
  164|      0|                for _ in stride(from: first, through: last, by: interval)
  165|      0|                {
  166|      0|                    n += 1
  167|      0|                }
  168|      0|            }
  169|      0|            else if last == first && n == 0
  170|      0|            {
  171|      0|                n = 1
  172|      0|            }
  173|      0|
  174|      0|            // Ensure stops contains at least n elements.
  175|      0|            axis.entries.removeAll(keepingCapacity: true)
  176|      0|            axis.entries.reserveCapacity(labelCount)
  177|      0|            
  178|      0|            var f = first
  179|      0|            var i = 0
  180|      0|            while i < n
  181|      0|            {
  182|      0|                if f == 0.0
  183|      0|                {
  184|      0|                    // Fix for IEEE negative zero case (Where value == -0.0, and 0.0 == -0.0)
  185|      0|                    f = 0.0
  186|      0|                }
  187|      0|                
  188|      0|                axis.entries.append(Double(f))
  189|      0|                
  190|      0|                f += interval
  191|      0|                i += 1
  192|      0|            }
  193|      0|        }
  194|      0|        
  195|      0|        // set decimals
  196|      0|        if interval < 1
  197|      0|        {
  198|      0|            axis.decimals = Int(ceil(-log10(interval)))
  199|      0|        }
  200|      0|        else
  201|      0|        {
  202|      0|            axis.decimals = 0
  203|      0|        }
  204|      0|        
  205|      0|        if axis.centerAxisLabelsEnabled
  206|      0|        {
  207|      0|            axis.centeredEntries.reserveCapacity(n)
  208|      0|            axis.centeredEntries.removeAll()
  209|      0|            
  210|      0|            let offset: Double = interval / 2.0
  211|      0|            
  212|      0|            for i in 0 ..< n
  213|      0|            {
  214|      0|                axis.centeredEntries.append(axis.entries[i] + offset)
  215|      0|            }
  216|      0|        }
  217|      0|    }
  218|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/BarChartRenderer.swift:
    1|       |//
    2|       |//  BarChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |open class BarChartRenderer: BarLineScatterCandleBubbleRenderer
   24|       |{
   25|       |    /// A nested array of elements ordered logically (i.e not in visual/drawing order) for use with VoiceOver
   26|       |    ///
   27|       |    /// Its use is apparent when there are multiple data sets, since we want to read bars in left to right order,
   28|       |    /// irrespective of dataset. However, drawing is done per dataset, so using this array and then flattening it prevents us from needing to
   29|       |    /// re-render for the sake of accessibility.
   30|       |    ///
   31|       |    /// In practise, its structure is:
   32|       |    ///
   33|       |    /// ````
   34|       |    ///     [
   35|       |    ///      [dataset1 element1, dataset2 element1],
   36|       |    ///      [dataset1 element2, dataset2 element2],
   37|       |    ///      [dataset1 element3, dataset2 element3]
   38|       |    ///     ...
   39|       |    ///     ]
   40|       |    /// ````
   41|       |    /// This is done to provide numerical inference across datasets to a screenreader user, in the same way that a sighted individual
   42|       |    /// uses a multi-dataset bar chart.
   43|       |    ///
   44|       |    /// The ````internal```` specifier is to allow subclasses (HorizontalBar) to populate the same array
   45|       |    internal lazy var accessibilityOrderedElements: [[NSUIAccessibilityElement]] = accessibilityCreateEmptyOrderedElements()
   46|       |
   47|       |    private class Buffer
   48|       |    {
   49|       |        var rects = [CGRect]()
   50|       |    }
   51|       |    
   52|       |    @objc open weak var dataProvider: BarChartDataProvider?
   53|       |    
   54|       |    @objc public init(dataProvider: BarChartDataProvider, animator: Animator, viewPortHandler: ViewPortHandler)
   55|      0|    {
   56|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   57|      0|        
   58|      0|        self.dataProvider = dataProvider
   59|      0|    }
   60|       |    
   61|       |    // [CGRect] per dataset
   62|      0|    private var _buffers = [Buffer]()
   63|       |    
   64|       |    open override func initBuffers()
   65|      0|    {
   66|      0|        if let barData = dataProvider?.barData
   67|      0|        {
   68|      0|            // Matche buffers count to dataset count
   69|      0|            if _buffers.count != barData.dataSetCount
   70|      0|            {
   71|      0|                while _buffers.count < barData.dataSetCount
   72|      0|                {
   73|      0|                    _buffers.append(Buffer())
   74|      0|                }
   75|      0|                while _buffers.count > barData.dataSetCount
   76|      0|                {
   77|      0|                    _buffers.removeLast()
   78|      0|                }
   79|      0|            }
   80|      0|            
   81|      0|            for i in stride(from: 0, to: barData.dataSetCount, by: 1)
   82|      0|            {
   83|      0|                let set = barData.dataSets[i] as! IBarChartDataSet
   84|      0|                let size = set.entryCount * (set.isStacked ? set.stackSize : 1)
   85|      0|                if _buffers[i].rects.count != size
   86|      0|                {
   87|      0|                    _buffers[i].rects = [CGRect](repeating: CGRect(), count: size)
   88|      0|                }
   89|      0|            }
   90|      0|        }
   91|      0|        else
   92|      0|        {
   93|      0|            _buffers.removeAll()
   94|      0|        }
   95|      0|    }
   96|       |    
   97|       |    private func prepareBuffer(dataSet: IBarChartDataSet, index: Int)
   98|      0|    {
   99|      0|        guard
  100|      0|            let dataProvider = dataProvider,
  101|      0|            let barData = dataProvider.barData
  102|      0|            else { return }
  103|      0|        
  104|      0|        let barWidthHalf = barData.barWidth / 2.0
  105|      0|    
  106|      0|        let buffer = _buffers[index]
  107|      0|        var bufferIndex = 0
  108|      0|        let containsStacks = dataSet.isStacked
  109|      0|        
  110|      0|        let isInverted = dataProvider.isInverted(axis: dataSet.axisDependency)
  111|      0|        let phaseY = animator.phaseY
  112|      0|        var barRect = CGRect()
  113|      0|        var x: Double
  114|      0|        var y: Double
  115|      0|
  116|      0|        
  117|      0|        for i in stride(from: 0, to: min(Int(ceil(Double(dataSet.entryCount) * animator.phaseX)), dataSet.entryCount), by: 1)
  118|      0|        {
  119|      0|            guard let e = dataSet.entryForIndex(i) as? BarChartDataEntry else { continue }
  120|      0|            
  121|      0|            let vals = e.yValues
  122|      0|
  123|      0|            x = e.x
  124|      0|            y = e.y
  125|      0|
  126|      0|            if !containsStacks || vals == nil
  127|      0|            {
  128|      0|                let left = CGFloat(x - barWidthHalf)
  129|      0|                let right = CGFloat(x + barWidthHalf)
  130|      0|                var top = isInverted
  131|      0|                    ? (y <= 0.0 ? CGFloat(y) : 0)
  132|      0|                    : (y >= 0.0 ? CGFloat(y) : 0)
  133|      0|                var bottom = isInverted
  134|      0|                    ? (y >= 0.0 ? CGFloat(y) : 0)
  135|      0|                    : (y <= 0.0 ? CGFloat(y) : 0)
  136|      0|                
  137|      0|                /* When drawing each bar, the renderer actually draws each bar from 0 to the required value.
  138|      0|                 * This drawn bar is then clipped to the visible chart rect in BarLineChartViewBase's draw(rect:) using clipDataToContent.
  139|      0|                 * While this works fine when calculating the bar rects for drawing, it causes the accessibilityFrames to be oversized in some cases.
  140|      0|                 * This offset attempts to undo that unnecessary drawing when calculating barRects
  141|      0|                 *
  142|      0|                 * +---------------------------------------------------------------+---------------------------------------------------------------+
  143|      0|                 * |      Situation 1:  (!inverted && y >= 0)                      |      Situation 3:  (inverted && y >= 0)                       |
  144|      0|                 * |                                                               |                                                               |
  145|      0|                 * |        y ->           +--+       <- top                       |        0 -> ---+--+---+--+------   <- top                     |
  146|      0|                 * |                       |//|        } topOffset = y - max       |                |  |   |//|          } topOffset = min         |
  147|      0|                 * |      max -> +---------+--+----+  <- top - topOffset           |      min -> +--+--+---+--+----+    <- top + topOffset         |
  148|      0|                 * |             |  +--+   |//|    |                               |             |  |  |   |//|    |                               |
  149|      0|                 * |             |  |  |   |//|    |                               |             |  +--+   |//|    |                               |
  150|      0|                 * |             |  |  |   |//|    |                               |             |         |//|    |                               |
  151|      0|                 * |      min -> +--+--+---+--+----+  <- bottom + bottomOffset     |      max -> +---------+--+----+    <- bottom - bottomOffset   |
  152|      0|                 * |                |  |   |//|        } bottomOffset = min        |                       |//|          } bottomOffset = y - max  |
  153|      0|                 * |        0 -> ---+--+---+--+-----  <- bottom                    |        y ->           +--+         <- bottom                  |
  154|      0|                 * |                                                               |                                                               |
  155|      0|                 * +---------------------------------------------------------------+---------------------------------------------------------------+
  156|      0|                 * |      Situation 2:  (!inverted && y < 0)                       |      Situation 4:  (inverted && y < 0)                        |
  157|      0|                 * |                                                               |                                                               |
  158|      0|                 * |        0 -> ---+--+---+--+-----   <- top                      |        y ->           +--+         <- top                     |
  159|      0|                 * |                |  |   |//|         } topOffset = -max         |                       |//|          } topOffset = min - y     |
  160|      0|                 * |      max -> +--+--+---+--+----+   <- top - topOffset          |      min -> +---------+--+----+    <- top + topOffset         |
  161|      0|                 * |             |  |  |   |//|    |                               |             |  +--+   |//|    |                               |
  162|      0|                 * |             |  +--+   |//|    |                               |             |  |  |   |//|    |                               |
  163|      0|                 * |             |         |//|    |                               |             |  |  |   |//|    |                               |
  164|      0|                 * |      min -> +---------+--+----+   <- bottom + bottomOffset    |      max -> +--+--+---+--+----+    <- bottom - bottomOffset   |
  165|      0|                 * |                       |//|         } bottomOffset = min - y   |                |  |   |//|          } bottomOffset = -max     |
  166|      0|                 * |        y ->           +--+        <- bottom                   |        0 -> ---+--+---+--+-------  <- bottom                  |
  167|      0|                 * |                                                               |                                                               |
  168|      0|                 * +---------------------------------------------------------------+---------------------------------------------------------------+
  169|      0|                 */
  170|      0|                var topOffset: CGFloat = 0.0
  171|      0|                var bottomOffset: CGFloat = 0.0
  172|      0|                if let offsetView = dataProvider as? BarChartView
  173|      0|                {
  174|      0|                    let offsetAxis = offsetView.getAxis(dataSet.axisDependency)
  175|      0|                    if y >= 0
  176|      0|                    {
  177|      0|                        // situation 1
  178|      0|                        if offsetAxis.axisMaximum < y
  179|      0|                        {
  180|      0|                            topOffset = CGFloat(y - offsetAxis.axisMaximum)
  181|      0|                        }
  182|      0|                        if offsetAxis.axisMinimum > 0
  183|      0|                        {
  184|      0|                            bottomOffset = CGFloat(offsetAxis.axisMinimum)
  185|      0|                        }
  186|      0|                    }
  187|      0|                    else // y < 0
  188|      0|                    {
  189|      0|                        //situation 2
  190|      0|                        if offsetAxis.axisMaximum < 0
  191|      0|                        {
  192|      0|                            topOffset = CGFloat(offsetAxis.axisMaximum * -1)
  193|      0|                        }
  194|      0|                        if offsetAxis.axisMinimum > y
  195|      0|                        {
  196|      0|                            bottomOffset = CGFloat(offsetAxis.axisMinimum - y)
  197|      0|                        }
  198|      0|                    }
  199|      0|                    if isInverted
  200|      0|                    {
  201|      0|                        // situation 3 and 4
  202|      0|                        // exchange topOffset/bottomOffset based on 1 and 2
  203|      0|                        // see diagram above
  204|      0|                        (topOffset, bottomOffset) = (bottomOffset, topOffset)
  205|      0|                    }
  206|      0|                }
  207|      0|                //apply offset
  208|      0|                top = isInverted ? top + topOffset : top - topOffset
  209|      0|                bottom = isInverted ? bottom - bottomOffset : bottom + bottomOffset
  210|      0|
  211|      0|                // multiply the height of the rect with the phase
  212|      0|                // explicitly add 0 + topOffset to indicate this is changed after adding accessibility support (#3650, #3520)
  213|      0|                if top > 0 + topOffset
  214|      0|                {
  215|      0|                    top *= CGFloat(phaseY)
  216|      0|                }
  217|      0|                else
  218|      0|                {
  219|      0|                    bottom *= CGFloat(phaseY)
  220|      0|                }
  221|      0|
  222|      0|                barRect.origin.x = left
  223|      0|                barRect.origin.y = top
  224|      0|                barRect.size.width = right - left
  225|      0|                barRect.size.height = bottom - top
  226|      0|                buffer.rects[bufferIndex] = barRect
  227|      0|                bufferIndex += 1
  228|      0|            }
  229|      0|            else
  230|      0|            {
  231|      0|                var posY = 0.0
  232|      0|                var negY = -e.negativeSum
  233|      0|                var yStart = 0.0
  234|      0|                
  235|      0|                // fill the stack
  236|      0|                for k in 0 ..< vals!.count
  237|      0|                {
  238|      0|                    let value = vals![k]
  239|      0|                    
  240|      0|                    if value == 0.0 && (posY == 0.0 || negY == 0.0)
  241|      0|                    {
  242|      0|                        // Take care of the situation of a 0.0 value, which overlaps a non-zero bar
  243|      0|                        y = value
  244|      0|                        yStart = y
  245|      0|                    }
  246|      0|                    else if value >= 0.0
  247|      0|                    {
  248|      0|                        y = posY
  249|      0|                        yStart = posY + value
  250|      0|                        posY = yStart
  251|      0|                    }
  252|      0|                    else
  253|      0|                    {
  254|      0|                        y = negY
  255|      0|                        yStart = negY + abs(value)
  256|      0|                        negY += abs(value)
  257|      0|                    }
  258|      0|                    
  259|      0|                    let left = CGFloat(x - barWidthHalf)
  260|      0|                    let right = CGFloat(x + barWidthHalf)
  261|      0|                    var top = isInverted
  262|      0|                        ? (y <= yStart ? CGFloat(y) : CGFloat(yStart))
  263|      0|                        : (y >= yStart ? CGFloat(y) : CGFloat(yStart))
  264|      0|                    var bottom = isInverted
  265|      0|                        ? (y >= yStart ? CGFloat(y) : CGFloat(yStart))
  266|      0|                        : (y <= yStart ? CGFloat(y) : CGFloat(yStart))
  267|      0|                    
  268|      0|                    // multiply the height of the rect with the phase
  269|      0|                    top *= CGFloat(phaseY)
  270|      0|                    bottom *= CGFloat(phaseY)
  271|      0|                    
  272|      0|                    barRect.origin.x = left
  273|      0|                    barRect.size.width = right - left
  274|      0|                    barRect.origin.y = top
  275|      0|                    barRect.size.height = bottom - top
  276|      0|                    
  277|      0|                    buffer.rects[bufferIndex] = barRect
  278|      0|                    bufferIndex += 1
  279|      0|                }
  280|      0|            }
  281|      0|        }
  282|      0|    }
  283|       |
  284|       |    open override func drawData(context: CGContext)
  285|      0|    {
  286|      0|        guard
  287|      0|            let dataProvider = dataProvider,
  288|      0|            let barData = dataProvider.barData
  289|      0|            else { return }
  290|      0|        
  291|      0|        // If we redraw the data, remove and repopulate accessible elements to update label values and frames
  292|      0|        accessibleChartElements.removeAll()
  293|      0|        accessibilityOrderedElements = accessibilityCreateEmptyOrderedElements()
  294|      0|
  295|      0|        // Make the chart header the first element in the accessible elements array
  296|      0|        if let chart = dataProvider as? BarChartView {
  297|      0|            let element = createAccessibleHeader(usingChart: chart,
  298|      0|                                                 andData: barData,
  299|      0|                                                 withDefaultDescription: "Bar Chart")
  300|      0|            accessibleChartElements.append(element)
  301|      0|        }
  302|      0|
  303|      0|        // Populate logically ordered nested elements into accessibilityOrderedElements in drawDataSet()
  304|      0|        for i in 0 ..< barData.dataSetCount
  305|      0|        {
  306|      0|            guard let set = barData.getDataSetByIndex(i) else { continue }
  307|      0|            
  308|      0|            if set.isVisible
  309|      0|            {
  310|      0|                if !(set is IBarChartDataSet)
  311|      0|                {
  312|      0|                    fatalError("Datasets for BarChartRenderer must conform to IBarChartDataset")
  313|      0|                }
  314|      0|                
  315|      0|                drawDataSet(context: context, dataSet: set as! IBarChartDataSet, index: i)
  316|      0|            }
  317|      0|        }
  318|      0|
  319|      0|        // Merge nested ordered arrays into the single accessibleChartElements.
  320|      0|        accessibleChartElements.append(contentsOf: accessibilityOrderedElements.flatMap { $0 } )
  321|      0|        accessibilityPostLayoutChangedNotification()
  322|      0|    }
  323|       |
  324|      0|    private var _barShadowRectBuffer: CGRect = CGRect()
  325|       |
  326|       |    @objc open func drawDataSet(context: CGContext, dataSet: IBarChartDataSet, index: Int)
  327|      0|    {
  328|      0|        guard let dataProvider = dataProvider else { return }
  329|      0|
  330|      0|        let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  331|      0|
  332|      0|        prepareBuffer(dataSet: dataSet, index: index)
  333|      0|        trans.rectValuesToPixel(&_buffers[index].rects)
  334|      0|
  335|      0|        let borderWidth = dataSet.barBorderWidth
  336|      0|        let borderColor = dataSet.barBorderColor
  337|      0|        let drawBorder = borderWidth > 0.0
  338|      0|        
  339|      0|        context.saveGState()
  340|      0|        
  341|      0|        // draw the bar shadow before the values
  342|      0|        if dataProvider.isDrawBarShadowEnabled
  343|      0|        {
  344|      0|            guard let barData = dataProvider.barData else { return }
  345|      0|            
  346|      0|            let barWidth = barData.barWidth
  347|      0|            let barWidthHalf = barWidth / 2.0
  348|      0|            var x: Double = 0.0
  349|      0|            
  350|      0|            for i in stride(from: 0, to: min(Int(ceil(Double(dataSet.entryCount) * animator.phaseX)), dataSet.entryCount), by: 1)
  351|      0|            {
  352|      0|                guard let e = dataSet.entryForIndex(i) as? BarChartDataEntry else { continue }
  353|      0|                
  354|      0|                x = e.x
  355|      0|                
  356|      0|                _barShadowRectBuffer.origin.x = CGFloat(x - barWidthHalf)
  357|      0|                _barShadowRectBuffer.size.width = CGFloat(barWidth)
  358|      0|                
  359|      0|                trans.rectValueToPixel(&_barShadowRectBuffer)
  360|      0|                
  361|      0|                if !viewPortHandler.isInBoundsLeft(_barShadowRectBuffer.origin.x + _barShadowRectBuffer.size.width)
  362|      0|                {
  363|      0|                    continue
  364|      0|                }
  365|      0|                
  366|      0|                if !viewPortHandler.isInBoundsRight(_barShadowRectBuffer.origin.x)
  367|      0|                {
  368|      0|                    break
  369|      0|                }
  370|      0|                
  371|      0|                _barShadowRectBuffer.origin.y = viewPortHandler.contentTop
  372|      0|                _barShadowRectBuffer.size.height = viewPortHandler.contentHeight
  373|      0|                
  374|      0|                context.setFillColor(dataSet.barShadowColor.cgColor)
  375|      0|                context.fill(_barShadowRectBuffer)
  376|      0|            }
  377|      0|        }
  378|      0|
  379|      0|        let buffer = _buffers[index]
  380|      0|        
  381|      0|        // draw the bar shadow before the values
  382|      0|        if dataProvider.isDrawBarShadowEnabled
  383|      0|        {
  384|      0|            for j in stride(from: 0, to: buffer.rects.count, by: 1)
  385|      0|            {
  386|      0|                let barRect = buffer.rects[j]
  387|      0|                
  388|      0|                if (!viewPortHandler.isInBoundsLeft(barRect.origin.x + barRect.size.width))
  389|      0|                {
  390|      0|                    continue
  391|      0|                }
  392|      0|                
  393|      0|                if (!viewPortHandler.isInBoundsRight(barRect.origin.x))
  394|      0|                {
  395|      0|                    break
  396|      0|                }
  397|      0|                
  398|      0|                context.setFillColor(dataSet.barShadowColor.cgColor)
  399|      0|                context.fill(barRect)
  400|      0|            }
  401|      0|        }
  402|      0|        
  403|      0|        let isSingleColor = dataSet.colors.count == 1
  404|      0|        
  405|      0|        if isSingleColor
  406|      0|        {
  407|      0|            context.setFillColor(dataSet.color(atIndex: 0).cgColor)
  408|      0|        }
  409|      0|
  410|      0|        // In case the chart is stacked, we need to accomodate individual bars within accessibilityOrdereredElements
  411|      0|        let isStacked = dataSet.isStacked
  412|      0|        let stackSize = isStacked ? dataSet.stackSize : 1
  413|      0|
  414|      0|        for j in stride(from: 0, to: buffer.rects.count, by: 1)
  415|      0|        {
  416|      0|            let barRect = buffer.rects[j]
  417|      0|
  418|      0|            if (!viewPortHandler.isInBoundsLeft(barRect.origin.x + barRect.size.width))
  419|      0|            {
  420|      0|                continue
  421|      0|            }
  422|      0|            
  423|      0|            if (!viewPortHandler.isInBoundsRight(barRect.origin.x))
  424|      0|            {
  425|      0|                break
  426|      0|            }
  427|      0|            
  428|      0|            if !isSingleColor
  429|      0|            {
  430|      0|                // Set the color for the currently drawn value. If the index is out of bounds, reuse colors.
  431|      0|                context.setFillColor(dataSet.color(atIndex: j).cgColor)
  432|      0|            }
  433|      0|            
  434|      0|            context.fill(barRect)
  435|      0|            
  436|      0|            if drawBorder
  437|      0|            {
  438|      0|                context.setStrokeColor(borderColor.cgColor)
  439|      0|                context.setLineWidth(borderWidth)
  440|      0|                context.stroke(barRect)
  441|      0|            }
  442|      0|
  443|      0|            // Create and append the corresponding accessibility element to accessibilityOrderedElements
  444|      0|            if let chart = dataProvider as? BarChartView
  445|      0|            {
  446|      0|                let element = createAccessibleElement(withIndex: j,
  447|      0|                                                      container: chart,
  448|      0|                                                      dataSet: dataSet,
  449|      0|                                                      dataSetIndex: index,
  450|      0|                                                      stackSize: stackSize)
  451|      0|                { (element) in
  452|      0|                    element.accessibilityFrame = barRect
  453|      0|                }
  454|      0|
  455|      0|                accessibilityOrderedElements[j/stackSize].append(element)
  456|      0|            }
  457|      0|        }
  458|      0|        
  459|      0|        context.restoreGState()
  460|      0|    }
  461|       |    
  462|       |    open func prepareBarHighlight(
  463|       |        x: Double,
  464|       |          y1: Double,
  465|       |          y2: Double,
  466|       |          barWidthHalf: Double,
  467|       |          trans: Transformer,
  468|       |          rect: inout CGRect)
  469|      0|    {
  470|      0|        let left = x - barWidthHalf
  471|      0|        let right = x + barWidthHalf
  472|      0|        let top = y1
  473|      0|        let bottom = y2
  474|      0|        
  475|      0|        rect.origin.x = CGFloat(left)
  476|      0|        rect.origin.y = CGFloat(top)
  477|      0|        rect.size.width = CGFloat(right - left)
  478|      0|        rect.size.height = CGFloat(bottom - top)
  479|      0|        
  480|      0|        trans.rectValueToPixel(&rect, phaseY: animator.phaseY )
  481|      0|    }
  482|       |
  483|       |    open override func drawValues(context: CGContext)
  484|      0|    {
  485|      0|        // if values are drawn
  486|      0|        if isDrawingValuesAllowed(dataProvider: dataProvider)
  487|      0|        {
  488|      0|            guard
  489|      0|                let dataProvider = dataProvider,
  490|      0|                let barData = dataProvider.barData
  491|      0|                else { return }
  492|      0|
  493|      0|            let dataSets = barData.dataSets
  494|      0|
  495|      0|            let valueOffsetPlus: CGFloat = 4.5
  496|      0|            var posOffset: CGFloat
  497|      0|            var negOffset: CGFloat
  498|      0|            let drawValueAboveBar = dataProvider.isDrawValueAboveBarEnabled
  499|      0|            
  500|      0|            for dataSetIndex in 0 ..< barData.dataSetCount
  501|      0|            {
  502|      0|                guard let
  503|      0|                    dataSet = dataSets[dataSetIndex] as? IBarChartDataSet,
  504|      0|                    shouldDrawValues(forDataSet: dataSet)
  505|      0|                    else { continue }
  506|      0|                
  507|      0|                let isInverted = dataProvider.isInverted(axis: dataSet.axisDependency)
  508|      0|                
  509|      0|                // calculate the correct offset depending on the draw position of the value
  510|      0|                let valueFont = dataSet.valueFont
  511|      0|                let valueTextHeight = valueFont.lineHeight
  512|      0|                posOffset = (drawValueAboveBar ? -(valueTextHeight + valueOffsetPlus) : valueOffsetPlus)
  513|      0|                negOffset = (drawValueAboveBar ? valueOffsetPlus : -(valueTextHeight + valueOffsetPlus))
  514|      0|                
  515|      0|                if isInverted
  516|      0|                {
  517|      0|                    posOffset = -posOffset - valueTextHeight
  518|      0|                    negOffset = -negOffset - valueTextHeight
  519|      0|                }
  520|      0|                
  521|      0|                let buffer = _buffers[dataSetIndex]
  522|      0|                
  523|      0|                guard let formatter = dataSet.valueFormatter else { continue }
  524|      0|                
  525|      0|                let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  526|      0|                
  527|      0|                let phaseY = animator.phaseY
  528|      0|                
  529|      0|                let iconsOffset = dataSet.iconsOffset
  530|      0|        
  531|      0|                // if only single values are drawn (sum)
  532|      0|                if !dataSet.isStacked
  533|      0|                {
  534|      0|                    for j in 0 ..< Int(ceil(Double(dataSet.entryCount) * animator.phaseX))
  535|      0|                    {
  536|      0|                        guard let e = dataSet.entryForIndex(j) as? BarChartDataEntry else { continue }
  537|      0|                        
  538|      0|                        let rect = buffer.rects[j]
  539|      0|                        
  540|      0|                        let x = rect.origin.x + rect.size.width / 2.0
  541|      0|                        
  542|      0|                        if !viewPortHandler.isInBoundsRight(x)
  543|      0|                        {
  544|      0|                            break
  545|      0|                        }
  546|      0|                        
  547|      0|                        if !viewPortHandler.isInBoundsY(rect.origin.y)
  548|      0|                            || !viewPortHandler.isInBoundsLeft(x)
  549|      0|                        {
  550|      0|                            continue
  551|      0|                        }
  552|      0|                        
  553|      0|                        let val = e.y
  554|      0|                        
  555|      0|                        if dataSet.isDrawValuesEnabled
  556|      0|                        {
  557|      0|                            drawValue(
  558|      0|                                context: context,
  559|      0|                                value: formatter.stringForValue(
  560|      0|                                    val,
  561|      0|                                    entry: e,
  562|      0|                                    dataSetIndex: dataSetIndex,
  563|      0|                                    viewPortHandler: viewPortHandler),
  564|      0|                                xPos: x,
  565|      0|                                yPos: val >= 0.0
  566|      0|                                    ? (rect.origin.y + posOffset)
  567|      0|                                    : (rect.origin.y + rect.size.height + negOffset),
  568|      0|                                font: valueFont,
  569|      0|                                align: .center,
  570|      0|                                color: dataSet.valueTextColorAt(j))
  571|      0|                        }
  572|      0|                        
  573|      0|                        if let icon = e.icon, dataSet.isDrawIconsEnabled
  574|      0|                        {
  575|      0|                            var px = x
  576|      0|                            var py = val >= 0.0
  577|      0|                                ? (rect.origin.y + posOffset)
  578|      0|                                : (rect.origin.y + rect.size.height + negOffset)
  579|      0|                            
  580|      0|                            px += iconsOffset.x
  581|      0|                            py += iconsOffset.y
  582|      0|                            
  583|      0|                            ChartUtils.drawImage(
  584|      0|                                context: context,
  585|      0|                                image: icon,
  586|      0|                                x: px,
  587|      0|                                y: py,
  588|      0|                                size: icon.size)
  589|      0|                        }
  590|      0|                    }
  591|      0|                }
  592|      0|                else
  593|      0|                {
  594|      0|                    // if we have stacks
  595|      0|                    
  596|      0|                    var bufferIndex = 0
  597|      0|                    
  598|      0|                    for index in 0 ..< Int(ceil(Double(dataSet.entryCount) * animator.phaseX))
  599|      0|                    {
  600|      0|                        guard let e = dataSet.entryForIndex(index) as? BarChartDataEntry else { continue }
  601|      0|                        
  602|      0|                        let vals = e.yValues
  603|      0|                        
  604|      0|                        let rect = buffer.rects[bufferIndex]
  605|      0|                        
  606|      0|                        let x = rect.origin.x + rect.size.width / 2.0
  607|      0|                        
  608|      0|                        // we still draw stacked bars, but there is one non-stacked in between
  609|      0|                        if vals == nil
  610|      0|                        {
  611|      0|                            if !viewPortHandler.isInBoundsRight(x)
  612|      0|                            {
  613|      0|                                break
  614|      0|                            }
  615|      0|                            
  616|      0|                            if !viewPortHandler.isInBoundsY(rect.origin.y)
  617|      0|                                || !viewPortHandler.isInBoundsLeft(x)
  618|      0|                            {
  619|      0|                                continue
  620|      0|                            }
  621|      0|                            
  622|      0|                            if dataSet.isDrawValuesEnabled
  623|      0|                            {
  624|      0|                                drawValue(
  625|      0|                                    context: context,
  626|      0|                                    value: formatter.stringForValue(
  627|      0|                                        e.y,
  628|      0|                                        entry: e,
  629|      0|                                        dataSetIndex: dataSetIndex,
  630|      0|                                        viewPortHandler: viewPortHandler),
  631|      0|                                    xPos: x,
  632|      0|                                    yPos: rect.origin.y +
  633|      0|                                        (e.y >= 0 ? posOffset : negOffset),
  634|      0|                                    font: valueFont,
  635|      0|                                    align: .center,
  636|      0|                                    color: dataSet.valueTextColorAt(index))
  637|      0|                            }
  638|      0|                            
  639|      0|                            if let icon = e.icon, dataSet.isDrawIconsEnabled
  640|      0|                            {
  641|      0|                                var px = x
  642|      0|                                var py = rect.origin.y +
  643|      0|                                    (e.y >= 0 ? posOffset : negOffset)
  644|      0|                                
  645|      0|                                px += iconsOffset.x
  646|      0|                                py += iconsOffset.y
  647|      0|                                
  648|      0|                                ChartUtils.drawImage(
  649|      0|                                    context: context,
  650|      0|                                    image: icon,
  651|      0|                                    x: px,
  652|      0|                                    y: py,
  653|      0|                                    size: icon.size)
  654|      0|                            }
  655|      0|                        }
  656|      0|                        else
  657|      0|                        {
  658|      0|                            // draw stack values
  659|      0|                            
  660|      0|                            let vals = vals!
  661|      0|                            var transformed = [CGPoint]()
  662|      0|                            
  663|      0|                            var posY = 0.0
  664|      0|                            var negY = -e.negativeSum
  665|      0|                            
  666|      0|                            for k in 0 ..< vals.count
  667|      0|                            {
  668|      0|                                let value = vals[k]
  669|      0|                                var y: Double
  670|      0|                                
  671|      0|                                if value == 0.0 && (posY == 0.0 || negY == 0.0)
  672|      0|                                {
  673|      0|                                    // Take care of the situation of a 0.0 value, which overlaps a non-zero bar
  674|      0|                                    y = value
  675|      0|                                }
  676|      0|                                else if value >= 0.0
  677|      0|                                {
  678|      0|                                    posY += value
  679|      0|                                    y = posY
  680|      0|                                }
  681|      0|                                else
  682|      0|                                {
  683|      0|                                    y = negY
  684|      0|                                    negY -= value
  685|      0|                                }
  686|      0|                                
  687|      0|                                transformed.append(CGPoint(x: 0.0, y: CGFloat(y * phaseY)))
  688|      0|                            }
  689|      0|                            
  690|      0|                            trans.pointValuesToPixel(&transformed)
  691|      0|                            
  692|      0|                            for k in 0 ..< transformed.count
  693|      0|                            {
  694|      0|                                let val = vals[k]
  695|      0|                                let drawBelow = (val == 0.0 && negY == 0.0 && posY > 0.0) || val < 0.0
  696|      0|                                let y = transformed[k].y + (drawBelow ? negOffset : posOffset)
  697|      0|                                
  698|      0|                                if !viewPortHandler.isInBoundsRight(x)
  699|      0|                                {
  700|      0|                                    break
  701|      0|                                }
  702|      0|                                
  703|      0|                                if !viewPortHandler.isInBoundsY(y) || !viewPortHandler.isInBoundsLeft(x)
  704|      0|                                {
  705|      0|                                    continue
  706|      0|                                }
  707|      0|                                
  708|      0|                                if dataSet.isDrawValuesEnabled
  709|      0|                                {
  710|      0|                                    drawValue(
  711|      0|                                        context: context,
  712|      0|                                        value: formatter.stringForValue(
  713|      0|                                            vals[k],
  714|      0|                                            entry: e,
  715|      0|                                            dataSetIndex: dataSetIndex,
  716|      0|                                            viewPortHandler: viewPortHandler),
  717|      0|                                        xPos: x,
  718|      0|                                        yPos: y,
  719|      0|                                        font: valueFont,
  720|      0|                                        align: .center,
  721|      0|                                        color: dataSet.valueTextColorAt(index))
  722|      0|                                }
  723|      0|                                
  724|      0|                                if let icon = e.icon, dataSet.isDrawIconsEnabled
  725|      0|                                {
  726|      0|                                    ChartUtils.drawImage(
  727|      0|                                        context: context,
  728|      0|                                        image: icon,
  729|      0|                                        x: x + iconsOffset.x,
  730|      0|                                        y: y + iconsOffset.y,
  731|      0|                                        size: icon.size)
  732|      0|                                }
  733|      0|                            }
  734|      0|                        }
  735|      0|                        
  736|      0|                        bufferIndex = vals == nil ? (bufferIndex + 1) : (bufferIndex + vals!.count)
  737|      0|                    }
  738|      0|                }
  739|      0|            }
  740|      0|        }
  741|      0|    }
  742|       |    
  743|       |    /// Draws a value at the specified x and y position.
  744|       |    @objc open func drawValue(context: CGContext, value: String, xPos: CGFloat, yPos: CGFloat, font: NSUIFont, align: NSTextAlignment, color: NSUIColor)
  745|      0|    {
  746|      0|        ChartUtils.drawText(context: context, text: value, point: CGPoint(x: xPos, y: yPos), align: align, attributes: [NSAttributedString.Key.font: font, NSAttributedString.Key.foregroundColor: color])
  747|      0|    }
  748|       |    
  749|       |    open override func drawExtras(context: CGContext)
  750|      0|    {
  751|      0|        
  752|      0|    }
  753|       |    
  754|       |    open override func drawHighlighted(context: CGContext, indices: [Highlight])
  755|      0|    {
  756|      0|        guard
  757|      0|            let dataProvider = dataProvider,
  758|      0|            let barData = dataProvider.barData
  759|      0|            else { return }
  760|      0|        
  761|      0|        context.saveGState()
  762|      0|        
  763|      0|        var barRect = CGRect()
  764|      0|        
  765|      0|        for high in indices
  766|      0|        {
  767|      0|            guard
  768|      0|                let set = barData.getDataSetByIndex(high.dataSetIndex) as? IBarChartDataSet,
  769|      0|                set.isHighlightEnabled
  770|      0|                else { continue }
  771|      0|            
  772|      0|            if let e = set.entryForXValue(high.x, closestToY: high.y) as? BarChartDataEntry
  773|      0|            {
  774|      0|                if !isInBoundsX(entry: e, dataSet: set)
  775|      0|                {
  776|      0|                    continue
  777|      0|                }
  778|      0|                
  779|      0|                let trans = dataProvider.getTransformer(forAxis: set.axisDependency)
  780|      0|                
  781|      0|                context.setFillColor(set.highlightColor.cgColor)
  782|      0|                context.setAlpha(set.highlightAlpha)
  783|      0|                
  784|      0|                let isStack = high.stackIndex >= 0 && e.isStacked
  785|      0|                
  786|      0|                let y1: Double
  787|      0|                let y2: Double
  788|      0|                
  789|      0|                if isStack
  790|      0|                {
  791|      0|                    if dataProvider.isHighlightFullBarEnabled
  792|      0|                    {
  793|      0|                        y1 = e.positiveSum
  794|      0|                        y2 = -e.negativeSum
  795|      0|                    }
  796|      0|                    else
  797|      0|                    {
  798|      0|                        let range = e.ranges?[high.stackIndex]
  799|      0|                        
  800|      0|                        y1 = range?.from ?? 0.0
  801|      0|                        y2 = range?.to ?? 0.0
  802|      0|                    }
  803|      0|                }
  804|      0|                else
  805|      0|                {
  806|      0|                    y1 = e.y
  807|      0|                    y2 = 0.0
  808|      0|                }
  809|      0|                
  810|      0|                prepareBarHighlight(x: e.x, y1: y1, y2: y2, barWidthHalf: barData.barWidth / 2.0, trans: trans, rect: &barRect)
  811|      0|                
  812|      0|                setHighlightDrawPos(highlight: high, barRect: barRect)
  813|      0|                
  814|      0|                context.fill(barRect)
  815|      0|            }
  816|      0|        }
  817|      0|        
  818|      0|        context.restoreGState()
  819|      0|    }
  820|       |
  821|       |    /// Sets the drawing position of the highlight object based on the given bar-rect.
  822|       |    internal func setHighlightDrawPos(highlight high: Highlight, barRect: CGRect)
  823|      0|    {
  824|      0|        high.setDraw(x: barRect.midX, y: barRect.origin.y)
  825|      0|    }
  826|       |
  827|       |    /// Creates a nested array of empty subarrays each of which will be populated with NSUIAccessibilityElements.
  828|       |    /// This is marked internal to support HorizontalBarChartRenderer as well.
  829|       |    internal func accessibilityCreateEmptyOrderedElements() -> [[NSUIAccessibilityElement]]
  830|      0|    {
  831|      0|        guard let chart = dataProvider as? BarChartView else { return [] }
  832|      0|
  833|      0|        // Unlike Bubble & Line charts, here we use the maximum entry count to account for stacked bars
  834|      0|        let maxEntryCount = chart.data?.maxEntryCountSet?.entryCount ?? 0
  835|      0|
  836|      0|        return Array(repeating: [NSUIAccessibilityElement](),
  837|      0|                     count: maxEntryCount)
  838|      0|    }
  839|       |
  840|       |    /// Creates an NSUIAccessibleElement representing the smallest meaningful bar of the chart
  841|       |    /// i.e. in case of a stacked chart, this returns each stack, not the combined bar.
  842|       |    /// Note that it is marked internal to support subclass modification in the HorizontalBarChart.
  843|       |    internal func createAccessibleElement(withIndex idx: Int,
  844|       |                                          container: BarChartView,
  845|       |                                          dataSet: IBarChartDataSet,
  846|       |                                          dataSetIndex: Int,
  847|       |                                          stackSize: Int,
  848|       |                                          modifier: (NSUIAccessibilityElement) -> ()) -> NSUIAccessibilityElement
  849|      0|    {
  850|      0|        let element = NSUIAccessibilityElement(accessibilityContainer: container)
  851|      0|        let xAxis = container.xAxis
  852|      0|
  853|      0|        guard let e = dataSet.entryForIndex(idx/stackSize) as? BarChartDataEntry else { return element }
  854|      0|        guard let dataProvider = dataProvider else { return element }
  855|      0|
  856|      0|        // NOTE: The formatter can cause issues when the x-axis labels are consecutive ints.
  857|      0|        // i.e. due to the Double conversion, if there are more than one data set that are grouped,
  858|      0|        // there is the possibility of some labels being rounded up. A floor() might fix this, but seems to be a brute force solution.
  859|      0|        let label = xAxis.valueFormatter?.stringForValue(e.x, axis: xAxis) ?? "\(e.x)"
  860|      0|
  861|      0|        var elementValueText = dataSet.valueFormatter?.stringForValue(
  862|      0|            e.y,
  863|      0|            entry: e,
  864|      0|            dataSetIndex: dataSetIndex,
  865|      0|            viewPortHandler: viewPortHandler) ?? "\(e.y)"
  866|      0|
  867|      0|        if dataSet.isStacked, let vals = e.yValues
  868|      0|        {
  869|      0|            let labelCount = min(dataSet.colors.count, stackSize)
  870|      0|
  871|      0|            let stackLabel: String?
  872|      0|            if (dataSet.stackLabels.count > 0 && labelCount > 0) {
  873|      0|                let labelIndex = idx % labelCount
  874|      0|                stackLabel = dataSet.stackLabels.indices.contains(labelIndex) ? dataSet.stackLabels[labelIndex] : nil
  875|      0|            } else {
  876|      0|                stackLabel = nil
  877|      0|            }
  878|      0|            
  879|      0|            //Handles empty array of yValues
  880|      0|            let yValue = vals.isEmpty ? 0.0 : vals[idx % vals.count]
  881|      0|            
  882|      0|            elementValueText = dataSet.valueFormatter?.stringForValue(
  883|      0|                yValue,
  884|      0|                entry: e,
  885|      0|                dataSetIndex: dataSetIndex,
  886|      0|                viewPortHandler: viewPortHandler) ?? "\(e.y)"
  887|      0|
  888|      0|            if let stackLabel = stackLabel {
  889|      0|                elementValueText = stackLabel + " \(elementValueText)"
  890|      0|            } else {
  891|      0|                elementValueText = "\(elementValueText)"
  892|      0|            }
  893|      0|        }
  894|      0|
  895|      0|        let dataSetCount = dataProvider.barData?.dataSetCount ?? -1
  896|      0|        let doesContainMultipleDataSets = dataSetCount > 1
  897|      0|
  898|      0|        element.accessibilityLabel = "\(doesContainMultipleDataSets ? (dataSet.label ?? "")  + ", " : "") \(label): \(elementValueText)"
  899|      0|
  900|      0|        modifier(element)
  901|      0|
  902|      0|        return element
  903|      0|    }
  904|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/BarLineScatterCandleBubbleRenderer.swift:
    1|       |//
    2|       |//  BarLineScatterCandleBubbleRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(BarLineScatterCandleBubbleChartRenderer)
   16|       |open class BarLineScatterCandleBubbleRenderer: DataRenderer
   17|       |{
   18|      0|    internal var _xBounds = XBounds() // Reusable XBounds object
   19|       |    
   20|       |    public override init(animator: Animator, viewPortHandler: ViewPortHandler)
   21|      0|    {
   22|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   23|      0|    }
   24|       |    
   25|       |    /// Checks if the provided entry object is in bounds for drawing considering the current animation phase.
   26|       |    internal func isInBoundsX(entry e: ChartDataEntry, dataSet: IBarLineScatterCandleBubbleChartDataSet) -> Bool
   27|      0|    {
   28|      0|        let entryIndex = dataSet.entryIndex(entry: e)
   29|      0|        return Double(entryIndex) < Double(dataSet.entryCount) * animator.phaseX
   30|      0|    }
   31|       |
   32|       |    /// Calculates and returns the x-bounds for the given DataSet in terms of index in their values array.
   33|       |    /// This includes minimum and maximum visible x, as well as range.
   34|       |    internal func xBounds(chart: BarLineScatterCandleBubbleChartDataProvider,
   35|       |                          dataSet: IBarLineScatterCandleBubbleChartDataSet,
   36|       |                          animator: Animator?) -> XBounds
   37|      0|    {
   38|      0|        return XBounds(chart: chart, dataSet: dataSet, animator: animator)
   39|      0|    }
   40|       |    
   41|       |    /// - Returns: `true` if the DataSet values should be drawn, `false` if not.
   42|       |    internal func shouldDrawValues(forDataSet set: IChartDataSet) -> Bool
   43|      0|    {
   44|      0|        return set.isVisible && (set.isDrawValuesEnabled || set.isDrawIconsEnabled)
   45|      0|    }
   46|       |
   47|       |    /// Class representing the bounds of the current viewport in terms of indices in the values array of a DataSet.
   48|       |    open class XBounds
   49|       |    {
   50|       |        /// minimum visible entry index
   51|       |        open var min: Int = 0
   52|       |
   53|       |        /// maximum visible entry index
   54|       |        open var max: Int = 0
   55|       |
   56|       |        /// range of visible entry indices
   57|       |        open var range: Int = 0
   58|       |
   59|       |        public init()
   60|      0|        {
   61|      0|            
   62|      0|        }
   63|       |        
   64|       |        public init(chart: BarLineScatterCandleBubbleChartDataProvider,
   65|       |                    dataSet: IBarLineScatterCandleBubbleChartDataSet,
   66|       |                    animator: Animator?)
   67|      0|        {
   68|      0|            self.set(chart: chart, dataSet: dataSet, animator: animator)
   69|      0|        }
   70|       |        
   71|       |        /// Calculates the minimum and maximum x values as well as the range between them.
   72|       |        open func set(chart: BarLineScatterCandleBubbleChartDataProvider,
   73|       |                      dataSet: IBarLineScatterCandleBubbleChartDataSet,
   74|       |                      animator: Animator?)
   75|      0|        {
   76|      0|            let phaseX = Swift.max(0.0, Swift.min(1.0, animator?.phaseX ?? 1.0))
   77|      0|            
   78|      0|            let low = chart.lowestVisibleX
   79|      0|            let high = chart.highestVisibleX
   80|      0|            
   81|      0|            let entryFrom = dataSet.entryForXValue(low, closestToY: .nan, rounding: .down)
   82|      0|            let entryTo = dataSet.entryForXValue(high, closestToY: .nan, rounding: .up)
   83|      0|            
   84|      0|            self.min = entryFrom == nil ? 0 : dataSet.entryIndex(entry: entryFrom!)
   85|      0|            self.max = entryTo == nil ? 0 : dataSet.entryIndex(entry: entryTo!)
   86|      0|            range = Int(Double(self.max - self.min) * phaseX)
   87|      0|        }
   88|       |    }
   89|       |}
   90|       |
   91|       |extension BarLineScatterCandleBubbleRenderer.XBounds: RangeExpression {
   92|       |    public func relative<C>(to collection: C) -> Swift.Range<Int>
   93|       |        where C : Collection, Bound == C.Index
   94|      0|    {
   95|      0|        return Swift.Range<Int>(min...min + range)
   96|      0|    }
   97|       |
   98|      0|    public func contains(_ element: Int) -> Bool {
   99|      0|        return (min...min + range).contains(element)
  100|      0|    }
  101|       |}
  102|       |
  103|       |extension BarLineScatterCandleBubbleRenderer.XBounds: Sequence {
  104|       |    public struct Iterator: IteratorProtocol {
  105|       |        private var iterator: IndexingIterator<ClosedRange<Int>>
  106|       |        
  107|      0|        fileprivate init(min: Int, max: Int) {
  108|      0|            self.iterator = (min...max).makeIterator()
  109|      0|        }
  110|       |        
  111|      0|        public mutating func next() -> Int? {
  112|      0|            return self.iterator.next()
  113|      0|        }
  114|       |    }
  115|       |    
  116|      0|    public func makeIterator() -> Iterator {
  117|      0|        return Iterator(min: self.min, max: self.min + self.range)
  118|      0|    }
  119|       |}
  120|       |
  121|       |extension BarLineScatterCandleBubbleRenderer.XBounds: CustomDebugStringConvertible
  122|       |{
  123|       |    public var debugDescription: String
  124|      0|    {
  125|      0|        return "min:\(self.min), max:\(self.max), range:\(self.range)"
  126|      0|    }
  127|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/BubbleChartRenderer.swift:
    1|       |//
    2|       |//  BubbleChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Bubble chart implementation:
    6|       |//    Copyright 2015 Pierre-Marc Airoldi
    7|       |//    Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class BubbleChartRenderer: BarLineScatterCandleBubbleRenderer
   16|       |{
   17|       |    /// A nested array of elements ordered logically (i.e not in visual/drawing order) for use with VoiceOver.
   18|       |    private lazy var accessibilityOrderedElements: [[NSUIAccessibilityElement]] = accessibilityCreateEmptyOrderedElements()
   19|       |
   20|       |    @objc open weak var dataProvider: BubbleChartDataProvider?
   21|       |    
   22|       |    @objc public init(dataProvider: BubbleChartDataProvider, animator: Animator, viewPortHandler: ViewPortHandler)
   23|      0|    {
   24|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   25|      0|        
   26|      0|        self.dataProvider = dataProvider
   27|      0|    }
   28|       |    
   29|       |    open override func drawData(context: CGContext)
   30|      0|    {
   31|      0|        guard
   32|      0|            let dataProvider = dataProvider,
   33|      0|            let bubbleData = dataProvider.bubbleData
   34|      0|            else { return }
   35|      0|        
   36|      0|        // If we redraw the data, remove and repopulate accessible elements to update label values and frames
   37|      0|        accessibleChartElements.removeAll()
   38|      0|        accessibilityOrderedElements = accessibilityCreateEmptyOrderedElements()
   39|      0|
   40|      0|        // Make the chart header the first element in the accessible elements array
   41|      0|        if let chart = dataProvider as? BubbleChartView {
   42|      0|            let element = createAccessibleHeader(usingChart: chart,
   43|      0|                                                 andData: bubbleData,
   44|      0|                                                 withDefaultDescription: "Bubble Chart")
   45|      0|            accessibleChartElements.append(element)
   46|      0|        }
   47|      0|
   48|      0|        for (i, set) in (bubbleData.dataSets as! [IBubbleChartDataSet]).enumerated() where set.isVisible
   49|      0|        {
   50|      0|            drawDataSet(context: context, dataSet: set, dataSetIndex: i)
   51|      0|        }
   52|      0|
   53|      0|        // Merge nested ordered arrays into the single accessibleChartElements.
   54|      0|        accessibleChartElements.append(contentsOf: accessibilityOrderedElements.flatMap { $0 } )
   55|      0|        accessibilityPostLayoutChangedNotification()
   56|      0|    }
   57|       |    
   58|       |    private func getShapeSize(
   59|       |        entrySize: CGFloat,
   60|       |        maxSize: CGFloat,
   61|       |        reference: CGFloat,
   62|       |        normalizeSize: Bool) -> CGFloat
   63|      0|    {
   64|      0|        let factor: CGFloat = normalizeSize
   65|      0|            ? ((maxSize == 0.0) ? 1.0 : sqrt(entrySize / maxSize))
   66|      0|            : entrySize
   67|      0|        let shapeSize: CGFloat = reference * factor
   68|      0|        return shapeSize
   69|      0|    }
   70|       |    
   71|      0|    private var _pointBuffer = CGPoint()
   72|      0|    private var _sizeBuffer = [CGPoint](repeating: CGPoint(), count: 2)
   73|       |    
   74|       |    @objc open func drawDataSet(context: CGContext, dataSet: IBubbleChartDataSet, dataSetIndex: Int)
   75|      0|    {
   76|      0|        guard let dataProvider = dataProvider else { return }
   77|      0|        
   78|      0|        let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
   79|      0|        
   80|      0|        let phaseY = animator.phaseY
   81|      0|        
   82|      0|        _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
   83|      0|        
   84|      0|        let valueToPixelMatrix = trans.valueToPixelMatrix
   85|      0|    
   86|      0|        _sizeBuffer[0].x = 0.0
   87|      0|        _sizeBuffer[0].y = 0.0
   88|      0|        _sizeBuffer[1].x = 1.0
   89|      0|        _sizeBuffer[1].y = 0.0
   90|      0|        
   91|      0|        trans.pointValuesToPixel(&_sizeBuffer)
   92|      0|        
   93|      0|        context.saveGState()
   94|      0|        defer { context.restoreGState() }
   95|      0|        
   96|      0|        let normalizeSize = dataSet.isNormalizeSizeEnabled
   97|      0|        
   98|      0|        // calcualte the full width of 1 step on the x-axis
   99|      0|        let maxBubbleWidth: CGFloat = abs(_sizeBuffer[1].x - _sizeBuffer[0].x)
  100|      0|        let maxBubbleHeight: CGFloat = abs(viewPortHandler.contentBottom - viewPortHandler.contentTop)
  101|      0|        let referenceSize: CGFloat = min(maxBubbleHeight, maxBubbleWidth)
  102|      0|        
  103|      0|        for j in _xBounds
  104|      0|        {
  105|      0|            guard let entry = dataSet.entryForIndex(j) as? BubbleChartDataEntry else { continue }
  106|      0|            
  107|      0|            _pointBuffer.x = CGFloat(entry.x)
  108|      0|            _pointBuffer.y = CGFloat(entry.y * phaseY)
  109|      0|            _pointBuffer = _pointBuffer.applying(valueToPixelMatrix)
  110|      0|            
  111|      0|            let shapeSize = getShapeSize(entrySize: entry.size, maxSize: dataSet.maxSize, reference: referenceSize, normalizeSize: normalizeSize)
  112|      0|            let shapeHalf = shapeSize / 2.0
  113|      0|            
  114|      0|            guard
  115|      0|                viewPortHandler.isInBoundsTop(_pointBuffer.y + shapeHalf),
  116|      0|                viewPortHandler.isInBoundsBottom(_pointBuffer.y - shapeHalf),
  117|      0|                viewPortHandler.isInBoundsLeft(_pointBuffer.x + shapeHalf)
  118|      0|                else { continue }
  119|      0|
  120|      0|            guard viewPortHandler.isInBoundsRight(_pointBuffer.x - shapeHalf) else { break }
  121|      0|            
  122|      0|            let color = dataSet.color(atIndex: j)
  123|      0|            
  124|      0|            let rect = CGRect(
  125|      0|                x: _pointBuffer.x - shapeHalf,
  126|      0|                y: _pointBuffer.y - shapeHalf,
  127|      0|                width: shapeSize,
  128|      0|                height: shapeSize
  129|      0|            )
  130|      0|
  131|      0|            context.setFillColor(color.cgColor)
  132|      0|            context.fillEllipse(in: rect)
  133|      0|
  134|      0|            // Create and append the corresponding accessibility element to accessibilityOrderedElements
  135|      0|            if let chart = dataProvider as? BubbleChartView
  136|      0|            {
  137|      0|                let element = createAccessibleElement(withIndex: j,
  138|      0|                                                      container: chart,
  139|      0|                                                      dataSet: dataSet,
  140|      0|                                                      dataSetIndex: dataSetIndex,
  141|      0|                                                      shapeSize: shapeSize)
  142|      0|                { (element) in
  143|      0|                    element.accessibilityFrame = rect
  144|      0|                }
  145|      0|
  146|      0|                accessibilityOrderedElements[dataSetIndex].append(element)
  147|      0|            }
  148|      0|        }
  149|      0|    }
  150|       |    
  151|       |    open override func drawValues(context: CGContext)
  152|      0|    {
  153|      0|        guard let
  154|      0|            dataProvider = dataProvider,
  155|      0|            let bubbleData = dataProvider.bubbleData,
  156|      0|            isDrawingValuesAllowed(dataProvider: dataProvider),
  157|      0|            let dataSets = bubbleData.dataSets as? [IBubbleChartDataSet]
  158|      0|            else { return }
  159|      0|
  160|      0|        let phaseX = max(0.0, min(1.0, animator.phaseX))
  161|      0|        let phaseY = animator.phaseY
  162|      0|
  163|      0|        var pt = CGPoint()
  164|      0|
  165|      0|        for i in 0..<dataSets.count
  166|      0|        {
  167|      0|            let dataSet = dataSets[i]
  168|      0|
  169|      0|            guard
  170|      0|                shouldDrawValues(forDataSet: dataSet),
  171|      0|                let formatter = dataSet.valueFormatter
  172|      0|                else { continue }
  173|      0|
  174|      0|            let alpha = phaseX == 1 ? phaseY : phaseX
  175|      0|
  176|      0|            _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
  177|      0|
  178|      0|            let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  179|      0|            let valueToPixelMatrix = trans.valueToPixelMatrix
  180|      0|
  181|      0|            let iconsOffset = dataSet.iconsOffset
  182|      0|
  183|      0|            for j in _xBounds
  184|      0|            {
  185|      0|                guard let e = dataSet.entryForIndex(j) as? BubbleChartDataEntry else { break }
  186|      0|
  187|      0|                let valueTextColor = dataSet.valueTextColorAt(j).withAlphaComponent(CGFloat(alpha))
  188|      0|
  189|      0|                pt.x = CGFloat(e.x)
  190|      0|                pt.y = CGFloat(e.y * phaseY)
  191|      0|                pt = pt.applying(valueToPixelMatrix)
  192|      0|
  193|      0|                guard viewPortHandler.isInBoundsRight(pt.x) else { break }
  194|      0|
  195|      0|                guard
  196|      0|                    viewPortHandler.isInBoundsLeft(pt.x),
  197|      0|                    viewPortHandler.isInBoundsY(pt.y)
  198|      0|                    else { continue }
  199|      0|
  200|      0|                let text = formatter.stringForValue(
  201|      0|                    Double(e.size),
  202|      0|                    entry: e,
  203|      0|                    dataSetIndex: i,
  204|      0|                    viewPortHandler: viewPortHandler)
  205|      0|
  206|      0|                // Larger font for larger bubbles?
  207|      0|                let valueFont = dataSet.valueFont
  208|      0|                let lineHeight = valueFont.lineHeight
  209|      0|
  210|      0|                if dataSet.isDrawValuesEnabled
  211|      0|                {
  212|      0|                    ChartUtils.drawText(
  213|      0|                        context: context,
  214|      0|                        text: text,
  215|      0|                        point: CGPoint(
  216|      0|                            x: pt.x,
  217|      0|                            y: pt.y - (0.5 * lineHeight)),
  218|      0|                        align: .center,
  219|      0|                        attributes: [NSAttributedString.Key.font: valueFont, NSAttributedString.Key.foregroundColor: valueTextColor])
  220|      0|                }
  221|      0|
  222|      0|                if let icon = e.icon, dataSet.isDrawIconsEnabled
  223|      0|                {
  224|      0|                    ChartUtils.drawImage(context: context,
  225|      0|                                         image: icon,
  226|      0|                                         x: pt.x + iconsOffset.x,
  227|      0|                                         y: pt.y + iconsOffset.y,
  228|      0|                                         size: icon.size)
  229|      0|                }
  230|      0|            }
  231|      0|        }
  232|      0|    }
  233|       |    
  234|       |    open override func drawExtras(context: CGContext)
  235|      0|    {
  236|      0|        
  237|      0|    }
  238|       |    
  239|       |    open override func drawHighlighted(context: CGContext, indices: [Highlight])
  240|      0|    {
  241|      0|        guard
  242|      0|            let dataProvider = dataProvider,
  243|      0|            let bubbleData = dataProvider.bubbleData
  244|      0|            else { return }
  245|      0|
  246|      0|        context.saveGState()
  247|      0|        defer { context.restoreGState() }
  248|      0|
  249|      0|        let phaseY = animator.phaseY
  250|      0|        
  251|      0|        for high in indices
  252|      0|        {
  253|      0|            guard
  254|      0|                let dataSet = bubbleData.getDataSetByIndex(high.dataSetIndex) as? IBubbleChartDataSet,
  255|      0|                dataSet.isHighlightEnabled,
  256|      0|                let entry = dataSet.entryForXValue(high.x, closestToY: high.y) as? BubbleChartDataEntry,
  257|      0|                isInBoundsX(entry: entry, dataSet: dataSet)
  258|      0|                else { continue }
  259|      0|
  260|      0|            let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  261|      0|            
  262|      0|            _sizeBuffer[0].x = 0.0
  263|      0|            _sizeBuffer[0].y = 0.0
  264|      0|            _sizeBuffer[1].x = 1.0
  265|      0|            _sizeBuffer[1].y = 0.0
  266|      0|            
  267|      0|            trans.pointValuesToPixel(&_sizeBuffer)
  268|      0|            
  269|      0|            let normalizeSize = dataSet.isNormalizeSizeEnabled
  270|      0|            
  271|      0|            // calcualte the full width of 1 step on the x-axis
  272|      0|            let maxBubbleWidth: CGFloat = abs(_sizeBuffer[1].x - _sizeBuffer[0].x)
  273|      0|            let maxBubbleHeight: CGFloat = abs(viewPortHandler.contentBottom - viewPortHandler.contentTop)
  274|      0|            let referenceSize: CGFloat = min(maxBubbleHeight, maxBubbleWidth)
  275|      0|            
  276|      0|            _pointBuffer.x = CGFloat(entry.x)
  277|      0|            _pointBuffer.y = CGFloat(entry.y * phaseY)
  278|      0|            trans.pointValueToPixel(&_pointBuffer)
  279|      0|            
  280|      0|            let shapeSize = getShapeSize(entrySize: entry.size, maxSize: dataSet.maxSize, reference: referenceSize, normalizeSize: normalizeSize)
  281|      0|            let shapeHalf = shapeSize / 2.0
  282|      0|            
  283|      0|            guard
  284|      0|                viewPortHandler.isInBoundsTop(_pointBuffer.y + shapeHalf),
  285|      0|                viewPortHandler.isInBoundsBottom(_pointBuffer.y - shapeHalf),
  286|      0|                viewPortHandler.isInBoundsLeft(_pointBuffer.x + shapeHalf)
  287|      0|            else { continue }
  288|      0|
  289|      0|            guard viewPortHandler.isInBoundsRight(_pointBuffer.x - shapeHalf) else { break }
  290|      0|
  291|      0|            let originalColor = dataSet.color(atIndex: Int(entry.x))
  292|      0|            
  293|      0|            var h: CGFloat = 0.0
  294|      0|            var s: CGFloat = 0.0
  295|      0|            var b: CGFloat = 0.0
  296|      0|            var a: CGFloat = 0.0
  297|      0|            
  298|      0|            originalColor.getHue(&h, saturation: &s, brightness: &b, alpha: &a)
  299|      0|            
  300|      0|            let color = NSUIColor(hue: h, saturation: s, brightness: b * 0.5, alpha: a)
  301|      0|            let rect = CGRect(
  302|      0|                x: _pointBuffer.x - shapeHalf,
  303|      0|                y: _pointBuffer.y - shapeHalf,
  304|      0|                width: shapeSize,
  305|      0|                height: shapeSize)
  306|      0|            
  307|      0|            context.setLineWidth(dataSet.highlightCircleWidth)
  308|      0|            context.setStrokeColor(color.cgColor)
  309|      0|            context.strokeEllipse(in: rect)
  310|      0|            
  311|      0|            high.setDraw(x: _pointBuffer.x, y: _pointBuffer.y)
  312|      0|        }
  313|      0|    }
  314|       |
  315|       |    /// Creates a nested array of empty subarrays each of which will be populated with NSUIAccessibilityElements.
  316|       |    private func accessibilityCreateEmptyOrderedElements() -> [[NSUIAccessibilityElement]]
  317|      0|    {
  318|      0|        guard let chart = dataProvider as? BubbleChartView else { return [] }
  319|      0|
  320|      0|        let dataSetCount = chart.bubbleData?.dataSetCount ?? 0
  321|      0|
  322|      0|        return Array(repeating: [NSUIAccessibilityElement](),
  323|      0|                     count: dataSetCount)
  324|      0|    }
  325|       |
  326|       |    /// Creates an NSUIAccessibleElement representing individual bubbles location and relative size.
  327|       |    private func createAccessibleElement(withIndex idx: Int,
  328|       |                                         container: BubbleChartView,
  329|       |                                         dataSet: IBubbleChartDataSet,
  330|       |                                         dataSetIndex: Int,
  331|       |                                         shapeSize: CGFloat,
  332|       |                                         modifier: (NSUIAccessibilityElement) -> ()) -> NSUIAccessibilityElement
  333|      0|    {
  334|      0|        let element = NSUIAccessibilityElement(accessibilityContainer: container)
  335|      0|        let xAxis = container.xAxis
  336|      0|
  337|      0|        guard let e = dataSet.entryForIndex(idx) else { return element }
  338|      0|        guard let dataProvider = dataProvider else { return element }
  339|      0|
  340|      0|        // NOTE: The formatter can cause issues when the x-axis labels are consecutive ints.
  341|      0|        // i.e. due to the Double conversion, if there are more than one data set that are grouped,
  342|      0|        // there is the possibility of some labels being rounded up. A floor() might fix this, but seems to be a brute force solution.
  343|      0|        let label = xAxis.valueFormatter?.stringForValue(e.x, axis: xAxis) ?? "\(e.x)"
  344|      0|
  345|      0|        let elementValueText = dataSet.valueFormatter?.stringForValue(e.y,
  346|      0|                                                                      entry: e,
  347|      0|                                                                      dataSetIndex: dataSetIndex,
  348|      0|                                                                      viewPortHandler: viewPortHandler) ?? "\(e.y)"
  349|      0|
  350|      0|        let dataSetCount = dataProvider.bubbleData?.dataSetCount ?? -1
  351|      0|        let doesContainMultipleDataSets = dataSetCount > 1
  352|      0|
  353|      0|        element.accessibilityLabel = "\(doesContainMultipleDataSets ? (dataSet.label ?? "")  + ", " : "") \(label): \(elementValueText), bubble size: \(String(format: "%.2f", (shapeSize/dataSet.maxSize) * 100)) %"
  354|      0|
  355|      0|        modifier(element)
  356|      0|
  357|      0|        return element
  358|      0|    }
  359|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/CandleStickChartRenderer.swift:
    1|       |//
    2|       |//  CandleStickChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class CandleStickChartRenderer: LineScatterCandleRadarRenderer
   16|       |{
   17|       |    @objc open weak var dataProvider: CandleChartDataProvider?
   18|       |    
   19|       |    @objc public init(dataProvider: CandleChartDataProvider, animator: Animator, viewPortHandler: ViewPortHandler)
   20|      0|    {
   21|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   22|      0|        
   23|      0|        self.dataProvider = dataProvider
   24|      0|    }
   25|       |    
   26|       |    open override func drawData(context: CGContext)
   27|      0|    {
   28|      0|        guard let dataProvider = dataProvider, let candleData = dataProvider.candleData else { return }
   29|      0|
   30|      0|        // If we redraw the data, remove and repopulate accessible elements to update label values and frames
   31|      0|        accessibleChartElements.removeAll()
   32|      0|
   33|      0|        // Make the chart header the first element in the accessible elements array
   34|      0|        if let chart = dataProvider as? CandleStickChartView {
   35|      0|            let element = createAccessibleHeader(usingChart: chart,
   36|      0|                                                 andData: candleData,
   37|      0|                                                 withDefaultDescription: "CandleStick Chart")
   38|      0|            accessibleChartElements.append(element)
   39|      0|        }
   40|      0|
   41|      0|        for set in candleData.dataSets as! [ICandleChartDataSet] where set.isVisible
   42|      0|        {
   43|      0|            drawDataSet(context: context, dataSet: set)
   44|      0|        }
   45|      0|    }
   46|       |    
   47|      0|    private var _shadowPoints = [CGPoint](repeating: CGPoint(), count: 4)
   48|      0|    private var _rangePoints = [CGPoint](repeating: CGPoint(), count: 2)
   49|      0|    private var _openPoints = [CGPoint](repeating: CGPoint(), count: 2)
   50|      0|    private var _closePoints = [CGPoint](repeating: CGPoint(), count: 2)
   51|      0|    private var _bodyRect = CGRect()
   52|      0|    private var _lineSegments = [CGPoint](repeating: CGPoint(), count: 2)
   53|       |    
   54|       |    @objc open func drawDataSet(context: CGContext, dataSet: ICandleChartDataSet)
   55|      0|    {
   56|      0|        guard
   57|      0|            let dataProvider = dataProvider
   58|      0|            else { return }
   59|      0|
   60|      0|        let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
   61|      0|        
   62|      0|        let phaseY = animator.phaseY
   63|      0|        let barSpace = dataSet.barSpace
   64|      0|        let showCandleBar = dataSet.showCandleBar
   65|      0|        
   66|      0|        _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
   67|      0|        
   68|      0|        context.saveGState()
   69|      0|        
   70|      0|        context.setLineWidth(dataSet.shadowWidth)
   71|      0|
   72|      0|        for j in _xBounds
   73|      0|        {
   74|      0|            // get the entry
   75|      0|            guard let e = dataSet.entryForIndex(j) as? CandleChartDataEntry else { continue }
   76|      0|            
   77|      0|            let xPos = e.x
   78|      0|            
   79|      0|            let open = e.open
   80|      0|            let close = e.close
   81|      0|            let high = e.high
   82|      0|            let low = e.low
   83|      0|            
   84|      0|            let doesContainMultipleDataSets = (dataProvider.candleData?.dataSets.count ?? 1) > 1
   85|      0|            var accessibilityMovementDescription = "neutral"
   86|      0|            var accessibilityRect = CGRect(x: CGFloat(xPos) + 0.5 - barSpace,
   87|      0|                                           y: CGFloat(low * phaseY),
   88|      0|                                           width: (2 * barSpace) - 1.0,
   89|      0|                                           height: (CGFloat(abs(high - low) * phaseY)))
   90|      0|            trans.rectValueToPixel(&accessibilityRect)
   91|      0|
   92|      0|            if showCandleBar
   93|      0|            {
   94|      0|                // calculate the shadow
   95|      0|                
   96|      0|                _shadowPoints[0].x = CGFloat(xPos)
   97|      0|                _shadowPoints[1].x = CGFloat(xPos)
   98|      0|                _shadowPoints[2].x = CGFloat(xPos)
   99|      0|                _shadowPoints[3].x = CGFloat(xPos)
  100|      0|                
  101|      0|                if open > close
  102|      0|                {
  103|      0|                    _shadowPoints[0].y = CGFloat(high * phaseY)
  104|      0|                    _shadowPoints[1].y = CGFloat(open * phaseY)
  105|      0|                    _shadowPoints[2].y = CGFloat(low * phaseY)
  106|      0|                    _shadowPoints[3].y = CGFloat(close * phaseY)
  107|      0|                }
  108|      0|                else if open < close
  109|      0|                {
  110|      0|                    _shadowPoints[0].y = CGFloat(high * phaseY)
  111|      0|                    _shadowPoints[1].y = CGFloat(close * phaseY)
  112|      0|                    _shadowPoints[2].y = CGFloat(low * phaseY)
  113|      0|                    _shadowPoints[3].y = CGFloat(open * phaseY)
  114|      0|                }
  115|      0|                else
  116|      0|                {
  117|      0|                    _shadowPoints[0].y = CGFloat(high * phaseY)
  118|      0|                    _shadowPoints[1].y = CGFloat(open * phaseY)
  119|      0|                    _shadowPoints[2].y = CGFloat(low * phaseY)
  120|      0|                    _shadowPoints[3].y = _shadowPoints[1].y
  121|      0|                }
  122|      0|                
  123|      0|                trans.pointValuesToPixel(&_shadowPoints)
  124|      0|                
  125|      0|                // draw the shadows
  126|      0|                
  127|      0|                var shadowColor: NSUIColor! = nil
  128|      0|                if dataSet.shadowColorSameAsCandle
  129|      0|                {
  130|      0|                    if open > close
  131|      0|                    {
  132|      0|                        shadowColor = dataSet.decreasingColor ?? dataSet.color(atIndex: j)
  133|      0|                    }
  134|      0|                    else if open < close
  135|      0|                    {
  136|      0|                        shadowColor = dataSet.increasingColor ?? dataSet.color(atIndex: j)
  137|      0|                    }
  138|      0|                    else
  139|      0|                    {
  140|      0|                        shadowColor = dataSet.neutralColor ?? dataSet.color(atIndex: j)
  141|      0|                    }
  142|      0|                }
  143|      0|                
  144|      0|                if shadowColor === nil
  145|      0|                {
  146|      0|                    shadowColor = dataSet.shadowColor ?? dataSet.color(atIndex: j)
  147|      0|                }
  148|      0|                
  149|      0|                context.setStrokeColor(shadowColor.cgColor)
  150|      0|                context.strokeLineSegments(between: _shadowPoints)
  151|      0|                
  152|      0|                // calculate the body
  153|      0|                
  154|      0|                _bodyRect.origin.x = CGFloat(xPos) - 0.5 + barSpace
  155|      0|                _bodyRect.origin.y = CGFloat(close * phaseY)
  156|      0|                _bodyRect.size.width = (CGFloat(xPos) + 0.5 - barSpace) - _bodyRect.origin.x
  157|      0|                _bodyRect.size.height = CGFloat(open * phaseY) - _bodyRect.origin.y
  158|      0|                
  159|      0|                trans.rectValueToPixel(&_bodyRect)
  160|      0|                
  161|      0|                // draw body differently for increasing and decreasing entry
  162|      0|
  163|      0|                if open > close
  164|      0|                {
  165|      0|                    accessibilityMovementDescription = "decreasing"
  166|      0|
  167|      0|                    let color = dataSet.decreasingColor ?? dataSet.color(atIndex: j)
  168|      0|                    
  169|      0|                    if dataSet.isDecreasingFilled
  170|      0|                    {
  171|      0|                        context.setFillColor(color.cgColor)
  172|      0|                        context.fill(_bodyRect)
  173|      0|                    }
  174|      0|                    else
  175|      0|                    {
  176|      0|                        context.setStrokeColor(color.cgColor)
  177|      0|                        context.stroke(_bodyRect)
  178|      0|                    }
  179|      0|                }
  180|      0|                else if open < close
  181|      0|                {
  182|      0|                    accessibilityMovementDescription = "increasing"
  183|      0|
  184|      0|                    let color = dataSet.increasingColor ?? dataSet.color(atIndex: j)
  185|      0|                    
  186|      0|                    if dataSet.isIncreasingFilled
  187|      0|                    {
  188|      0|                        context.setFillColor(color.cgColor)
  189|      0|                        context.fill(_bodyRect)
  190|      0|                    }
  191|      0|                    else
  192|      0|                    {
  193|      0|                        context.setStrokeColor(color.cgColor)
  194|      0|                        context.stroke(_bodyRect)
  195|      0|                    }
  196|      0|                }
  197|      0|                else
  198|      0|                {
  199|      0|                    let color = dataSet.neutralColor ?? dataSet.color(atIndex: j)
  200|      0|                    
  201|      0|                    context.setStrokeColor(color.cgColor)
  202|      0|                    context.stroke(_bodyRect)
  203|      0|                }
  204|      0|            }
  205|      0|            else
  206|      0|            {
  207|      0|                _rangePoints[0].x = CGFloat(xPos)
  208|      0|                _rangePoints[0].y = CGFloat(high * phaseY)
  209|      0|                _rangePoints[1].x = CGFloat(xPos)
  210|      0|                _rangePoints[1].y = CGFloat(low * phaseY)
  211|      0|
  212|      0|                _openPoints[0].x = CGFloat(xPos) - 0.5 + barSpace
  213|      0|                _openPoints[0].y = CGFloat(open * phaseY)
  214|      0|                _openPoints[1].x = CGFloat(xPos)
  215|      0|                _openPoints[1].y = CGFloat(open * phaseY)
  216|      0|
  217|      0|                _closePoints[0].x = CGFloat(xPos) + 0.5 - barSpace
  218|      0|                _closePoints[0].y = CGFloat(close * phaseY)
  219|      0|                _closePoints[1].x = CGFloat(xPos)
  220|      0|                _closePoints[1].y = CGFloat(close * phaseY)
  221|      0|                
  222|      0|                trans.pointValuesToPixel(&_rangePoints)
  223|      0|                trans.pointValuesToPixel(&_openPoints)
  224|      0|                trans.pointValuesToPixel(&_closePoints)
  225|      0|                
  226|      0|                // draw the ranges
  227|      0|                var barColor: NSUIColor! = nil
  228|      0|
  229|      0|                if open > close
  230|      0|                {
  231|      0|                    accessibilityMovementDescription = "decreasing"
  232|      0|                    barColor = dataSet.decreasingColor ?? dataSet.color(atIndex: j)
  233|      0|                }
  234|      0|                else if open < close
  235|      0|                {
  236|      0|                    accessibilityMovementDescription = "increasing"
  237|      0|                    barColor = dataSet.increasingColor ?? dataSet.color(atIndex: j)
  238|      0|                }
  239|      0|                else
  240|      0|                {
  241|      0|                    barColor = dataSet.neutralColor ?? dataSet.color(atIndex: j)
  242|      0|                }
  243|      0|                
  244|      0|                context.setStrokeColor(barColor.cgColor)
  245|      0|                context.strokeLineSegments(between: _rangePoints)
  246|      0|                context.strokeLineSegments(between: _openPoints)
  247|      0|                context.strokeLineSegments(between: _closePoints)
  248|      0|            }
  249|      0|
  250|      0|            let axElement = createAccessibleElement(withIndex: j,
  251|      0|                                                    container: dataProvider,
  252|      0|                                                    dataSet: dataSet)
  253|      0|            { (element) in
  254|      0|                element.accessibilityLabel = "\(doesContainMultipleDataSets ? "\(dataSet.label ?? "Dataset")" : "") " + "\(xPos) - \(accessibilityMovementDescription). low: \(low), high: \(high), opening: \(open), closing: \(close)"
  255|      0|                element.accessibilityFrame = accessibilityRect
  256|      0|            }
  257|      0|
  258|      0|            accessibleChartElements.append(axElement)
  259|      0|
  260|      0|        }
  261|      0|
  262|      0|        // Post this notification to let VoiceOver account for the redrawn frames
  263|      0|        accessibilityPostLayoutChangedNotification()
  264|      0|
  265|      0|        context.restoreGState()
  266|      0|    }
  267|       |    
  268|       |    open override func drawValues(context: CGContext)
  269|      0|    {
  270|      0|        guard
  271|      0|            let dataProvider = dataProvider,
  272|      0|            let candleData = dataProvider.candleData
  273|      0|            else { return }
  274|      0|        
  275|      0|        // if values are drawn
  276|      0|        if isDrawingValuesAllowed(dataProvider: dataProvider)
  277|      0|        {
  278|      0|            let dataSets = candleData.dataSets
  279|      0|            
  280|      0|            let phaseY = animator.phaseY
  281|      0|            
  282|      0|            var pt = CGPoint()
  283|      0|            
  284|      0|            for i in 0 ..< dataSets.count
  285|      0|            {
  286|      0|                guard let
  287|      0|                    dataSet = dataSets[i] as? IBarLineScatterCandleBubbleChartDataSet,
  288|      0|                    shouldDrawValues(forDataSet: dataSet)
  289|      0|                    else { continue }
  290|      0|                
  291|      0|                let valueFont = dataSet.valueFont
  292|      0|                
  293|      0|                guard let formatter = dataSet.valueFormatter else { continue }
  294|      0|                
  295|      0|                let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  296|      0|                let valueToPixelMatrix = trans.valueToPixelMatrix
  297|      0|                
  298|      0|                let iconsOffset = dataSet.iconsOffset
  299|      0|                
  300|      0|                _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
  301|      0|                
  302|      0|                let lineHeight = valueFont.lineHeight
  303|      0|                let yOffset: CGFloat = lineHeight + 5.0
  304|      0|                
  305|      0|                for j in _xBounds
  306|      0|                {
  307|      0|                    guard let e = dataSet.entryForIndex(j) as? CandleChartDataEntry else { break }
  308|      0|                    
  309|      0|                    pt.x = CGFloat(e.x)
  310|      0|                    pt.y = CGFloat(e.high * phaseY)
  311|      0|                    pt = pt.applying(valueToPixelMatrix)
  312|      0|                    
  313|      0|                    if (!viewPortHandler.isInBoundsRight(pt.x))
  314|      0|                    {
  315|      0|                        break
  316|      0|                    }
  317|      0|                    
  318|      0|                    if (!viewPortHandler.isInBoundsLeft(pt.x) || !viewPortHandler.isInBoundsY(pt.y))
  319|      0|                    {
  320|      0|                        continue
  321|      0|                    }
  322|      0|                    
  323|      0|                    if dataSet.isDrawValuesEnabled
  324|      0|                    {
  325|      0|                        ChartUtils.drawText(
  326|      0|                            context: context,
  327|      0|                            text: formatter.stringForValue(
  328|      0|                                e.high,
  329|      0|                                entry: e,
  330|      0|                                dataSetIndex: i,
  331|      0|                                viewPortHandler: viewPortHandler),
  332|      0|                            point: CGPoint(
  333|      0|                                x: pt.x,
  334|      0|                                y: pt.y - yOffset),
  335|      0|                            align: .center,
  336|      0|                            attributes: [NSAttributedString.Key.font: valueFont, NSAttributedString.Key.foregroundColor: dataSet.valueTextColorAt(j)])
  337|      0|                    }
  338|      0|                    
  339|      0|                    if let icon = e.icon, dataSet.isDrawIconsEnabled
  340|      0|                    {
  341|      0|                        ChartUtils.drawImage(context: context,
  342|      0|                                             image: icon,
  343|      0|                                             x: pt.x + iconsOffset.x,
  344|      0|                                             y: pt.y + iconsOffset.y,
  345|      0|                                             size: icon.size)
  346|      0|                    }
  347|      0|                }
  348|      0|            }
  349|      0|        }
  350|      0|    }
  351|       |    
  352|       |    open override func drawExtras(context: CGContext)
  353|      0|    {
  354|      0|    }
  355|       |    
  356|       |    open override func drawHighlighted(context: CGContext, indices: [Highlight])
  357|      0|    {
  358|      0|        guard
  359|      0|            let dataProvider = dataProvider,
  360|      0|            let candleData = dataProvider.candleData
  361|      0|            else { return }
  362|      0|        
  363|      0|        context.saveGState()
  364|      0|        
  365|      0|        for high in indices
  366|      0|        {
  367|      0|            guard
  368|      0|                let set = candleData.getDataSetByIndex(high.dataSetIndex) as? ICandleChartDataSet,
  369|      0|                set.isHighlightEnabled
  370|      0|                else { continue }
  371|      0|            
  372|      0|            guard let e = set.entryForXValue(high.x, closestToY: high.y) as? CandleChartDataEntry else { continue }
  373|      0|            
  374|      0|            if !isInBoundsX(entry: e, dataSet: set)
  375|      0|            {
  376|      0|                continue
  377|      0|            }
  378|      0|            
  379|      0|            let trans = dataProvider.getTransformer(forAxis: set.axisDependency)
  380|      0|            
  381|      0|            context.setStrokeColor(set.highlightColor.cgColor)
  382|      0|            context.setLineWidth(set.highlightLineWidth)
  383|      0|            
  384|      0|            if set.highlightLineDashLengths != nil
  385|      0|            {
  386|      0|                context.setLineDash(phase: set.highlightLineDashPhase, lengths: set.highlightLineDashLengths!)
  387|      0|            }
  388|      0|            else
  389|      0|            {
  390|      0|                context.setLineDash(phase: 0.0, lengths: [])
  391|      0|            }
  392|      0|            
  393|      0|            let lowValue = e.low * Double(animator.phaseY)
  394|      0|            let highValue = e.high * Double(animator.phaseY)
  395|      0|            let y = (lowValue + highValue) / 2.0
  396|      0|            
  397|      0|            let pt = trans.pixelForValues(x: e.x, y: y)
  398|      0|            
  399|      0|            high.setDraw(pt: pt)
  400|      0|            
  401|      0|            // draw the lines
  402|      0|            drawHighlightLines(context: context, point: pt, set: set)
  403|      0|        }
  404|      0|        
  405|      0|        context.restoreGState()
  406|      0|    }
  407|       |
  408|       |    private func createAccessibleElement(withIndex idx: Int,
  409|       |                                         container: CandleChartDataProvider,
  410|       |                                         dataSet: ICandleChartDataSet,
  411|      0|                                         modifier: (NSUIAccessibilityElement) -> ()) -> NSUIAccessibilityElement {
  412|      0|
  413|      0|        let element = NSUIAccessibilityElement(accessibilityContainer: container)
  414|      0|
  415|      0|        // The modifier allows changing of traits and frame depending on highlight, rotation, etc
  416|      0|        modifier(element)
  417|      0|
  418|      0|        return element
  419|      0|    }
  420|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/ChartDataRendererBase.swift:
    1|       |//
    2|       |//  DataRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |@objc(ChartDataRendererBase)
   24|       |open class DataRenderer: Renderer
   25|       |{
   26|       |    /// An array of accessibility elements that are presented to the ChartViewBase accessibility methods.
   27|       |    ///
   28|       |    /// Note that the order of elements in this array determines the order in which they are presented and navigated by
   29|       |    /// Accessibility clients such as VoiceOver.
   30|       |    ///
   31|       |    /// Renderers should ensure that the order of elements makes sense to a client presenting an audio-only interface to a user.
   32|       |    /// Subclasses should populate this array in drawData() or drawDataSet() to make the chart accessible.
   33|      0|    @objc final var accessibleChartElements: [NSUIAccessibilityElement] = []
   34|       |
   35|       |    @objc public let animator: Animator
   36|       |    
   37|       |    @objc public init(animator: Animator, viewPortHandler: ViewPortHandler)
   38|      0|    {
   39|      0|        self.animator = animator
   40|      0|
   41|      0|        super.init(viewPortHandler: viewPortHandler)
   42|      0|    }
   43|       |
   44|       |    @objc open func drawData(context: CGContext)
   45|      0|    {
   46|      0|        fatalError("drawData() cannot be called on DataRenderer")
   47|      0|    }
   48|       |    
   49|       |    @objc open func drawValues(context: CGContext)
   50|      0|    {
   51|      0|        fatalError("drawValues() cannot be called on DataRenderer")
   52|      0|    }
   53|       |    
   54|       |    @objc open func drawExtras(context: CGContext)
   55|      0|    {
   56|      0|        fatalError("drawExtras() cannot be called on DataRenderer")
   57|      0|    }
   58|       |    
   59|       |    /// Draws all highlight indicators for the values that are currently highlighted.
   60|       |    ///
   61|       |    /// - Parameters:
   62|       |    ///   - indices: the highlighted values
   63|       |    @objc open func drawHighlighted(context: CGContext, indices: [Highlight])
   64|      0|    {
   65|      0|        fatalError("drawHighlighted() cannot be called on DataRenderer")
   66|      0|    }
   67|       |    
   68|       |    /// An opportunity for initializing internal buffers used for rendering with a new size.
   69|       |    /// Since this might do memory allocations, it should only be called if necessary.
   70|      0|    @objc open func initBuffers() { }
   71|       |    
   72|       |    @objc open func isDrawingValuesAllowed(dataProvider: ChartDataProvider?) -> Bool
   73|      0|    {
   74|      0|        guard let data = dataProvider?.data else { return false }
   75|      0|        return data.entryCount < Int(CGFloat(dataProvider?.maxVisibleCount ?? 0) * viewPortHandler.scaleX)
   76|      0|    }
   77|       |
   78|       |    /// Creates an ```NSUIAccessibilityElement``` that acts as the first and primary header describing a chart view.
   79|       |    ///
   80|       |    /// - Parameters:
   81|       |    ///   - chart: The chartView object being described
   82|       |    ///   - data: A non optional data source about the chart
   83|       |    ///   - defaultDescription: A simple string describing the type/design of Chart.
   84|       |    /// - Returns: A header ```NSUIAccessibilityElement``` that can be added to accessibleChartElements.
   85|       |    @objc internal func createAccessibleHeader(usingChart chart: ChartViewBase,
   86|       |                                        andData data: ChartData,
   87|       |                                        withDefaultDescription defaultDescription: String = "Chart") -> NSUIAccessibilityElement
   88|      0|    {
   89|      0|        let chartDescriptionText = chart.chartDescription?.text ?? defaultDescription
   90|      0|        let dataSetDescriptions = data.dataSets.map { $0.label ?? "" }
   91|      0|        let dataSetDescriptionText = dataSetDescriptions.joined(separator: ", ")
   92|      0|        let dataSetCount = data.dataSets.count
   93|      0|
   94|      0|        let
   95|      0|        element = NSUIAccessibilityElement(accessibilityContainer: chart)
   96|      0|        element.accessibilityLabel = chartDescriptionText + ". \(dataSetCount) dataset\(dataSetCount == 1 ? "" : "s"). \(dataSetDescriptionText)"
   97|      0|        element.accessibilityFrame = chart.bounds
   98|      0|        element.isHeader = true
   99|      0|
  100|      0|        return element
  101|      0|    }
  102|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/CombinedChartRenderer.swift:
    1|       |//
    2|       |//  CombinedChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class CombinedChartRenderer: DataRenderer
   16|       |{
   17|       |    @objc open weak var chart: CombinedChartView?
   18|       |    
   19|       |    /// if set to true, all values are drawn above their bars, instead of below their top
   20|       |    @objc open var drawValueAboveBarEnabled = true
   21|       |    
   22|       |    /// if set to true, a grey area is drawn behind each bar that indicates the maximum value
   23|       |    @objc open var drawBarShadowEnabled = false
   24|       |    
   25|      0|    internal var _renderers = [DataRenderer]()
   26|       |    
   27|      0|    internal var _drawOrder: [CombinedChartView.DrawOrder] = [.bar, .bubble, .line, .candle, .scatter]
   28|       |    
   29|       |    @objc public init(chart: CombinedChartView, animator: Animator, viewPortHandler: ViewPortHandler)
   30|      0|    {
   31|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   32|      0|        
   33|      0|        self.chart = chart
   34|      0|        
   35|      0|        createRenderers()
   36|      0|    }
   37|       |    
   38|       |    /// Creates the renderers needed for this combined-renderer in the required order. Also takes the DrawOrder into consideration.
   39|       |    internal func createRenderers()
   40|      0|    {
   41|      0|        _renderers = [DataRenderer]()
   42|      0|        
   43|      0|        guard let chart = chart else { return }
   44|      0|
   45|      0|        for order in drawOrder
   46|      0|        {
   47|      0|            switch (order)
   48|      0|            {
   49|      0|            case .bar:
   50|      0|                if chart.barData !== nil
   51|      0|                {
   52|      0|                    _renderers.append(BarChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
   53|      0|                }
   54|      0|                break
   55|      0|                
   56|      0|            case .line:
   57|      0|                if chart.lineData !== nil
   58|      0|                {
   59|      0|                    _renderers.append(LineChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
   60|      0|                }
   61|      0|                break
   62|      0|                
   63|      0|            case .candle:
   64|      0|                if chart.candleData !== nil
   65|      0|                {
   66|      0|                    _renderers.append(CandleStickChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
   67|      0|                }
   68|      0|                break
   69|      0|                
   70|      0|            case .scatter:
   71|      0|                if chart.scatterData !== nil
   72|      0|                {
   73|      0|                    _renderers.append(ScatterChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
   74|      0|                }
   75|      0|                break
   76|      0|                
   77|      0|            case .bubble:
   78|      0|                if chart.bubbleData !== nil
   79|      0|                {
   80|      0|                    _renderers.append(BubbleChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
   81|      0|                }
   82|      0|                break
   83|      0|            }
   84|      0|        }
   85|      0|
   86|      0|    }
   87|       |    
   88|       |    open override func initBuffers()
   89|      0|    {
   90|      0|        _renderers.forEach { $0.initBuffers() }
   91|      0|    }
   92|       |    
   93|       |    open override func drawData(context: CGContext)
   94|      0|    {
   95|      0|        // If we redraw the data, remove and repopulate accessible elements to update label values and frames
   96|      0|        accessibleChartElements.removeAll()
   97|      0|
   98|      0|        if
   99|      0|            let combinedChart = chart,
  100|      0|            let data = combinedChart.data {
  101|      0|            // Make the chart header the first element in the accessible elements array
  102|      0|            let element = createAccessibleHeader(usingChart: combinedChart,
  103|      0|                                                 andData: data,
  104|      0|                                                 withDefaultDescription: "Combined Chart")
  105|      0|            accessibleChartElements.append(element)
  106|      0|        }
  107|      0|
  108|      0|        // TODO: Due to the potential complexity of data presented in Combined charts, a more usable way
  109|      0|        // for VO accessibility would be to use axis based traversal rather than by dataset.
  110|      0|        // Hence, accessibleChartElements is not populated below. (Individual renderers guard against dataSource being their respective views)
  111|      0|        _renderers.forEach { $0.drawData(context: context) }
  112|      0|    }
  113|       |    
  114|       |    open override func drawValues(context: CGContext)
  115|      0|    {
  116|      0|        _renderers.forEach { $0.drawValues(context: context) }
  117|      0|    }
  118|       |    
  119|       |    open override func drawExtras(context: CGContext)
  120|      0|    {
  121|      0|        _renderers.forEach { $0.drawExtras(context: context) }
  122|      0|    }
  123|       |    
  124|       |    open override func drawHighlighted(context: CGContext, indices: [Highlight])
  125|      0|    {
  126|      0|        for renderer in _renderers
  127|      0|        {
  128|      0|            var data: ChartData?
  129|      0|            
  130|      0|            if renderer is BarChartRenderer
  131|      0|            {
  132|      0|                data = (renderer as! BarChartRenderer).dataProvider?.barData
  133|      0|            }
  134|      0|            else if renderer is LineChartRenderer
  135|      0|            {
  136|      0|                data = (renderer as! LineChartRenderer).dataProvider?.lineData
  137|      0|            }
  138|      0|            else if renderer is CandleStickChartRenderer
  139|      0|            {
  140|      0|                data = (renderer as! CandleStickChartRenderer).dataProvider?.candleData
  141|      0|            }
  142|      0|            else if renderer is ScatterChartRenderer
  143|      0|            {
  144|      0|                data = (renderer as! ScatterChartRenderer).dataProvider?.scatterData
  145|      0|            }
  146|      0|            else if renderer is BubbleChartRenderer
  147|      0|            {
  148|      0|                data = (renderer as! BubbleChartRenderer).dataProvider?.bubbleData
  149|      0|            }
  150|      0|            
  151|      0|            let dataIndex: Int? = {
  152|      0|                guard let data = data else { return nil }
  153|      0|                return (chart?.data as? CombinedChartData)?
  154|      0|                    .allData
  155|      0|                    .firstIndex(of: data)
  156|      0|            }()
  157|      0|            
  158|      0|            let dataIndices = indices.filter{ $0.dataIndex == dataIndex || $0.dataIndex == -1 }
  159|      0|            
  160|      0|            renderer.drawHighlighted(context: context, indices: dataIndices)
  161|      0|        }
  162|      0|    }
  163|       |
  164|       |    /// - Returns: The sub-renderer object at the specified index.
  165|       |    @objc open func getSubRenderer(index: Int) -> DataRenderer?
  166|      0|    {
  167|      0|        if index >= _renderers.count || index < 0
  168|      0|        {
  169|      0|            return nil
  170|      0|        }
  171|      0|        else
  172|      0|        {
  173|      0|            return _renderers[index]
  174|      0|        }
  175|      0|    }
  176|       |
  177|       |    /// All sub-renderers.
  178|       |    @objc open var subRenderers: [DataRenderer]
  179|       |    {
  180|      0|        get { return _renderers }
  181|      0|        set { _renderers = newValue }
  182|       |    }
  183|       |    
  184|       |    // MARK: Accessors
  185|       |    
  186|       |    /// `true` if drawing values above bars is enabled, `false` ifnot
  187|      0|    @objc open var isDrawValueAboveBarEnabled: Bool { return drawValueAboveBarEnabled }
  188|       |    
  189|       |    /// `true` if drawing shadows (maxvalue) for each bar is enabled, `false` ifnot
  190|      0|    @objc open var isDrawBarShadowEnabled: Bool { return drawBarShadowEnabled }
  191|       |    
  192|       |    /// the order in which the provided data objects should be drawn.
  193|       |    /// The earlier you place them in the provided array, the further they will be in the background.
  194|       |    /// e.g. if you provide [DrawOrder.Bar, DrawOrder.Line], the bars will be drawn behind the lines.
  195|       |    open var drawOrder: [CombinedChartView.DrawOrder]
  196|       |    {
  197|       |        get
  198|      0|        {
  199|      0|            return _drawOrder
  200|      0|        }
  201|       |        set
  202|      0|        {
  203|      0|            if newValue.count > 0
  204|      0|            {
  205|      0|                _drawOrder = newValue
  206|      0|            }
  207|      0|        }
  208|       |    }
  209|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/HorizontalBarChartRenderer.swift:
    1|       |//
    2|       |//  HorizontalBarChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |open class HorizontalBarChartRenderer: BarChartRenderer
   24|       |{
   25|       |    private class Buffer
   26|       |    {
   27|       |        var rects = [CGRect]()
   28|       |    }
   29|       |    
   30|       |    public override init(dataProvider: BarChartDataProvider, animator: Animator, viewPortHandler: ViewPortHandler)
   31|      0|    {
   32|      0|        super.init(dataProvider: dataProvider, animator: animator, viewPortHandler: viewPortHandler)
   33|      0|    }
   34|       |    
   35|       |    // [CGRect] per dataset
   36|      0|    private var _buffers = [Buffer]()
   37|       |    
   38|       |    open override func initBuffers()
   39|      0|    {
   40|      0|        if let barData = dataProvider?.barData
   41|      0|        {
   42|      0|            // Matche buffers count to dataset count
   43|      0|            if _buffers.count != barData.dataSetCount
   44|      0|            {
   45|      0|                while _buffers.count < barData.dataSetCount
   46|      0|                {
   47|      0|                    _buffers.append(Buffer())
   48|      0|                }
   49|      0|                while _buffers.count > barData.dataSetCount
   50|      0|                {
   51|      0|                    _buffers.removeLast()
   52|      0|                }
   53|      0|            }
   54|      0|            
   55|      0|            for i in stride(from: 0, to: barData.dataSetCount, by: 1)
   56|      0|            {
   57|      0|                let set = barData.dataSets[i] as! IBarChartDataSet
   58|      0|                let size = set.entryCount * (set.isStacked ? set.stackSize : 1)
   59|      0|                if _buffers[i].rects.count != size
   60|      0|                {
   61|      0|                    _buffers[i].rects = [CGRect](repeating: CGRect(), count: size)
   62|      0|                }
   63|      0|            }
   64|      0|        }
   65|      0|        else
   66|      0|        {
   67|      0|            _buffers.removeAll()
   68|      0|        }
   69|      0|    }
   70|       |    
   71|       |    private func prepareBuffer(dataSet: IBarChartDataSet, index: Int)
   72|      0|    {
   73|      0|        guard let
   74|      0|            dataProvider = dataProvider,
   75|      0|            let barData = dataProvider.barData
   76|      0|            else { return }
   77|      0|        
   78|      0|        let barWidthHalf = barData.barWidth / 2.0
   79|      0|        
   80|      0|        let buffer = _buffers[index]
   81|      0|        var bufferIndex = 0
   82|      0|        let containsStacks = dataSet.isStacked
   83|      0|        
   84|      0|        let isInverted = dataProvider.isInverted(axis: dataSet.axisDependency)
   85|      0|        let phaseY = animator.phaseY
   86|      0|        var barRect = CGRect()
   87|      0|        var x: Double
   88|      0|        var y: Double
   89|      0|        
   90|      0|        for i in stride(from: 0, to: min(Int(ceil(Double(dataSet.entryCount) * animator.phaseX)), dataSet.entryCount), by: 1)
   91|      0|        {
   92|      0|            guard let e = dataSet.entryForIndex(i) as? BarChartDataEntry else { continue }
   93|      0|            
   94|      0|            let vals = e.yValues
   95|      0|            
   96|      0|            x = e.x
   97|      0|            y = e.y
   98|      0|            
   99|      0|            if !containsStacks || vals == nil
  100|      0|            {
  101|      0|                let bottom = CGFloat(x - barWidthHalf)
  102|      0|                let top = CGFloat(x + barWidthHalf)
  103|      0|                var right = isInverted
  104|      0|                    ? (y <= 0.0 ? CGFloat(y) : 0)
  105|      0|                    : (y >= 0.0 ? CGFloat(y) : 0)
  106|      0|                var left = isInverted
  107|      0|                    ? (y >= 0.0 ? CGFloat(y) : 0)
  108|      0|                    : (y <= 0.0 ? CGFloat(y) : 0)
  109|      0|                
  110|      0|                // multiply the height of the rect with the phase
  111|      0|                if right > 0
  112|      0|                {
  113|      0|                    right *= CGFloat(phaseY)
  114|      0|                }
  115|      0|                else
  116|      0|                {
  117|      0|                    left *= CGFloat(phaseY)
  118|      0|                }
  119|      0|                
  120|      0|                barRect.origin.x = left
  121|      0|                barRect.size.width = right - left
  122|      0|                barRect.origin.y = top
  123|      0|                barRect.size.height = bottom - top
  124|      0|                
  125|      0|                buffer.rects[bufferIndex] = barRect
  126|      0|                bufferIndex += 1
  127|      0|            }
  128|      0|            else
  129|      0|            {
  130|      0|                var posY = 0.0
  131|      0|                var negY = -e.negativeSum
  132|      0|                var yStart = 0.0
  133|      0|                
  134|      0|                // fill the stack
  135|      0|                for k in 0 ..< vals!.count
  136|      0|                {
  137|      0|                    let value = vals![k]
  138|      0|                    
  139|      0|                    if value == 0.0 && (posY == 0.0 || negY == 0.0)
  140|      0|                    {
  141|      0|                        // Take care of the situation of a 0.0 value, which overlaps a non-zero bar
  142|      0|                        y = value
  143|      0|                        yStart = y
  144|      0|                    }
  145|      0|                    else if value >= 0.0
  146|      0|                    {
  147|      0|                        y = posY
  148|      0|                        yStart = posY + value
  149|      0|                        posY = yStart
  150|      0|                    }
  151|      0|                    else
  152|      0|                    {
  153|      0|                        y = negY
  154|      0|                        yStart = negY + abs(value)
  155|      0|                        negY += abs(value)
  156|      0|                    }
  157|      0|                    
  158|      0|                    let bottom = CGFloat(x - barWidthHalf)
  159|      0|                    let top = CGFloat(x + barWidthHalf)
  160|      0|                    var right = isInverted
  161|      0|                        ? (y <= yStart ? CGFloat(y) : CGFloat(yStart))
  162|      0|                        : (y >= yStart ? CGFloat(y) : CGFloat(yStart))
  163|      0|                    var left = isInverted
  164|      0|                        ? (y >= yStart ? CGFloat(y) : CGFloat(yStart))
  165|      0|                        : (y <= yStart ? CGFloat(y) : CGFloat(yStart))
  166|      0|                    
  167|      0|                    // multiply the height of the rect with the phase
  168|      0|                    right *= CGFloat(phaseY)
  169|      0|                    left *= CGFloat(phaseY)
  170|      0|                    
  171|      0|                    barRect.origin.x = left
  172|      0|                    barRect.size.width = right - left
  173|      0|                    barRect.origin.y = top
  174|      0|                    barRect.size.height = bottom - top
  175|      0|                    
  176|      0|                    buffer.rects[bufferIndex] = barRect
  177|      0|                    bufferIndex += 1
  178|      0|                }
  179|      0|            }
  180|      0|        }
  181|      0|    }
  182|       |    
  183|      0|    private var _barShadowRectBuffer: CGRect = CGRect()
  184|       |    
  185|       |    open override func drawDataSet(context: CGContext, dataSet: IBarChartDataSet, index: Int)
  186|      0|    {
  187|      0|        guard let dataProvider = dataProvider else { return }
  188|      0|        
  189|      0|        let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  190|      0|        
  191|      0|        prepareBuffer(dataSet: dataSet, index: index)
  192|      0|        trans.rectValuesToPixel(&_buffers[index].rects)
  193|      0|        
  194|      0|        let borderWidth = dataSet.barBorderWidth
  195|      0|        let borderColor = dataSet.barBorderColor
  196|      0|        let drawBorder = borderWidth > 0.0
  197|      0|        
  198|      0|        context.saveGState()
  199|      0|        
  200|      0|        // draw the bar shadow before the values
  201|      0|        if dataProvider.isDrawBarShadowEnabled
  202|      0|        {
  203|      0|            guard let barData = dataProvider.barData else { return }
  204|      0|            
  205|      0|            let barWidth = barData.barWidth
  206|      0|            let barWidthHalf = barWidth / 2.0
  207|      0|            var x: Double = 0.0
  208|      0|            
  209|      0|            for i in stride(from: 0, to: min(Int(ceil(Double(dataSet.entryCount) * animator.phaseX)), dataSet.entryCount), by: 1)
  210|      0|            {
  211|      0|                guard let e = dataSet.entryForIndex(i) as? BarChartDataEntry else { continue }
  212|      0|                
  213|      0|                x = e.x
  214|      0|                
  215|      0|                _barShadowRectBuffer.origin.y = CGFloat(x - barWidthHalf)
  216|      0|                _barShadowRectBuffer.size.height = CGFloat(barWidth)
  217|      0|                
  218|      0|                trans.rectValueToPixel(&_barShadowRectBuffer)
  219|      0|                
  220|      0|                if !viewPortHandler.isInBoundsTop(_barShadowRectBuffer.origin.y + _barShadowRectBuffer.size.height)
  221|      0|                {
  222|      0|                    break
  223|      0|                }
  224|      0|                
  225|      0|                if !viewPortHandler.isInBoundsBottom(_barShadowRectBuffer.origin.y)
  226|      0|                {
  227|      0|                    continue
  228|      0|                }
  229|      0|                
  230|      0|                _barShadowRectBuffer.origin.x = viewPortHandler.contentLeft
  231|      0|                _barShadowRectBuffer.size.width = viewPortHandler.contentWidth
  232|      0|                
  233|      0|                context.setFillColor(dataSet.barShadowColor.cgColor)
  234|      0|                context.fill(_barShadowRectBuffer)
  235|      0|            }
  236|      0|        }
  237|      0|        
  238|      0|        let buffer = _buffers[index]
  239|      0|        
  240|      0|        let isSingleColor = dataSet.colors.count == 1
  241|      0|        
  242|      0|        if isSingleColor
  243|      0|        {
  244|      0|            context.setFillColor(dataSet.color(atIndex: 0).cgColor)
  245|      0|        }
  246|      0|
  247|      0|        // In case the chart is stacked, we need to accomodate individual bars within accessibilityOrdereredElements
  248|      0|        let isStacked = dataSet.isStacked
  249|      0|        let stackSize = isStacked ? dataSet.stackSize : 1
  250|      0|
  251|      0|        for j in stride(from: 0, to: buffer.rects.count, by: 1)
  252|      0|        {
  253|      0|            let barRect = buffer.rects[j]
  254|      0|            
  255|      0|            if (!viewPortHandler.isInBoundsTop(barRect.origin.y + barRect.size.height))
  256|      0|            {
  257|      0|                break
  258|      0|            }
  259|      0|            
  260|      0|            if (!viewPortHandler.isInBoundsBottom(barRect.origin.y))
  261|      0|            {
  262|      0|                continue
  263|      0|            }
  264|      0|            
  265|      0|            if !isSingleColor
  266|      0|            {
  267|      0|                // Set the color for the currently drawn value. If the index is out of bounds, reuse colors.
  268|      0|                context.setFillColor(dataSet.color(atIndex: j).cgColor)
  269|      0|            }
  270|      0|
  271|      0|            context.fill(barRect)
  272|      0|
  273|      0|            if drawBorder
  274|      0|            {
  275|      0|                context.setStrokeColor(borderColor.cgColor)
  276|      0|                context.setLineWidth(borderWidth)
  277|      0|                context.stroke(barRect)
  278|      0|            }
  279|      0|
  280|      0|            // Create and append the corresponding accessibility element to accessibilityOrderedElements (see BarChartRenderer)
  281|      0|            if let chart = dataProvider as? BarChartView
  282|      0|            {
  283|      0|                let element = createAccessibleElement(withIndex: j,
  284|      0|                                                      container: chart,
  285|      0|                                                      dataSet: dataSet,
  286|      0|                                                      dataSetIndex: index,
  287|      0|                                                      stackSize: stackSize)
  288|      0|                { (element) in
  289|      0|                    element.accessibilityFrame = barRect
  290|      0|                }
  291|      0|
  292|      0|                accessibilityOrderedElements[j/stackSize].append(element)
  293|      0|            }
  294|      0|        }
  295|      0|        
  296|      0|        context.restoreGState()
  297|      0|    }
  298|       |    
  299|       |    open override func prepareBarHighlight(
  300|       |        x: Double,
  301|       |        y1: Double,
  302|       |        y2: Double,
  303|       |        barWidthHalf: Double,
  304|       |        trans: Transformer,
  305|       |        rect: inout CGRect)
  306|      0|    {
  307|      0|        let top = x - barWidthHalf
  308|      0|        let bottom = x + barWidthHalf
  309|      0|        let left = y1
  310|      0|        let right = y2
  311|      0|        
  312|      0|        rect.origin.x = CGFloat(left)
  313|      0|        rect.origin.y = CGFloat(top)
  314|      0|        rect.size.width = CGFloat(right - left)
  315|      0|        rect.size.height = CGFloat(bottom - top)
  316|      0|        
  317|      0|        trans.rectValueToPixelHorizontal(&rect, phaseY: animator.phaseY)
  318|      0|    }
  319|       |    
  320|       |    open override func drawValues(context: CGContext)
  321|      0|    {
  322|      0|        // if values are drawn
  323|      0|        if isDrawingValuesAllowed(dataProvider: dataProvider)
  324|      0|        {
  325|      0|            guard
  326|      0|                let dataProvider = dataProvider,
  327|      0|                let barData = dataProvider.barData
  328|      0|                else { return }
  329|      0|            
  330|      0|            let dataSets = barData.dataSets
  331|      0|            
  332|      0|            let textAlign = NSTextAlignment.left
  333|      0|            
  334|      0|            let valueOffsetPlus: CGFloat = 5.0
  335|      0|            var posOffset: CGFloat
  336|      0|            var negOffset: CGFloat
  337|      0|            let drawValueAboveBar = dataProvider.isDrawValueAboveBarEnabled
  338|      0|            
  339|      0|            for dataSetIndex in 0 ..< barData.dataSetCount
  340|      0|            {
  341|      0|                guard let
  342|      0|                    dataSet = dataSets[dataSetIndex] as? IBarChartDataSet,
  343|      0|                    shouldDrawValues(forDataSet: dataSet)
  344|      0|                    else { continue }
  345|      0|                
  346|      0|                let isInverted = dataProvider.isInverted(axis: dataSet.axisDependency)
  347|      0|                
  348|      0|                let valueFont = dataSet.valueFont
  349|      0|                let yOffset = -valueFont.lineHeight / 2.0
  350|      0|                
  351|      0|                guard let formatter = dataSet.valueFormatter else { continue }
  352|      0|                
  353|      0|                let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  354|      0|                
  355|      0|                let phaseY = animator.phaseY
  356|      0|                
  357|      0|                let iconsOffset = dataSet.iconsOffset
  358|      0|                
  359|      0|                let buffer = _buffers[dataSetIndex]
  360|      0|                
  361|      0|                // if only single values are drawn (sum)
  362|      0|                if !dataSet.isStacked
  363|      0|                {
  364|      0|                    for j in 0 ..< Int(ceil(Double(dataSet.entryCount) * animator.phaseX))
  365|      0|                    {
  366|      0|                        guard let e = dataSet.entryForIndex(j) as? BarChartDataEntry else { continue }
  367|      0|                        
  368|      0|                        let rect = buffer.rects[j]
  369|      0|                        
  370|      0|                        let y = rect.origin.y + rect.size.height / 2.0
  371|      0|                        
  372|      0|                        if !viewPortHandler.isInBoundsTop(rect.origin.y)
  373|      0|                        {
  374|      0|                            break
  375|      0|                        }
  376|      0|                        
  377|      0|                        if !viewPortHandler.isInBoundsX(rect.origin.x)
  378|      0|                        {
  379|      0|                            continue
  380|      0|                        }
  381|      0|                        
  382|      0|                        if !viewPortHandler.isInBoundsBottom(rect.origin.y)
  383|      0|                        {
  384|      0|                            continue
  385|      0|                        }
  386|      0|                        
  387|      0|                        let val = e.y
  388|      0|                        let valueText = formatter.stringForValue(
  389|      0|                            val,
  390|      0|                            entry: e,
  391|      0|                            dataSetIndex: dataSetIndex,
  392|      0|                            viewPortHandler: viewPortHandler)
  393|      0|                        
  394|      0|                        // calculate the correct offset depending on the draw position of the value
  395|      0|                        let valueTextWidth = valueText.size(withAttributes: [NSAttributedString.Key.font: valueFont]).width
  396|      0|                        posOffset = (drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus))
  397|      0|                        negOffset = (drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus) - rect.size.width
  398|      0|                        
  399|      0|                        if isInverted
  400|      0|                        {
  401|      0|                            posOffset = -posOffset - valueTextWidth
  402|      0|                            negOffset = -negOffset - valueTextWidth
  403|      0|                        }
  404|      0|                        
  405|      0|                        if dataSet.isDrawValuesEnabled
  406|      0|                        {
  407|      0|                            drawValue(
  408|      0|                                context: context,
  409|      0|                                value: valueText,
  410|      0|                                xPos: (rect.origin.x + rect.size.width)
  411|      0|                                    + (val >= 0.0 ? posOffset : negOffset),
  412|      0|                                yPos: y + yOffset,
  413|      0|                                font: valueFont,
  414|      0|                                align: textAlign,
  415|      0|                                color: dataSet.valueTextColorAt(j))
  416|      0|                        }
  417|      0|                        
  418|      0|                        if let icon = e.icon, dataSet.isDrawIconsEnabled
  419|      0|                        {
  420|      0|                            var px = (rect.origin.x + rect.size.width)
  421|      0|                                + (val >= 0.0 ? posOffset : negOffset)
  422|      0|                            var py = y
  423|      0|                            
  424|      0|                            px += iconsOffset.x
  425|      0|                            py += iconsOffset.y
  426|      0|                            
  427|      0|                            ChartUtils.drawImage(
  428|      0|                                context: context,
  429|      0|                                image: icon,
  430|      0|                                x: px,
  431|      0|                                y: py,
  432|      0|                                size: icon.size)
  433|      0|                        }
  434|      0|                    }
  435|      0|                }
  436|      0|                else
  437|      0|                {
  438|      0|                    // if each value of a potential stack should be drawn
  439|      0|                    
  440|      0|                    var bufferIndex = 0
  441|      0|                    
  442|      0|                    for index in 0 ..< Int(ceil(Double(dataSet.entryCount) * animator.phaseX))
  443|      0|                    {
  444|      0|                        guard let e = dataSet.entryForIndex(index) as? BarChartDataEntry else { continue }
  445|      0|                        
  446|      0|                        let rect = buffer.rects[bufferIndex]
  447|      0|                        
  448|      0|                        let vals = e.yValues
  449|      0|                        
  450|      0|                        // we still draw stacked bars, but there is one non-stacked in between
  451|      0|                        if vals == nil
  452|      0|                        {
  453|      0|                            if !viewPortHandler.isInBoundsTop(rect.origin.y)
  454|      0|                            {
  455|      0|                                break
  456|      0|                            }
  457|      0|                            
  458|      0|                            if !viewPortHandler.isInBoundsX(rect.origin.x)
  459|      0|                            {
  460|      0|                                continue
  461|      0|                            }
  462|      0|                            
  463|      0|                            if !viewPortHandler.isInBoundsBottom(rect.origin.y)
  464|      0|                            {
  465|      0|                                continue
  466|      0|                            }
  467|      0|                            
  468|      0|                            let val = e.y
  469|      0|                            let valueText = formatter.stringForValue(
  470|      0|                                val,
  471|      0|                                entry: e,
  472|      0|                                dataSetIndex: dataSetIndex,
  473|      0|                                viewPortHandler: viewPortHandler)
  474|      0|                            
  475|      0|                            // calculate the correct offset depending on the draw position of the value
  476|      0|                            let valueTextWidth = valueText.size(withAttributes: [NSAttributedString.Key.font: valueFont]).width
  477|      0|                            posOffset = (drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus))
  478|      0|                            negOffset = (drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus)
  479|      0|                            
  480|      0|                            if isInverted
  481|      0|                            {
  482|      0|                                posOffset = -posOffset - valueTextWidth
  483|      0|                                negOffset = -negOffset - valueTextWidth
  484|      0|                            }
  485|      0|                            
  486|      0|                            if dataSet.isDrawValuesEnabled
  487|      0|                            {
  488|      0|                                drawValue(
  489|      0|                                    context: context,
  490|      0|                                    value: valueText,
  491|      0|                                    xPos: (rect.origin.x + rect.size.width)
  492|      0|                                        + (val >= 0.0 ? posOffset : negOffset),
  493|      0|                                    yPos: rect.origin.y + yOffset,
  494|      0|                                    font: valueFont,
  495|      0|                                    align: textAlign,
  496|      0|                                    color: dataSet.valueTextColorAt(index))
  497|      0|                            }
  498|      0|                            
  499|      0|                            if let icon = e.icon, dataSet.isDrawIconsEnabled
  500|      0|                            {
  501|      0|                                var px = (rect.origin.x + rect.size.width)
  502|      0|                                    + (val >= 0.0 ? posOffset : negOffset)
  503|      0|                                var py = rect.origin.y
  504|      0|                                
  505|      0|                                px += iconsOffset.x
  506|      0|                                py += iconsOffset.y
  507|      0|                                
  508|      0|                                ChartUtils.drawImage(
  509|      0|                                    context: context,
  510|      0|                                    image: icon,
  511|      0|                                    x: px,
  512|      0|                                    y: py,
  513|      0|                                    size: icon.size)
  514|      0|                            }
  515|      0|                        }
  516|      0|                        else
  517|      0|                        {
  518|      0|                            let vals = vals!
  519|      0|                            var transformed = [CGPoint]()
  520|      0|                            
  521|      0|                            var posY = 0.0
  522|      0|                            var negY = -e.negativeSum
  523|      0|                            
  524|      0|                            for k in 0 ..< vals.count
  525|      0|                            {
  526|      0|                                let value = vals[k]
  527|      0|                                var y: Double
  528|      0|                                
  529|      0|                                if value == 0.0 && (posY == 0.0 || negY == 0.0)
  530|      0|                                {
  531|      0|                                    // Take care of the situation of a 0.0 value, which overlaps a non-zero bar
  532|      0|                                    y = value
  533|      0|                                }
  534|      0|                                else if value >= 0.0
  535|      0|                                {
  536|      0|                                    posY += value
  537|      0|                                    y = posY
  538|      0|                                }
  539|      0|                                else
  540|      0|                                {
  541|      0|                                    y = negY
  542|      0|                                    negY -= value
  543|      0|                                }
  544|      0|                                
  545|      0|                                transformed.append(CGPoint(x: CGFloat(y * phaseY), y: 0.0))
  546|      0|                            }
  547|      0|                            
  548|      0|                            trans.pointValuesToPixel(&transformed)
  549|      0|                            
  550|      0|                            for k in 0 ..< transformed.count
  551|      0|                            {
  552|      0|                                let val = vals[k]
  553|      0|                                let valueText = formatter.stringForValue(
  554|      0|                                    val,
  555|      0|                                    entry: e,
  556|      0|                                    dataSetIndex: dataSetIndex,
  557|      0|                                    viewPortHandler: viewPortHandler)
  558|      0|                                
  559|      0|                                // calculate the correct offset depending on the draw position of the value
  560|      0|                                let valueTextWidth = valueText.size(withAttributes: [NSAttributedString.Key.font: valueFont]).width
  561|      0|                                posOffset = (drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus))
  562|      0|                                negOffset = (drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus)
  563|      0|                                
  564|      0|                                if isInverted
  565|      0|                                {
  566|      0|                                    posOffset = -posOffset - valueTextWidth
  567|      0|                                    negOffset = -negOffset - valueTextWidth
  568|      0|                                }
  569|      0|                                
  570|      0|                                let drawBelow = (val == 0.0 && negY == 0.0 && posY > 0.0) || val < 0.0
  571|      0|
  572|      0|                                let x = transformed[k].x + (drawBelow ? negOffset : posOffset)
  573|      0|                                let y = rect.origin.y + rect.size.height / 2.0
  574|      0|                                
  575|      0|                                if (!viewPortHandler.isInBoundsTop(y))
  576|      0|                                {
  577|      0|                                    break
  578|      0|                                }
  579|      0|                                
  580|      0|                                if (!viewPortHandler.isInBoundsX(x))
  581|      0|                                {
  582|      0|                                    continue
  583|      0|                                }
  584|      0|                                
  585|      0|                                if (!viewPortHandler.isInBoundsBottom(y))
  586|      0|                                {
  587|      0|                                    continue
  588|      0|                                }
  589|      0|                                
  590|      0|                                if dataSet.isDrawValuesEnabled
  591|      0|                                {
  592|      0|                                    drawValue(context: context,
  593|      0|                                        value: valueText,
  594|      0|                                        xPos: x,
  595|      0|                                        yPos: y + yOffset,
  596|      0|                                        font: valueFont,
  597|      0|                                        align: textAlign,
  598|      0|                                        color: dataSet.valueTextColorAt(index))
  599|      0|                                }
  600|      0|                                
  601|      0|                                if let icon = e.icon, dataSet.isDrawIconsEnabled
  602|      0|                                {
  603|      0|                                    ChartUtils.drawImage(
  604|      0|                                        context: context,
  605|      0|                                        image: icon,
  606|      0|                                        x: x + iconsOffset.x,
  607|      0|                                        y: y + iconsOffset.y,
  608|      0|                                        size: icon.size)
  609|      0|                                }
  610|      0|                            }
  611|      0|                        }
  612|      0|                        
  613|      0|                        bufferIndex = vals == nil ? (bufferIndex + 1) : (bufferIndex + vals!.count)
  614|      0|                    }
  615|      0|                }
  616|      0|            }
  617|      0|        }
  618|      0|    }
  619|       |    
  620|       |    open override func isDrawingValuesAllowed(dataProvider: ChartDataProvider?) -> Bool
  621|      0|    {
  622|      0|        guard let data = dataProvider?.data
  623|      0|            else { return false }
  624|      0|        return data.entryCount < Int(CGFloat(dataProvider?.maxVisibleCount ?? 0) * self.viewPortHandler.scaleY)
  625|      0|    }
  626|       |    
  627|       |    /// Sets the drawing position of the highlight object based on the riven bar-rect.
  628|       |    internal override func setHighlightDrawPos(highlight high: Highlight, barRect: CGRect)
  629|      0|    {
  630|      0|        high.setDraw(x: barRect.midY, y: barRect.origin.x + barRect.size.width)
  631|      0|    }
  632|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/LegendRenderer.swift:
    1|       |//
    2|       |//  LegendRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartLegendRenderer)
   16|       |open class LegendRenderer: Renderer
   17|       |{
   18|       |    /// the legend object this renderer renders
   19|       |    @objc open var legend: Legend?
   20|       |
   21|       |    @objc public init(viewPortHandler: ViewPortHandler, legend: Legend?)
   22|      0|    {
   23|      0|        super.init(viewPortHandler: viewPortHandler)
   24|      0|        
   25|      0|        self.legend = legend
   26|      0|    }
   27|       |
   28|       |    /// Prepares the legend and calculates all needed forms, labels and colors.
   29|       |    @objc open func computeLegend(data: ChartData)
   30|      0|    {
   31|      0|        guard let legend = legend else { return }
   32|      0|        
   33|      0|        if !legend.isLegendCustom
   34|      0|        {
   35|      0|            var entries: [LegendEntry] = []
   36|      0|            
   37|      0|            // loop for building up the colors and labels used in the legend
   38|      0|            for i in 0..<data.dataSetCount
   39|      0|            {
   40|      0|                guard let dataSet = data.getDataSetByIndex(i) else { continue }
   41|      0|                
   42|      0|                let clrs: [NSUIColor] = dataSet.colors
   43|      0|                let entryCount = dataSet.entryCount
   44|      0|                
   45|      0|                // if we have a barchart with stacked bars
   46|      0|                if dataSet is IBarChartDataSet &&
   47|      0|                    (dataSet as! IBarChartDataSet).isStacked
   48|      0|                {
   49|      0|                    let bds = dataSet as! IBarChartDataSet
   50|      0|                    let sLabels = bds.stackLabels
   51|      0|                    let minEntries = min(clrs.count, bds.stackSize)
   52|      0|
   53|      0|                    for j in 0..<minEntries
   54|      0|                    {
   55|      0|                        let label: String?
   56|      0|                        if (sLabels.count > 0)
   57|      0|                        {
   58|      0|                            let labelIndex = j % minEntries
   59|      0|                            label = sLabels.indices.contains(labelIndex) ? sLabels[labelIndex] : nil
   60|      0|                        }
   61|      0|                        else
   62|      0|                        {
   63|      0|                            label = nil
   64|      0|                        }
   65|      0|
   66|      0|                        entries.append(
   67|      0|                            LegendEntry(
   68|      0|                                label: label,
   69|      0|                                form: dataSet.form,
   70|      0|                                formSize: dataSet.formSize,
   71|      0|                                formLineWidth: dataSet.formLineWidth,
   72|      0|                                formLineDashPhase: dataSet.formLineDashPhase,
   73|      0|                                formLineDashLengths: dataSet.formLineDashLengths,
   74|      0|                                formColor: clrs[j]
   75|      0|                            )
   76|      0|                        )
   77|      0|                    }
   78|      0|                    
   79|      0|                    if dataSet.label != nil
   80|      0|                    {
   81|      0|                        // add the legend description label
   82|      0|                        
   83|      0|                        entries.append(
   84|      0|                            LegendEntry(
   85|      0|                                label: dataSet.label,
   86|      0|                                form: .none,
   87|      0|                                formSize: CGFloat.nan,
   88|      0|                                formLineWidth: CGFloat.nan,
   89|      0|                                formLineDashPhase: 0.0,
   90|      0|                                formLineDashLengths: nil,
   91|      0|                                formColor: nil
   92|      0|                            )
   93|      0|                        )
   94|      0|                    }
   95|      0|                }
   96|      0|                else if dataSet is IPieChartDataSet
   97|      0|                {
   98|      0|                    let pds = dataSet as! IPieChartDataSet
   99|      0|                    
  100|      0|                    for j in 0..<min(clrs.count, entryCount)
  101|      0|                    {
  102|      0|                        entries.append(
  103|      0|                            LegendEntry(
  104|      0|                                label: (pds.entryForIndex(j) as? PieChartDataEntry)?.label,
  105|      0|                                form: dataSet.form,
  106|      0|                                formSize: dataSet.formSize,
  107|      0|                                formLineWidth: dataSet.formLineWidth,
  108|      0|                                formLineDashPhase: dataSet.formLineDashPhase,
  109|      0|                                formLineDashLengths: dataSet.formLineDashLengths,
  110|      0|                                formColor: clrs[j]
  111|      0|                            )
  112|      0|                        )
  113|      0|                    }
  114|      0|                    
  115|      0|                    if dataSet.label != nil
  116|      0|                    {
  117|      0|                        // add the legend description label
  118|      0|                        
  119|      0|                        entries.append(
  120|      0|                            LegendEntry(
  121|      0|                                label: dataSet.label,
  122|      0|                                form: .none,
  123|      0|                                formSize: CGFloat.nan,
  124|      0|                                formLineWidth: CGFloat.nan,
  125|      0|                                formLineDashPhase: 0.0,
  126|      0|                                formLineDashLengths: nil,
  127|      0|                                formColor: nil
  128|      0|                            )
  129|      0|                        )
  130|      0|                    }
  131|      0|                }
  132|      0|                else if dataSet is ICandleChartDataSet &&
  133|      0|                    (dataSet as! ICandleChartDataSet).decreasingColor != nil
  134|      0|                {
  135|      0|                    let candleDataSet = dataSet as! ICandleChartDataSet
  136|      0|                    
  137|      0|                    entries.append(
  138|      0|                        LegendEntry(
  139|      0|                            label: nil,
  140|      0|                            form: dataSet.form,
  141|      0|                            formSize: dataSet.formSize,
  142|      0|                            formLineWidth: dataSet.formLineWidth,
  143|      0|                            formLineDashPhase: dataSet.formLineDashPhase,
  144|      0|                            formLineDashLengths: dataSet.formLineDashLengths,
  145|      0|                            formColor: candleDataSet.decreasingColor
  146|      0|                        )
  147|      0|                    )
  148|      0|                    
  149|      0|                    entries.append(
  150|      0|                        LegendEntry(
  151|      0|                            label: dataSet.label,
  152|      0|                            form: dataSet.form,
  153|      0|                            formSize: dataSet.formSize,
  154|      0|                            formLineWidth: dataSet.formLineWidth,
  155|      0|                            formLineDashPhase: dataSet.formLineDashPhase,
  156|      0|                            formLineDashLengths: dataSet.formLineDashLengths,
  157|      0|                            formColor: candleDataSet.increasingColor
  158|      0|                        )
  159|      0|                    )
  160|      0|                }
  161|      0|                else
  162|      0|                { // all others
  163|      0|                    
  164|      0|                    for j in 0..<min(clrs.count, entryCount)
  165|      0|                    {
  166|      0|                        let label: String?
  167|      0|                        
  168|      0|                        // if multiple colors are set for a DataSet, group them
  169|      0|                        if j < clrs.count - 1 && j < entryCount - 1
  170|      0|                        {
  171|      0|                            label = nil
  172|      0|                        }
  173|      0|                        else
  174|      0|                        { // add label to the last entry
  175|      0|                            label = dataSet.label
  176|      0|                        }
  177|      0|                        
  178|      0|                        entries.append(
  179|      0|                            LegendEntry(
  180|      0|                                label: label,
  181|      0|                                form: dataSet.form,
  182|      0|                                formSize: dataSet.formSize,
  183|      0|                                formLineWidth: dataSet.formLineWidth,
  184|      0|                                formLineDashPhase: dataSet.formLineDashPhase,
  185|      0|                                formLineDashLengths: dataSet.formLineDashLengths,
  186|      0|                                formColor: clrs[j]
  187|      0|                            )
  188|      0|                        )
  189|      0|                    }
  190|      0|                }
  191|      0|            }
  192|      0|            
  193|      0|            legend.entries = entries + legend.extraEntries
  194|      0|        }
  195|      0|        
  196|      0|        // calculate all dimensions of the legend
  197|      0|        legend.calculateDimensions(labelFont: legend.font, viewPortHandler: viewPortHandler)
  198|      0|    }
  199|       |    
  200|       |    @objc open func renderLegend(context: CGContext)
  201|      0|    {
  202|      0|        guard let legend = legend else { return }
  203|      0|        
  204|      0|        if !legend.enabled
  205|      0|        {
  206|      0|            return
  207|      0|        }
  208|      0|        
  209|      0|        let labelFont = legend.font
  210|      0|        let labelTextColor = legend.textColor
  211|      0|        let labelLineHeight = labelFont.lineHeight
  212|      0|        let formYOffset = labelLineHeight / 2.0
  213|      0|
  214|      0|        let entries = legend.entries
  215|      0|        
  216|      0|        let defaultFormSize = legend.formSize
  217|      0|        let formToTextSpace = legend.formToTextSpace
  218|      0|        let xEntrySpace = legend.xEntrySpace
  219|      0|        let yEntrySpace = legend.yEntrySpace
  220|      0|        
  221|      0|        let orientation = legend.orientation
  222|      0|        let horizontalAlignment = legend.horizontalAlignment
  223|      0|        let verticalAlignment = legend.verticalAlignment
  224|      0|        let direction = legend.direction
  225|      0|
  226|      0|        // space between the entries
  227|      0|        let stackSpace = legend.stackSpace
  228|      0|
  229|      0|        let yoffset = legend.yOffset
  230|      0|        let xoffset = legend.xOffset
  231|      0|        var originPosX: CGFloat = 0.0
  232|      0|        
  233|      0|        switch horizontalAlignment
  234|      0|        {
  235|      0|        case .left:
  236|      0|            
  237|      0|            if orientation == .vertical
  238|      0|            {
  239|      0|                originPosX = xoffset
  240|      0|            }
  241|      0|            else
  242|      0|            {
  243|      0|                originPosX = viewPortHandler.contentLeft + xoffset
  244|      0|            }
  245|      0|            
  246|      0|            if direction == .rightToLeft
  247|      0|            {
  248|      0|                originPosX += legend.neededWidth
  249|      0|            }
  250|      0|            
  251|      0|        case .right:
  252|      0|            
  253|      0|            if orientation == .vertical
  254|      0|            {
  255|      0|                originPosX = viewPortHandler.chartWidth - xoffset
  256|      0|            }
  257|      0|            else
  258|      0|            {
  259|      0|                originPosX = viewPortHandler.contentRight - xoffset
  260|      0|            }
  261|      0|            
  262|      0|            if direction == .leftToRight
  263|      0|            {
  264|      0|                originPosX -= legend.neededWidth
  265|      0|            }
  266|      0|            
  267|      0|        case .center:
  268|      0|            
  269|      0|            if orientation == .vertical
  270|      0|            {
  271|      0|                originPosX = viewPortHandler.chartWidth / 2.0
  272|      0|            }
  273|      0|            else
  274|      0|            {
  275|      0|                originPosX = viewPortHandler.contentLeft
  276|      0|                    + viewPortHandler.contentWidth / 2.0
  277|      0|            }
  278|      0|            
  279|      0|            originPosX += (direction == .leftToRight
  280|      0|                    ? +xoffset
  281|      0|                    : -xoffset)
  282|      0|            
  283|      0|            // Horizontally layed out legends do the center offset on a line basis,
  284|      0|            // So here we offset the vertical ones only.
  285|      0|            if orientation == .vertical
  286|      0|            {
  287|      0|                if direction == .leftToRight
  288|      0|                {
  289|      0|                    originPosX -= legend.neededWidth / 2.0 - xoffset
  290|      0|                }
  291|      0|                else
  292|      0|                {
  293|      0|                    originPosX += legend.neededWidth / 2.0 - xoffset
  294|      0|                }
  295|      0|            }
  296|      0|        }
  297|      0|        
  298|      0|        switch orientation
  299|      0|        {
  300|      0|        case .horizontal:
  301|      0|            
  302|      0|            let calculatedLineSizes = legend.calculatedLineSizes
  303|      0|            let calculatedLabelSizes = legend.calculatedLabelSizes
  304|      0|            let calculatedLabelBreakPoints = legend.calculatedLabelBreakPoints
  305|      0|            
  306|      0|            var posX: CGFloat = originPosX
  307|      0|            var posY: CGFloat
  308|      0|            
  309|      0|            switch verticalAlignment
  310|      0|            {
  311|      0|            case .top:
  312|      0|                posY = yoffset
  313|      0|                
  314|      0|            case .bottom:
  315|      0|                posY = viewPortHandler.chartHeight - yoffset - legend.neededHeight
  316|      0|                
  317|      0|            case .center:
  318|      0|                posY = (viewPortHandler.chartHeight - legend.neededHeight) / 2.0 + yoffset
  319|      0|            }
  320|      0|            
  321|      0|            var lineIndex: Int = 0
  322|      0|            
  323|      0|            for i in 0 ..< entries.count
  324|      0|            {
  325|      0|                let e = entries[i]
  326|      0|                let drawingForm = e.form != .none
  327|      0|                let formSize = e.formSize.isNaN ? defaultFormSize : e.formSize
  328|      0|                
  329|      0|                if i < calculatedLabelBreakPoints.count &&
  330|      0|                    calculatedLabelBreakPoints[i]
  331|      0|                {
  332|      0|                    posX = originPosX
  333|      0|                    posY += labelLineHeight + yEntrySpace
  334|      0|                }
  335|      0|                
  336|      0|                if posX == originPosX &&
  337|      0|                    horizontalAlignment == .center &&
  338|      0|                    lineIndex < calculatedLineSizes.count
  339|      0|                {
  340|      0|                    posX += (direction == .rightToLeft
  341|      0|                        ? calculatedLineSizes[lineIndex].width
  342|      0|                        : -calculatedLineSizes[lineIndex].width) / 2.0
  343|      0|                    lineIndex += 1
  344|      0|                }
  345|      0|                
  346|      0|                let isStacked = e.label == nil // grouped forms have null labels
  347|      0|                
  348|      0|                if drawingForm
  349|      0|                {
  350|      0|                    if direction == .rightToLeft
  351|      0|                    {
  352|      0|                        posX -= formSize
  353|      0|                    }
  354|      0|                    
  355|      0|                    drawForm(
  356|      0|                        context: context,
  357|      0|                        x: posX,
  358|      0|                        y: posY + formYOffset,
  359|      0|                        entry: e,
  360|      0|                        legend: legend)
  361|      0|                    
  362|      0|                    if direction == .leftToRight
  363|      0|                    {
  364|      0|                        posX += formSize
  365|      0|                    }
  366|      0|                }
  367|      0|                
  368|      0|                if !isStacked
  369|      0|                {
  370|      0|                    if drawingForm
  371|      0|                    {
  372|      0|                        posX += direction == .rightToLeft ? -formToTextSpace : formToTextSpace
  373|      0|                    }
  374|      0|                    
  375|      0|                    if direction == .rightToLeft
  376|      0|                    {
  377|      0|                        posX -= calculatedLabelSizes[i].width
  378|      0|                    }
  379|      0|                    
  380|      0|                    drawLabel(
  381|      0|                        context: context,
  382|      0|                        x: posX,
  383|      0|                        y: posY,
  384|      0|                        label: e.label!,
  385|      0|                        font: labelFont,
  386|      0|                        textColor: labelTextColor)
  387|      0|                    
  388|      0|                    if direction == .leftToRight
  389|      0|                    {
  390|      0|                        posX += calculatedLabelSizes[i].width
  391|      0|                    }
  392|      0|                    
  393|      0|                    posX += direction == .rightToLeft ? -xEntrySpace : xEntrySpace
  394|      0|                }
  395|      0|                else
  396|      0|                {
  397|      0|                    posX += direction == .rightToLeft ? -stackSpace : stackSpace
  398|      0|                }
  399|      0|            }
  400|      0|            
  401|      0|        case .vertical:
  402|      0|            
  403|      0|            // contains the stacked legend size in pixels
  404|      0|            var stack = CGFloat(0.0)
  405|      0|            var wasStacked = false
  406|      0|            
  407|      0|            var posY: CGFloat = 0.0
  408|      0|            
  409|      0|            switch verticalAlignment
  410|      0|            {
  411|      0|            case .top:
  412|      0|                posY = (horizontalAlignment == .center
  413|      0|                    ? 0.0
  414|      0|                    : viewPortHandler.contentTop)
  415|      0|                posY += yoffset
  416|      0|                
  417|      0|            case .bottom:
  418|      0|                posY = (horizontalAlignment == .center
  419|      0|                    ? viewPortHandler.chartHeight
  420|      0|                    : viewPortHandler.contentBottom)
  421|      0|                posY -= legend.neededHeight + yoffset
  422|      0|                
  423|      0|            case .center:
  424|      0|                
  425|      0|                posY = viewPortHandler.chartHeight / 2.0 - legend.neededHeight / 2.0 + legend.yOffset
  426|      0|            }
  427|      0|            
  428|      0|            for i in 0 ..< entries.count
  429|      0|            {
  430|      0|                let e = entries[i]
  431|      0|                let drawingForm = e.form != .none
  432|      0|                let formSize = e.formSize.isNaN ? defaultFormSize : e.formSize
  433|      0|                
  434|      0|                var posX = originPosX
  435|      0|                
  436|      0|                if drawingForm
  437|      0|                {
  438|      0|                    if direction == .leftToRight
  439|      0|                    {
  440|      0|                        posX += stack
  441|      0|                    }
  442|      0|                    else
  443|      0|                    {
  444|      0|                        posX -= formSize - stack
  445|      0|                    }
  446|      0|                    
  447|      0|                    drawForm(
  448|      0|                        context: context,
  449|      0|                        x: posX,
  450|      0|                        y: posY + formYOffset,
  451|      0|                        entry: e,
  452|      0|                        legend: legend)
  453|      0|                    
  454|      0|                    if direction == .leftToRight
  455|      0|                    {
  456|      0|                        posX += formSize
  457|      0|                    }
  458|      0|                }
  459|      0|                
  460|      0|                if e.label != nil
  461|      0|                {
  462|      0|                    if drawingForm && !wasStacked
  463|      0|                    {
  464|      0|                        posX += direction == .leftToRight ? formToTextSpace : -formToTextSpace
  465|      0|                    }
  466|      0|                    else if wasStacked
  467|      0|                    {
  468|      0|                        posX = originPosX
  469|      0|                    }
  470|      0|                    
  471|      0|                    if direction == .rightToLeft
  472|      0|                    {
  473|      0|                        posX -= (e.label! as NSString).size(withAttributes: [.font: labelFont]).width
  474|      0|                    }
  475|      0|                    
  476|      0|                    if !wasStacked
  477|      0|                    {
  478|      0|                        drawLabel(context: context, x: posX, y: posY, label: e.label!, font: labelFont, textColor: labelTextColor)
  479|      0|                    }
  480|      0|                    else
  481|      0|                    {
  482|      0|                        posY += labelLineHeight + yEntrySpace
  483|      0|                        drawLabel(context: context, x: posX, y: posY, label: e.label!, font: labelFont, textColor: labelTextColor)
  484|      0|                    }
  485|      0|                    
  486|      0|                    // make a step down
  487|      0|                    posY += labelLineHeight + yEntrySpace
  488|      0|                    stack = 0.0
  489|      0|                }
  490|      0|                else
  491|      0|                {
  492|      0|                    stack += formSize + stackSpace
  493|      0|                    wasStacked = true
  494|      0|                }
  495|      0|            }
  496|      0|        }
  497|      0|    }
  498|       |
  499|      0|    private var _formLineSegmentsBuffer = [CGPoint](repeating: CGPoint(), count: 2)
  500|       |    
  501|       |    /// Draws the Legend-form at the given position with the color at the given index.
  502|       |    @objc open func drawForm(
  503|       |        context: CGContext,
  504|       |        x: CGFloat,
  505|       |        y: CGFloat,
  506|       |        entry: LegendEntry,
  507|       |        legend: Legend)
  508|      0|    {
  509|      0|        guard
  510|      0|            let formColor = entry.formColor,
  511|      0|            formColor != NSUIColor.clear
  512|      0|            else { return }
  513|      0|        
  514|      0|        var form = entry.form
  515|      0|        if form == .default
  516|      0|        {
  517|      0|            form = legend.form
  518|      0|        }
  519|      0|        
  520|      0|        let formSize = entry.formSize.isNaN ? legend.formSize : entry.formSize
  521|      0|        
  522|      0|        context.saveGState()
  523|      0|        defer { context.restoreGState() }
  524|      0|        
  525|      0|        switch form
  526|      0|        {
  527|      0|        case .none:
  528|      0|            // Do nothing
  529|      0|            break
  530|      0|            
  531|      0|        case .empty:
  532|      0|            // Do not draw, but keep space for the form
  533|      0|            break
  534|      0|            
  535|      0|        case .default: fallthrough
  536|      0|        case .circle:
  537|      0|            
  538|      0|            context.setFillColor(formColor.cgColor)
  539|      0|            context.fillEllipse(in: CGRect(x: x, y: y - formSize / 2.0, width: formSize, height: formSize))
  540|      0|            
  541|      0|        case .square:
  542|      0|            
  543|      0|            context.setFillColor(formColor.cgColor)
  544|      0|            context.fill(CGRect(x: x, y: y - formSize / 2.0, width: formSize, height: formSize))
  545|      0|            
  546|      0|        case .line:
  547|      0|            
  548|      0|            let formLineWidth = entry.formLineWidth.isNaN ? legend.formLineWidth : entry.formLineWidth
  549|      0|            let formLineDashPhase = entry.formLineDashPhase.isNaN ? legend.formLineDashPhase : entry.formLineDashPhase
  550|      0|            let formLineDashLengths = entry.formLineDashLengths == nil ? legend.formLineDashLengths : entry.formLineDashLengths
  551|      0|            
  552|      0|            context.setLineWidth(formLineWidth)
  553|      0|            
  554|      0|            if formLineDashLengths != nil && formLineDashLengths!.count > 0
  555|      0|            {
  556|      0|                context.setLineDash(phase: formLineDashPhase, lengths: formLineDashLengths!)
  557|      0|            }
  558|      0|            else
  559|      0|            {
  560|      0|                context.setLineDash(phase: 0.0, lengths: [])
  561|      0|            }
  562|      0|            
  563|      0|            context.setStrokeColor(formColor.cgColor)
  564|      0|            
  565|      0|            _formLineSegmentsBuffer[0].x = x
  566|      0|            _formLineSegmentsBuffer[0].y = y
  567|      0|            _formLineSegmentsBuffer[1].x = x + formSize
  568|      0|            _formLineSegmentsBuffer[1].y = y
  569|      0|            context.strokeLineSegments(between: _formLineSegmentsBuffer)
  570|      0|        }
  571|      0|    }
  572|       |
  573|       |    /// Draws the provided label at the given position.
  574|       |    @objc open func drawLabel(context: CGContext, x: CGFloat, y: CGFloat, label: String, font: NSUIFont, textColor: NSUIColor)
  575|      0|    {
  576|      0|        ChartUtils.drawText(context: context, text: label, point: CGPoint(x: x, y: y), align: .left, attributes: [NSAttributedString.Key.font: font, NSAttributedString.Key.foregroundColor: textColor])
  577|      0|    }
  578|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/LineChartRenderer.swift:
    1|       |//
    2|       |//  LineChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class LineChartRenderer: LineRadarRenderer
   16|       |{
   17|       |    // TODO: Currently, this nesting isn't necessary for LineCharts. However, it will make it much easier to add a custom rotor
   18|       |    // that navigates between datasets.
   19|       |    // NOTE: Unlike the other renderers, LineChartRenderer populates accessibleChartElements in drawCircles due to the nature of its drawing options.
   20|       |    /// A nested array of elements ordered logically (i.e not in visual/drawing order) for use with VoiceOver.
   21|       |    private lazy var accessibilityOrderedElements: [[NSUIAccessibilityElement]] = accessibilityCreateEmptyOrderedElements()
   22|       |
   23|       |    @objc open weak var dataProvider: LineChartDataProvider?
   24|       |    
   25|       |    @objc public init(dataProvider: LineChartDataProvider, animator: Animator, viewPortHandler: ViewPortHandler)
   26|      0|    {
   27|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   28|      0|        
   29|      0|        self.dataProvider = dataProvider
   30|      0|    }
   31|       |    
   32|       |    open override func drawData(context: CGContext)
   33|      0|    {
   34|      0|        guard let lineData = dataProvider?.lineData else { return }
   35|      0|        
   36|      0|        for i in 0 ..< lineData.dataSetCount
   37|      0|        {
   38|      0|            guard let set = lineData.getDataSetByIndex(i) else { continue }
   39|      0|            
   40|      0|            if set.isVisible
   41|      0|            {
   42|      0|                if !(set is ILineChartDataSet)
   43|      0|                {
   44|      0|                    fatalError("Datasets for LineChartRenderer must conform to ILineChartDataSet")
   45|      0|                }
   46|      0|                
   47|      0|                drawDataSet(context: context, dataSet: set as! ILineChartDataSet)
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|       |    
   52|       |    @objc open func drawDataSet(context: CGContext, dataSet: ILineChartDataSet)
   53|      0|    {
   54|      0|        if dataSet.entryCount < 1
   55|      0|        {
   56|      0|            return
   57|      0|        }
   58|      0|        
   59|      0|        context.saveGState()
   60|      0|        
   61|      0|        context.setLineWidth(dataSet.lineWidth)
   62|      0|        if dataSet.lineDashLengths != nil
   63|      0|        {
   64|      0|            context.setLineDash(phase: dataSet.lineDashPhase, lengths: dataSet.lineDashLengths!)
   65|      0|        }
   66|      0|        else
   67|      0|        {
   68|      0|            context.setLineDash(phase: 0.0, lengths: [])
   69|      0|        }
   70|      0|        
   71|      0|        context.setLineCap(dataSet.lineCapType)
   72|      0|        
   73|      0|        // if drawing cubic lines is enabled
   74|      0|        switch dataSet.mode
   75|      0|        {
   76|      0|        case .linear: fallthrough
   77|      0|        case .stepped:
   78|      0|            drawLinear(context: context, dataSet: dataSet)
   79|      0|            
   80|      0|        case .cubicBezier:
   81|      0|            drawCubicBezier(context: context, dataSet: dataSet)
   82|      0|            
   83|      0|        case .horizontalBezier:
   84|      0|            drawHorizontalBezier(context: context, dataSet: dataSet)
   85|      0|        }
   86|      0|        
   87|      0|        context.restoreGState()
   88|      0|    }
   89|       |    
   90|       |    @objc open func drawCubicBezier(context: CGContext, dataSet: ILineChartDataSet)
   91|      0|    {
   92|      0|        guard let dataProvider = dataProvider else { return }
   93|      0|        
   94|      0|        let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
   95|      0|        
   96|      0|        let phaseY = animator.phaseY
   97|      0|        
   98|      0|        _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
   99|      0|        
  100|      0|        // get the color that is specified for this position from the DataSet
  101|      0|        let drawingColor = dataSet.colors.first!
  102|      0|        
  103|      0|        let intensity = dataSet.cubicIntensity
  104|      0|        
  105|      0|        // the path for the cubic-spline
  106|      0|        let cubicPath = CGMutablePath()
  107|      0|        
  108|      0|        let valueToPixelMatrix = trans.valueToPixelMatrix
  109|      0|        
  110|      0|        if _xBounds.range >= 1
  111|      0|        {
  112|      0|            var prevDx: CGFloat = 0.0
  113|      0|            var prevDy: CGFloat = 0.0
  114|      0|            var curDx: CGFloat = 0.0
  115|      0|            var curDy: CGFloat = 0.0
  116|      0|            
  117|      0|            // Take an extra point from the left, and an extra from the right.
  118|      0|            // That's because we need 4 points for a cubic bezier (cubic=4), otherwise we get lines moving and doing weird stuff on the edges of the chart.
  119|      0|            // So in the starting `prev` and `cur`, go -2, -1
  120|      0|            
  121|      0|            let firstIndex = _xBounds.min + 1
  122|      0|            
  123|      0|            var prevPrev: ChartDataEntry! = nil
  124|      0|            var prev: ChartDataEntry! = dataSet.entryForIndex(max(firstIndex - 2, 0))
  125|      0|            var cur: ChartDataEntry! = dataSet.entryForIndex(max(firstIndex - 1, 0))
  126|      0|            var next: ChartDataEntry! = cur
  127|      0|            var nextIndex: Int = -1
  128|      0|            
  129|      0|            if cur == nil { return }
  130|      0|            
  131|      0|            // let the spline start
  132|      0|            cubicPath.move(to: CGPoint(x: CGFloat(cur.x), y: CGFloat(cur.y * phaseY)), transform: valueToPixelMatrix)
  133|      0|            
  134|      0|            for j in _xBounds.dropFirst()  // same as firstIndex
  135|      0|            {
  136|      0|                prevPrev = prev
  137|      0|                prev = cur
  138|      0|                cur = nextIndex == j ? next : dataSet.entryForIndex(j)
  139|      0|                
  140|      0|                nextIndex = j + 1 < dataSet.entryCount ? j + 1 : j
  141|      0|                next = dataSet.entryForIndex(nextIndex)
  142|      0|                
  143|      0|                if next == nil { break }
  144|      0|                
  145|      0|                prevDx = CGFloat(cur.x - prevPrev.x) * intensity
  146|      0|                prevDy = CGFloat(cur.y - prevPrev.y) * intensity
  147|      0|                curDx = CGFloat(next.x - prev.x) * intensity
  148|      0|                curDy = CGFloat(next.y - prev.y) * intensity
  149|      0|                
  150|      0|                cubicPath.addCurve(
  151|      0|                    to: CGPoint(
  152|      0|                        x: CGFloat(cur.x),
  153|      0|                        y: CGFloat(cur.y) * CGFloat(phaseY)),
  154|      0|                    control1: CGPoint(
  155|      0|                        x: CGFloat(prev.x) + prevDx,
  156|      0|                        y: (CGFloat(prev.y) + prevDy) * CGFloat(phaseY)),
  157|      0|                    control2: CGPoint(
  158|      0|                        x: CGFloat(cur.x) - curDx,
  159|      0|                        y: (CGFloat(cur.y) - curDy) * CGFloat(phaseY)),
  160|      0|                    transform: valueToPixelMatrix)
  161|      0|            }
  162|      0|        }
  163|      0|        
  164|      0|        context.saveGState()
  165|      0|        
  166|      0|        if dataSet.isDrawFilledEnabled
  167|      0|        {
  168|      0|            // Copy this path because we make changes to it
  169|      0|            let fillPath = cubicPath.mutableCopy()
  170|      0|            
  171|      0|            drawCubicFill(context: context, dataSet: dataSet, spline: fillPath!, matrix: valueToPixelMatrix, bounds: _xBounds)
  172|      0|        }
  173|      0|        
  174|      0|        context.beginPath()
  175|      0|        context.addPath(cubicPath)
  176|      0|        context.setStrokeColor(drawingColor.cgColor)
  177|      0|        context.strokePath()
  178|      0|        
  179|      0|        context.restoreGState()
  180|      0|    }
  181|       |    
  182|       |    @objc open func drawHorizontalBezier(context: CGContext, dataSet: ILineChartDataSet)
  183|      0|    {
  184|      0|        guard let dataProvider = dataProvider else { return }
  185|      0|        
  186|      0|        let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  187|      0|        
  188|      0|        let phaseY = animator.phaseY
  189|      0|        
  190|      0|        _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
  191|      0|        
  192|      0|        // get the color that is specified for this position from the DataSet
  193|      0|        let drawingColor = dataSet.colors.first!
  194|      0|        
  195|      0|        // the path for the cubic-spline
  196|      0|        let cubicPath = CGMutablePath()
  197|      0|        
  198|      0|        let valueToPixelMatrix = trans.valueToPixelMatrix
  199|      0|        
  200|      0|        if _xBounds.range >= 1
  201|      0|        {
  202|      0|            var prev: ChartDataEntry! = dataSet.entryForIndex(_xBounds.min)
  203|      0|            var cur: ChartDataEntry! = prev
  204|      0|            
  205|      0|            if cur == nil { return }
  206|      0|            
  207|      0|            // let the spline start
  208|      0|            cubicPath.move(to: CGPoint(x: CGFloat(cur.x), y: CGFloat(cur.y * phaseY)), transform: valueToPixelMatrix)
  209|      0|            
  210|      0|            for j in _xBounds.dropFirst()
  211|      0|            {
  212|      0|                prev = cur
  213|      0|                cur = dataSet.entryForIndex(j)
  214|      0|                
  215|      0|                let cpx = CGFloat(prev.x + (cur.x - prev.x) / 2.0)
  216|      0|                
  217|      0|                cubicPath.addCurve(
  218|      0|                    to: CGPoint(
  219|      0|                        x: CGFloat(cur.x),
  220|      0|                        y: CGFloat(cur.y * phaseY)),
  221|      0|                    control1: CGPoint(
  222|      0|                        x: cpx,
  223|      0|                        y: CGFloat(prev.y * phaseY)),
  224|      0|                    control2: CGPoint(
  225|      0|                        x: cpx,
  226|      0|                        y: CGFloat(cur.y * phaseY)),
  227|      0|                    transform: valueToPixelMatrix)
  228|      0|            }
  229|      0|        }
  230|      0|        
  231|      0|        context.saveGState()
  232|      0|        
  233|      0|        if dataSet.isDrawFilledEnabled
  234|      0|        {
  235|      0|            // Copy this path because we make changes to it
  236|      0|            let fillPath = cubicPath.mutableCopy()
  237|      0|            
  238|      0|            drawCubicFill(context: context, dataSet: dataSet, spline: fillPath!, matrix: valueToPixelMatrix, bounds: _xBounds)
  239|      0|        }
  240|      0|        
  241|      0|        context.beginPath()
  242|      0|        context.addPath(cubicPath)
  243|      0|        context.setStrokeColor(drawingColor.cgColor)
  244|      0|        context.strokePath()
  245|      0|        
  246|      0|        context.restoreGState()
  247|      0|    }
  248|       |    
  249|       |    open func drawCubicFill(
  250|       |        context: CGContext,
  251|       |                dataSet: ILineChartDataSet,
  252|       |                spline: CGMutablePath,
  253|       |                matrix: CGAffineTransform,
  254|       |                bounds: XBounds)
  255|      0|    {
  256|      0|        guard
  257|      0|            let dataProvider = dataProvider
  258|      0|            else { return }
  259|      0|        
  260|      0|        if bounds.range <= 0
  261|      0|        {
  262|      0|            return
  263|      0|        }
  264|      0|        
  265|      0|        let fillMin = dataSet.fillFormatter?.getFillLinePosition(dataSet: dataSet, dataProvider: dataProvider) ?? 0.0
  266|      0|
  267|      0|        var pt1 = CGPoint(x: CGFloat(dataSet.entryForIndex(bounds.min + bounds.range)?.x ?? 0.0), y: fillMin)
  268|      0|        var pt2 = CGPoint(x: CGFloat(dataSet.entryForIndex(bounds.min)?.x ?? 0.0), y: fillMin)
  269|      0|        pt1 = pt1.applying(matrix)
  270|      0|        pt2 = pt2.applying(matrix)
  271|      0|        
  272|      0|        spline.addLine(to: pt1)
  273|      0|        spline.addLine(to: pt2)
  274|      0|        spline.closeSubpath()
  275|      0|        
  276|      0|        if dataSet.fill != nil
  277|      0|        {
  278|      0|            drawFilledPath(context: context, path: spline, fill: dataSet.fill!, fillAlpha: dataSet.fillAlpha)
  279|      0|        }
  280|      0|        else
  281|      0|        {
  282|      0|            drawFilledPath(context: context, path: spline, fillColor: dataSet.fillColor, fillAlpha: dataSet.fillAlpha)
  283|      0|        }
  284|      0|    }
  285|       |    
  286|      0|    private var _lineSegments = [CGPoint](repeating: CGPoint(), count: 2)
  287|       |    
  288|       |    @objc open func drawLinear(context: CGContext, dataSet: ILineChartDataSet)
  289|      0|    {
  290|      0|        guard let dataProvider = dataProvider else { return }
  291|      0|        
  292|      0|        let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  293|      0|        
  294|      0|        let valueToPixelMatrix = trans.valueToPixelMatrix
  295|      0|        
  296|      0|        let entryCount = dataSet.entryCount
  297|      0|        let isDrawSteppedEnabled = dataSet.mode == .stepped
  298|      0|        let pointsPerEntryPair = isDrawSteppedEnabled ? 4 : 2
  299|      0|        
  300|      0|        let phaseY = animator.phaseY
  301|      0|        
  302|      0|        _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
  303|      0|        
  304|      0|        // if drawing filled is enabled
  305|      0|        if dataSet.isDrawFilledEnabled && entryCount > 0
  306|      0|        {
  307|      0|            drawLinearFill(context: context, dataSet: dataSet, trans: trans, bounds: _xBounds)
  308|      0|        }
  309|      0|        
  310|      0|        context.saveGState()
  311|      0|
  312|      0|            if _lineSegments.count != pointsPerEntryPair
  313|      0|            {
  314|      0|                // Allocate once in correct size
  315|      0|                _lineSegments = [CGPoint](repeating: CGPoint(), count: pointsPerEntryPair)
  316|      0|            }
  317|      0|
  318|      0|        for j in _xBounds.dropLast()
  319|      0|        {
  320|      0|            var e: ChartDataEntry! = dataSet.entryForIndex(j)
  321|      0|            
  322|      0|            if e == nil { continue }
  323|      0|            
  324|      0|            _lineSegments[0].x = CGFloat(e.x)
  325|      0|            _lineSegments[0].y = CGFloat(e.y * phaseY)
  326|      0|            
  327|      0|            if j < _xBounds.max
  328|      0|            {
  329|      0|                // TODO: remove the check.
  330|      0|                // With the new XBounds iterator, j is always smaller than _xBounds.max
  331|      0|                // Keeping this check for a while, if xBounds have no further breaking changes, it should be safe to remove the check
  332|      0|                e = dataSet.entryForIndex(j + 1)
  333|      0|                
  334|      0|                if e == nil { break }
  335|      0|                
  336|      0|                if isDrawSteppedEnabled
  337|      0|                {
  338|      0|                    _lineSegments[1] = CGPoint(x: CGFloat(e.x), y: _lineSegments[0].y)
  339|      0|                    _lineSegments[2] = _lineSegments[1]
  340|      0|                    _lineSegments[3] = CGPoint(x: CGFloat(e.x), y: CGFloat(e.y * phaseY))
  341|      0|                }
  342|      0|                else
  343|      0|                {
  344|      0|                    _lineSegments[1] = CGPoint(x: CGFloat(e.x), y: CGFloat(e.y * phaseY))
  345|      0|                }
  346|      0|            }
  347|      0|            else
  348|      0|            {
  349|      0|                _lineSegments[1] = _lineSegments[0]
  350|      0|            }
  351|      0|
  352|      0|            for i in 0..<_lineSegments.count
  353|      0|            {
  354|      0|                _lineSegments[i] = _lineSegments[i].applying(valueToPixelMatrix)
  355|      0|            }
  356|      0|            
  357|      0|            if !viewPortHandler.isInBoundsRight(_lineSegments[0].x)
  358|      0|            {
  359|      0|                break
  360|      0|            }
  361|      0|            
  362|      0|            // Determine the start and end coordinates of the line, and make sure they differ.
  363|      0|            guard
  364|      0|                let firstCoordinate = _lineSegments.first,
  365|      0|                let lastCoordinate = _lineSegments.last,
  366|      0|                firstCoordinate != lastCoordinate else { continue }
  367|      0|            
  368|      0|            // make sure the lines don't do shitty things outside bounds
  369|      0|            if !viewPortHandler.isInBoundsLeft(lastCoordinate.x) ||
  370|      0|                !viewPortHandler.isInBoundsTop(max(firstCoordinate.y, lastCoordinate.y)) ||
  371|      0|                !viewPortHandler.isInBoundsBottom(min(firstCoordinate.y, lastCoordinate.y))
  372|      0|            {
  373|      0|                continue
  374|      0|            }
  375|      0|            
  376|      0|            // get the color that is set for this line-segment
  377|      0|            context.setStrokeColor(dataSet.color(atIndex: j).cgColor)
  378|      0|            context.strokeLineSegments(between: _lineSegments)
  379|      0|        }
  380|      0|        
  381|      0|        context.restoreGState()
  382|      0|    }
  383|       |    
  384|       |    open func drawLinearFill(context: CGContext, dataSet: ILineChartDataSet, trans: Transformer, bounds: XBounds)
  385|      0|    {
  386|      0|        guard let dataProvider = dataProvider else { return }
  387|      0|        
  388|      0|        let filled = generateFilledPath(
  389|      0|            dataSet: dataSet,
  390|      0|            fillMin: dataSet.fillFormatter?.getFillLinePosition(dataSet: dataSet, dataProvider: dataProvider) ?? 0.0,
  391|      0|            bounds: bounds,
  392|      0|            matrix: trans.valueToPixelMatrix)
  393|      0|        
  394|      0|        if dataSet.fill != nil
  395|      0|        {
  396|      0|            drawFilledPath(context: context, path: filled, fill: dataSet.fill!, fillAlpha: dataSet.fillAlpha)
  397|      0|        }
  398|      0|        else
  399|      0|        {
  400|      0|            drawFilledPath(context: context, path: filled, fillColor: dataSet.fillColor, fillAlpha: dataSet.fillAlpha)
  401|      0|        }
  402|      0|    }
  403|       |    
  404|       |    /// Generates the path that is used for filled drawing.
  405|       |    private func generateFilledPath(dataSet: ILineChartDataSet, fillMin: CGFloat, bounds: XBounds, matrix: CGAffineTransform) -> CGPath
  406|      0|    {
  407|      0|        let phaseY = animator.phaseY
  408|      0|        let isDrawSteppedEnabled = dataSet.mode == .stepped
  409|      0|        let matrix = matrix
  410|      0|        
  411|      0|        var e: ChartDataEntry!
  412|      0|        
  413|      0|        let filled = CGMutablePath()
  414|      0|        
  415|      0|        e = dataSet.entryForIndex(bounds.min)
  416|      0|        if e != nil
  417|      0|        {
  418|      0|            filled.move(to: CGPoint(x: CGFloat(e.x), y: fillMin), transform: matrix)
  419|      0|            filled.addLine(to: CGPoint(x: CGFloat(e.x), y: CGFloat(e.y * phaseY)), transform: matrix)
  420|      0|        }
  421|      0|        
  422|      0|        // create a new path
  423|      0|        for x in stride(from: (bounds.min + 1), through: bounds.range + bounds.min, by: 1)
  424|      0|        {
  425|      0|            guard let e = dataSet.entryForIndex(x) else { continue }
  426|      0|            
  427|      0|            if isDrawSteppedEnabled
  428|      0|            {
  429|      0|                guard let ePrev = dataSet.entryForIndex(x-1) else { continue }
  430|      0|                filled.addLine(to: CGPoint(x: CGFloat(e.x), y: CGFloat(ePrev.y * phaseY)), transform: matrix)
  431|      0|            }
  432|      0|            
  433|      0|            filled.addLine(to: CGPoint(x: CGFloat(e.x), y: CGFloat(e.y * phaseY)), transform: matrix)
  434|      0|        }
  435|      0|        
  436|      0|        // close up
  437|      0|        e = dataSet.entryForIndex(bounds.range + bounds.min)
  438|      0|        if e != nil
  439|      0|        {
  440|      0|            filled.addLine(to: CGPoint(x: CGFloat(e.x), y: fillMin), transform: matrix)
  441|      0|        }
  442|      0|        filled.closeSubpath()
  443|      0|        
  444|      0|        return filled
  445|      0|    }
  446|       |    
  447|       |    open override func drawValues(context: CGContext)
  448|      0|    {
  449|      0|        guard
  450|      0|            let dataProvider = dataProvider,
  451|      0|            let lineData = dataProvider.lineData
  452|      0|            else { return }
  453|      0|
  454|      0|        if isDrawingValuesAllowed(dataProvider: dataProvider)
  455|      0|        {
  456|      0|            let dataSets = lineData.dataSets
  457|      0|            
  458|      0|            let phaseY = animator.phaseY
  459|      0|            
  460|      0|            var pt = CGPoint()
  461|      0|            
  462|      0|            for i in 0 ..< dataSets.count
  463|      0|            {
  464|      0|                guard let
  465|      0|                    dataSet = dataSets[i] as? ILineChartDataSet,
  466|      0|                    shouldDrawValues(forDataSet: dataSet)
  467|      0|                    else { continue }
  468|      0|                
  469|      0|                let valueFont = dataSet.valueFont
  470|      0|                
  471|      0|                guard let formatter = dataSet.valueFormatter else { continue }
  472|      0|                
  473|      0|                let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  474|      0|                let valueToPixelMatrix = trans.valueToPixelMatrix
  475|      0|                
  476|      0|                let iconsOffset = dataSet.iconsOffset
  477|      0|                
  478|      0|                // make sure the values do not interfear with the circles
  479|      0|                var valOffset = Int(dataSet.circleRadius * 1.75)
  480|      0|                
  481|      0|                if !dataSet.isDrawCirclesEnabled
  482|      0|                {
  483|      0|                    valOffset = valOffset / 2
  484|      0|                }
  485|      0|                
  486|      0|                _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
  487|      0|
  488|      0|                for j in _xBounds
  489|      0|                {
  490|      0|                    guard let e = dataSet.entryForIndex(j) else { break }
  491|      0|                    
  492|      0|                    pt.x = CGFloat(e.x)
  493|      0|                    pt.y = CGFloat(e.y * phaseY)
  494|      0|                    pt = pt.applying(valueToPixelMatrix)
  495|      0|                    
  496|      0|                    if (!viewPortHandler.isInBoundsRight(pt.x))
  497|      0|                    {
  498|      0|                        break
  499|      0|                    }
  500|      0|                    
  501|      0|                    if (!viewPortHandler.isInBoundsLeft(pt.x) || !viewPortHandler.isInBoundsY(pt.y))
  502|      0|                    {
  503|      0|                        continue
  504|      0|                    }
  505|      0|                    
  506|      0|                    if dataSet.isDrawValuesEnabled {
  507|      0|                        ChartUtils.drawText(
  508|      0|                            context: context,
  509|      0|                            text: formatter.stringForValue(
  510|      0|                                e.y,
  511|      0|                                entry: e,
  512|      0|                                dataSetIndex: i,
  513|      0|                                viewPortHandler: viewPortHandler),
  514|      0|                            point: CGPoint(
  515|      0|                                x: pt.x,
  516|      0|                                y: pt.y - CGFloat(valOffset) - valueFont.lineHeight),
  517|      0|                            align: .center,
  518|      0|                            attributes: [NSAttributedString.Key.font: valueFont, NSAttributedString.Key.foregroundColor: dataSet.valueTextColorAt(j)])
  519|      0|                    }
  520|      0|                    
  521|      0|                    if let icon = e.icon, dataSet.isDrawIconsEnabled
  522|      0|                    {
  523|      0|                        ChartUtils.drawImage(context: context,
  524|      0|                                             image: icon,
  525|      0|                                             x: pt.x + iconsOffset.x,
  526|      0|                                             y: pt.y + iconsOffset.y,
  527|      0|                                             size: icon.size)
  528|      0|                    }
  529|      0|                }
  530|      0|            }
  531|      0|        }
  532|      0|    }
  533|       |    
  534|       |    open override func drawExtras(context: CGContext)
  535|      0|    {
  536|      0|        drawCircles(context: context)
  537|      0|    }
  538|       |    
  539|       |    private func drawCircles(context: CGContext)
  540|      0|    {
  541|      0|        guard
  542|      0|            let dataProvider = dataProvider,
  543|      0|            let lineData = dataProvider.lineData
  544|      0|            else { return }
  545|      0|        
  546|      0|        let phaseY = animator.phaseY
  547|      0|
  548|      0|        let dataSets = lineData.dataSets
  549|      0|        
  550|      0|        var pt = CGPoint()
  551|      0|        var rect = CGRect()
  552|      0|        
  553|      0|        // If we redraw the data, remove and repopulate accessible elements to update label values and frames
  554|      0|        accessibleChartElements.removeAll()
  555|      0|        accessibilityOrderedElements = accessibilityCreateEmptyOrderedElements()
  556|      0|
  557|      0|        // Make the chart header the first element in the accessible elements array
  558|      0|        if let chart = dataProvider as? LineChartView {
  559|      0|            let element = createAccessibleHeader(usingChart: chart,
  560|      0|                                                 andData: lineData,
  561|      0|                                                 withDefaultDescription: "Line Chart")
  562|      0|            accessibleChartElements.append(element)
  563|      0|        }
  564|      0|
  565|      0|        context.saveGState()
  566|      0|
  567|      0|        for i in 0 ..< dataSets.count
  568|      0|        {
  569|      0|            guard let dataSet = lineData.getDataSetByIndex(i) as? ILineChartDataSet else { continue }
  570|      0|            
  571|      0|            if !dataSet.isVisible || dataSet.entryCount == 0
  572|      0|            {
  573|      0|                continue
  574|      0|            }
  575|      0|            
  576|      0|            let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  577|      0|            let valueToPixelMatrix = trans.valueToPixelMatrix
  578|      0|            
  579|      0|            _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
  580|      0|            
  581|      0|            let circleRadius = dataSet.circleRadius
  582|      0|            let circleDiameter = circleRadius * 2.0
  583|      0|            let circleHoleRadius = dataSet.circleHoleRadius
  584|      0|            let circleHoleDiameter = circleHoleRadius * 2.0
  585|      0|            
  586|      0|            let drawCircleHole = dataSet.isDrawCircleHoleEnabled &&
  587|      0|                circleHoleRadius < circleRadius &&
  588|      0|                circleHoleRadius > 0.0
  589|      0|            let drawTransparentCircleHole = drawCircleHole &&
  590|      0|                (dataSet.circleHoleColor == nil ||
  591|      0|                    dataSet.circleHoleColor == NSUIColor.clear)
  592|      0|            
  593|      0|            for j in _xBounds
  594|      0|            {
  595|      0|                guard let e = dataSet.entryForIndex(j) else { break }
  596|      0|
  597|      0|                pt.x = CGFloat(e.x)
  598|      0|                pt.y = CGFloat(e.y * phaseY)
  599|      0|                pt = pt.applying(valueToPixelMatrix)
  600|      0|                
  601|      0|                if (!viewPortHandler.isInBoundsRight(pt.x))
  602|      0|                {
  603|      0|                    break
  604|      0|                }
  605|      0|                
  606|      0|                // make sure the circles don't do shitty things outside bounds
  607|      0|                if (!viewPortHandler.isInBoundsLeft(pt.x) || !viewPortHandler.isInBoundsY(pt.y))
  608|      0|                {
  609|      0|                    continue
  610|      0|                }
  611|      0|                
  612|      0|                
  613|      0|                // Skip Circles and Accessibility if not enabled,
  614|      0|                // reduces CPU significantly if not needed
  615|      0|                if !dataSet.isDrawCirclesEnabled
  616|      0|                {
  617|      0|                    continue
  618|      0|                }
  619|      0|                
  620|      0|                // Accessibility element geometry
  621|      0|                let scaleFactor: CGFloat = 3
  622|      0|                let accessibilityRect = CGRect(x: pt.x - (scaleFactor * circleRadius),
  623|      0|                                               y: pt.y - (scaleFactor * circleRadius),
  624|      0|                                               width: scaleFactor * circleDiameter,
  625|      0|                                               height: scaleFactor * circleDiameter)
  626|      0|                // Create and append the corresponding accessibility element to accessibilityOrderedElements
  627|      0|                if let chart = dataProvider as? LineChartView
  628|      0|                {
  629|      0|                    let element = createAccessibleElement(withIndex: j,
  630|      0|                                                          container: chart,
  631|      0|                                                          dataSet: dataSet,
  632|      0|                                                          dataSetIndex: i)
  633|      0|                    { (element) in
  634|      0|                        element.accessibilityFrame = accessibilityRect
  635|      0|                    }
  636|      0|
  637|      0|                    accessibilityOrderedElements[i].append(element)
  638|      0|                }
  639|      0|
  640|      0|                context.setFillColor(dataSet.getCircleColor(atIndex: j)!.cgColor)
  641|      0|
  642|      0|                rect.origin.x = pt.x - circleRadius
  643|      0|                rect.origin.y = pt.y - circleRadius
  644|      0|                rect.size.width = circleDiameter
  645|      0|                rect.size.height = circleDiameter
  646|      0|
  647|      0|                if drawTransparentCircleHole
  648|      0|                {
  649|      0|                    // Begin path for circle with hole
  650|      0|                    context.beginPath()
  651|      0|                    context.addEllipse(in: rect)
  652|      0|                    
  653|      0|                    // Cut hole in path
  654|      0|                    rect.origin.x = pt.x - circleHoleRadius
  655|      0|                    rect.origin.y = pt.y - circleHoleRadius
  656|      0|                    rect.size.width = circleHoleDiameter
  657|      0|                    rect.size.height = circleHoleDiameter
  658|      0|                    context.addEllipse(in: rect)
  659|      0|                    
  660|      0|                    // Fill in-between
  661|      0|                    context.fillPath(using: .evenOdd)
  662|      0|                }
  663|      0|                else
  664|      0|                {
  665|      0|                    context.fillEllipse(in: rect)
  666|      0|                    
  667|      0|                    if drawCircleHole
  668|      0|                    {
  669|      0|                        context.setFillColor(dataSet.circleHoleColor!.cgColor)
  670|      0|                     
  671|      0|                        // The hole rect
  672|      0|                        rect.origin.x = pt.x - circleHoleRadius
  673|      0|                        rect.origin.y = pt.y - circleHoleRadius
  674|      0|                        rect.size.width = circleHoleDiameter
  675|      0|                        rect.size.height = circleHoleDiameter
  676|      0|                        
  677|      0|                        context.fillEllipse(in: rect)
  678|      0|                    }
  679|      0|                }
  680|      0|            }
  681|      0|        }
  682|      0|        
  683|      0|        context.restoreGState()
  684|      0|
  685|      0|        // Merge nested ordered arrays into the single accessibleChartElements.
  686|      0|        accessibleChartElements.append(contentsOf: accessibilityOrderedElements.flatMap { $0 } )
  687|      0|        accessibilityPostLayoutChangedNotification()
  688|      0|    }
  689|       |    
  690|       |    open override func drawHighlighted(context: CGContext, indices: [Highlight])
  691|      0|    {
  692|      0|        guard
  693|      0|            let dataProvider = dataProvider,
  694|      0|            let lineData = dataProvider.lineData
  695|      0|            else { return }
  696|      0|        
  697|      0|        let chartXMax = dataProvider.chartXMax
  698|      0|        
  699|      0|        context.saveGState()
  700|      0|        
  701|      0|        for high in indices
  702|      0|        {
  703|      0|            guard let set = lineData.getDataSetByIndex(high.dataSetIndex) as? ILineChartDataSet
  704|      0|                , set.isHighlightEnabled
  705|      0|                else { continue }
  706|      0|            
  707|      0|            guard let e = set.entryForXValue(high.x, closestToY: high.y) else { continue }
  708|      0|            
  709|      0|            if !isInBoundsX(entry: e, dataSet: set)
  710|      0|            {
  711|      0|                continue
  712|      0|            }
  713|      0|        
  714|      0|            context.setStrokeColor(set.highlightColor.cgColor)
  715|      0|            context.setLineWidth(set.highlightLineWidth)
  716|      0|            if set.highlightLineDashLengths != nil
  717|      0|            {
  718|      0|                context.setLineDash(phase: set.highlightLineDashPhase, lengths: set.highlightLineDashLengths!)
  719|      0|            }
  720|      0|            else
  721|      0|            {
  722|      0|                context.setLineDash(phase: 0.0, lengths: [])
  723|      0|            }
  724|      0|            
  725|      0|            let x = e.x // get the x-position
  726|      0|            let y = e.y * Double(animator.phaseY)
  727|      0|            
  728|      0|            if x > chartXMax * animator.phaseX
  729|      0|            {
  730|      0|                continue
  731|      0|            }
  732|      0|            
  733|      0|            let trans = dataProvider.getTransformer(forAxis: set.axisDependency)
  734|      0|            
  735|      0|            let pt = trans.pixelForValues(x: x, y: y)
  736|      0|            
  737|      0|            high.setDraw(pt: pt)
  738|      0|            
  739|      0|            // draw the lines
  740|      0|            drawHighlightLines(context: context, point: pt, set: set)
  741|      0|        }
  742|      0|        
  743|      0|        context.restoreGState()
  744|      0|    }
  745|       |
  746|       |    /// Creates a nested array of empty subarrays each of which will be populated with NSUIAccessibilityElements.
  747|       |    /// This is marked internal to support HorizontalBarChartRenderer as well.
  748|       |    private func accessibilityCreateEmptyOrderedElements() -> [[NSUIAccessibilityElement]]
  749|      0|    {
  750|      0|        guard let chart = dataProvider as? LineChartView else { return [] }
  751|      0|
  752|      0|        let dataSetCount = chart.lineData?.dataSetCount ?? 0
  753|      0|
  754|      0|        return Array(repeating: [NSUIAccessibilityElement](),
  755|      0|                     count: dataSetCount)
  756|      0|    }
  757|       |
  758|       |    /// Creates an NSUIAccessibleElement representing the smallest meaningful bar of the chart
  759|       |    /// i.e. in case of a stacked chart, this returns each stack, not the combined bar.
  760|       |    /// Note that it is marked internal to support subclass modification in the HorizontalBarChart.
  761|       |    private func createAccessibleElement(withIndex idx: Int,
  762|       |                                          container: LineChartView,
  763|       |                                          dataSet: ILineChartDataSet,
  764|       |                                          dataSetIndex: Int,
  765|       |                                          modifier: (NSUIAccessibilityElement) -> ()) -> NSUIAccessibilityElement
  766|      0|    {
  767|      0|        let element = NSUIAccessibilityElement(accessibilityContainer: container)
  768|      0|        let xAxis = container.xAxis
  769|      0|
  770|      0|        guard let e = dataSet.entryForIndex(idx) else { return element }
  771|      0|        guard let dataProvider = dataProvider else { return element }
  772|      0|
  773|      0|        // NOTE: The formatter can cause issues when the x-axis labels are consecutive ints.
  774|      0|        // i.e. due to the Double conversion, if there are more than one data set that are grouped,
  775|      0|        // there is the possibility of some labels being rounded up. A floor() might fix this, but seems to be a brute force solution.
  776|      0|        let label = xAxis.valueFormatter?.stringForValue(e.x, axis: xAxis) ?? "\(e.x)"
  777|      0|
  778|      0|        let elementValueText = dataSet.valueFormatter?.stringForValue(e.y,
  779|      0|                                                                      entry: e,
  780|      0|                                                                      dataSetIndex: dataSetIndex,
  781|      0|                                                                      viewPortHandler: viewPortHandler) ?? "\(e.y)"
  782|      0|
  783|      0|        let dataSetCount = dataProvider.lineData?.dataSetCount ?? -1
  784|      0|        let doesContainMultipleDataSets = dataSetCount > 1
  785|      0|
  786|      0|        element.accessibilityLabel = "\(doesContainMultipleDataSets ? (dataSet.label ?? "")  + ", " : "") \(label): \(elementValueText)"
  787|      0|
  788|      0|        modifier(element)
  789|      0|
  790|      0|        return element
  791|      0|    }
  792|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/LineRadarRenderer.swift:
    1|       |//
    2|       |//  LineRadarRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(LineRadarChartRenderer)
   16|       |open class LineRadarRenderer: LineScatterCandleRadarRenderer
   17|       |{
   18|       |    public override init(animator: Animator, viewPortHandler: ViewPortHandler)
   19|      0|    {
   20|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   21|      0|    }
   22|       |    
   23|       |    /// Draws the provided path in filled mode with the provided drawable.
   24|       |    @objc open func drawFilledPath(context: CGContext, path: CGPath, fill: Fill, fillAlpha: CGFloat)
   25|      0|    {
   26|      0|        
   27|      0|        context.saveGState()
   28|      0|        context.beginPath()
   29|      0|        context.addPath(path)
   30|      0|        
   31|      0|        // filled is usually drawn with less alpha
   32|      0|        context.setAlpha(fillAlpha)
   33|      0|        
   34|      0|        fill.fillPath(context: context, rect: viewPortHandler.contentRect)
   35|      0|        
   36|      0|        context.restoreGState()
   37|      0|    }
   38|       |    
   39|       |    /// Draws the provided path in filled mode with the provided color and alpha.
   40|       |    @objc open func drawFilledPath(context: CGContext, path: CGPath, fillColor: NSUIColor, fillAlpha: CGFloat)
   41|      0|    {
   42|      0|        context.saveGState()
   43|      0|        context.beginPath()
   44|      0|        context.addPath(path)
   45|      0|        
   46|      0|        // filled is usually drawn with less alpha
   47|      0|        context.setAlpha(fillAlpha)
   48|      0|        
   49|      0|        context.setFillColor(fillColor.cgColor)
   50|      0|        context.fillPath()
   51|      0|        
   52|      0|        context.restoreGState()
   53|      0|    }
   54|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/LineScatterCandleRadarRenderer.swift:
    1|       |//
    2|       |//  LineScatterCandleRadarRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(LineScatterCandleRadarChartRenderer)
   16|       |open class LineScatterCandleRadarRenderer: BarLineScatterCandleBubbleRenderer
   17|       |{
   18|       |    public override init(animator: Animator, viewPortHandler: ViewPortHandler)
   19|      0|    {
   20|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   21|      0|    }
   22|       |    
   23|       |    /// Draws vertical & horizontal highlight-lines if enabled.
   24|       |    /// :param: context
   25|       |    /// :param: points
   26|       |    /// :param: horizontal
   27|       |    /// :param: vertical
   28|       |    @objc open func drawHighlightLines(context: CGContext, point: CGPoint, set: ILineScatterCandleRadarChartDataSet)
   29|      0|    {
   30|      0|        
   31|      0|        // draw vertical highlight lines
   32|      0|        if set.isVerticalHighlightIndicatorEnabled
   33|      0|        {
   34|      0|            context.beginPath()
   35|      0|            context.move(to: CGPoint(x: point.x, y: viewPortHandler.contentTop))
   36|      0|            context.addLine(to: CGPoint(x: point.x, y: viewPortHandler.contentBottom))
   37|      0|            context.strokePath()
   38|      0|        }
   39|      0|        
   40|      0|        // draw horizontal highlight lines
   41|      0|        if set.isHorizontalHighlightIndicatorEnabled
   42|      0|        {
   43|      0|            context.beginPath()
   44|      0|            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: point.y))
   45|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: point.y))
   46|      0|            context.strokePath()
   47|      0|        }
   48|      0|    }
   49|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/PieChartRenderer.swift:
    1|       |//
    2|       |//  PieChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |open class PieChartRenderer: DataRenderer
   24|       |{
   25|       |    @objc open weak var chart: PieChartView?
   26|       |
   27|       |    @objc public init(chart: PieChartView, animator: Animator, viewPortHandler: ViewPortHandler)
   28|      0|    {
   29|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   30|      0|
   31|      0|        self.chart = chart
   32|      0|    }
   33|       |
   34|       |    open override func drawData(context: CGContext)
   35|      0|    {
   36|      0|        guard let chart = chart else { return }
   37|      0|
   38|      0|        let pieData = chart.data
   39|      0|
   40|      0|        if pieData != nil
   41|      0|        {
   42|      0|            // If we redraw the data, remove and repopulate accessible elements to update label values and frames
   43|      0|            accessibleChartElements.removeAll()
   44|      0|
   45|      0|            for set in pieData!.dataSets as! [IPieChartDataSet]
   46|      0|                where set.isVisible && set.entryCount > 0
   47|      0|            {
   48|      0|                drawDataSet(context: context, dataSet: set)
   49|      0|            }
   50|      0|        }
   51|      0|    }
   52|       |
   53|       |    @objc open func calculateMinimumRadiusForSpacedSlice(
   54|       |        center: CGPoint,
   55|       |        radius: CGFloat,
   56|       |        angle: CGFloat,
   57|       |        arcStartPointX: CGFloat,
   58|       |        arcStartPointY: CGFloat,
   59|       |        startAngle: CGFloat,
   60|       |        sweepAngle: CGFloat) -> CGFloat
   61|      0|    {
   62|      0|        let angleMiddle = startAngle + sweepAngle / 2.0
   63|      0|
   64|      0|        // Other point of the arc
   65|      0|        let arcEndPointX = center.x + radius * cos((startAngle + sweepAngle).DEG2RAD)
   66|      0|        let arcEndPointY = center.y + radius * sin((startAngle + sweepAngle).DEG2RAD)
   67|      0|
   68|      0|        // Middle point on the arc
   69|      0|        let arcMidPointX = center.x + radius * cos(angleMiddle.DEG2RAD)
   70|      0|        let arcMidPointY = center.y + radius * sin(angleMiddle.DEG2RAD)
   71|      0|
   72|      0|        // This is the base of the contained triangle
   73|      0|        let basePointsDistance = sqrt(
   74|      0|            pow(arcEndPointX - arcStartPointX, 2) +
   75|      0|                pow(arcEndPointY - arcStartPointY, 2))
   76|      0|
   77|      0|        // After reducing space from both sides of the "slice",
   78|      0|        //   the angle of the contained triangle should stay the same.
   79|      0|        // So let's find out the height of that triangle.
   80|      0|        let containedTriangleHeight = (basePointsDistance / 2.0 *
   81|      0|            tan((180.0 - angle).DEG2RAD / 2.0))
   82|      0|
   83|      0|        // Now we subtract that from the radius
   84|      0|        var spacedRadius = radius - containedTriangleHeight
   85|      0|
   86|      0|        // And now subtract the height of the arc that's between the triangle and the outer circle
   87|      0|        spacedRadius -= sqrt(
   88|      0|            pow(arcMidPointX - (arcEndPointX + arcStartPointX) / 2.0, 2) +
   89|      0|                pow(arcMidPointY - (arcEndPointY + arcStartPointY) / 2.0, 2))
   90|      0|
   91|      0|        return spacedRadius
   92|      0|    }
   93|       |
   94|       |    /// Calculates the sliceSpace to use based on visible values and their size compared to the set sliceSpace.
   95|       |    @objc open func getSliceSpace(dataSet: IPieChartDataSet) -> CGFloat
   96|      0|    {
   97|      0|        guard
   98|      0|            dataSet.automaticallyDisableSliceSpacing,
   99|      0|            let data = chart?.data as? PieChartData
  100|      0|            else { return dataSet.sliceSpace }
  101|      0|
  102|      0|        let spaceSizeRatio = dataSet.sliceSpace / min(viewPortHandler.contentWidth, viewPortHandler.contentHeight)
  103|      0|        let minValueRatio = dataSet.yMin / data.yValueSum * 2.0
  104|      0|
  105|      0|        let sliceSpace = spaceSizeRatio > CGFloat(minValueRatio)
  106|      0|            ? 0.0
  107|      0|            : dataSet.sliceSpace
  108|      0|
  109|      0|        return sliceSpace
  110|      0|    }
  111|       |
  112|       |    @objc open func drawDataSet(context: CGContext, dataSet: IPieChartDataSet)
  113|      0|    {
  114|      0|        guard let chart = chart else {return }
  115|      0|
  116|      0|        var angle: CGFloat = 0.0
  117|      0|        let rotationAngle = chart.rotationAngle
  118|      0|
  119|      0|        let phaseX = animator.phaseX
  120|      0|        let phaseY = animator.phaseY
  121|      0|
  122|      0|        let entryCount = dataSet.entryCount
  123|      0|        let drawAngles = chart.drawAngles
  124|      0|        let center = chart.centerCircleBox
  125|      0|        let radius = chart.radius
  126|      0|        let drawInnerArc = chart.drawHoleEnabled && !chart.drawSlicesUnderHoleEnabled
  127|      0|        let userInnerRadius = drawInnerArc ? radius * chart.holeRadiusPercent : 0.0
  128|      0|
  129|      0|        var visibleAngleCount = 0
  130|      0|        for j in 0 ..< entryCount
  131|      0|        {
  132|      0|            guard let e = dataSet.entryForIndex(j) else { continue }
  133|      0|            if ((abs(e.y) > Double.ulpOfOne))
  134|      0|            {
  135|      0|                visibleAngleCount += 1
  136|      0|            }
  137|      0|        }
  138|      0|
  139|      0|        let sliceSpace = visibleAngleCount <= 1 ? 0.0 : getSliceSpace(dataSet: dataSet)
  140|      0|
  141|      0|        context.saveGState()
  142|      0|
  143|      0|        // Make the chart header the first element in the accessible elements array
  144|      0|        // We can do this in drawDataSet, since we know PieChartView can have only 1 dataSet
  145|      0|        // Also since there's only 1 dataset, we don't use the typical createAccessibleHeader() here.
  146|      0|        // NOTE: - Since we want to summarize the total count of slices/portions/elements, use a default string here
  147|      0|        // This is unlike when we are naming individual slices, wherein it's alright to not use a prefix as descriptor.
  148|      0|        // i.e. We want to VO to say "3 Elements" even if the developer didn't specify an accessibility prefix
  149|      0|        // If prefix is unspecified it is safe to assume they did not want to use "Element 1", so that uses a default empty string
  150|      0|        let prefix: String = chart.data?.accessibilityEntryLabelPrefix ?? "Element"
  151|      0|        let description = chart.chartDescription?.text ?? dataSet.label ?? chart.centerText ??  "Pie Chart"
  152|      0|
  153|      0|        let
  154|      0|        element = NSUIAccessibilityElement(accessibilityContainer: chart)
  155|      0|        element.accessibilityLabel = description + ". \(entryCount) \(prefix + (entryCount == 1 ? "" : "s"))"
  156|      0|        element.accessibilityFrame = chart.bounds
  157|      0|        element.isHeader = true
  158|      0|        accessibleChartElements.append(element)
  159|      0|
  160|      0|        for j in 0 ..< entryCount
  161|      0|        {
  162|      0|            let sliceAngle = drawAngles[j]
  163|      0|            var innerRadius = userInnerRadius
  164|      0|
  165|      0|            guard let e = dataSet.entryForIndex(j) else { continue }
  166|      0|            
  167|      0|            defer
  168|      0|            {
  169|      0|                // From here on, even when skipping (i.e for highlight),
  170|      0|                //  increase the angle
  171|      0|                angle += sliceAngle * CGFloat(phaseX)
  172|      0|            }
  173|      0|
  174|      0|            // draw only if the value is greater than zero
  175|      0|            if abs(e.y) < Double.ulpOfOne { continue }
  176|      0|            
  177|      0|            // Skip if highlighted
  178|      0|            if dataSet.isHighlightEnabled && chart.needsHighlight(index: j)
  179|      0|            {
  180|      0|                continue
  181|      0|            }
  182|      0|        
  183|      0|            let accountForSliceSpacing = sliceSpace > 0.0 && sliceAngle <= 180.0
  184|      0|
  185|      0|            context.setFillColor(dataSet.color(atIndex: j).cgColor)
  186|      0|
  187|      0|            let sliceSpaceAngleOuter = visibleAngleCount == 1 ?
  188|      0|                0.0 :
  189|      0|                sliceSpace / radius.DEG2RAD
  190|      0|            let startAngleOuter = rotationAngle + (angle + sliceSpaceAngleOuter / 2.0) * CGFloat(phaseY)
  191|      0|            var sweepAngleOuter = (sliceAngle - sliceSpaceAngleOuter) * CGFloat(phaseY)
  192|      0|            if sweepAngleOuter < 0.0
  193|      0|            {
  194|      0|                sweepAngleOuter = 0.0
  195|      0|            }
  196|      0|
  197|      0|            let arcStartPointX = center.x + radius * cos(startAngleOuter.DEG2RAD)
  198|      0|            let arcStartPointY = center.y + radius * sin(startAngleOuter.DEG2RAD)
  199|      0|
  200|      0|            let path = CGMutablePath()
  201|      0|
  202|      0|            path.move(to: CGPoint(x: arcStartPointX,
  203|      0|                                  y: arcStartPointY))
  204|      0|
  205|      0|            path.addRelativeArc(center: center, radius: radius, startAngle: startAngleOuter.DEG2RAD, delta: sweepAngleOuter.DEG2RAD)
  206|      0|
  207|      0|            if drawInnerArc &&
  208|      0|                (innerRadius > 0.0 || accountForSliceSpacing)
  209|      0|            {
  210|      0|                if accountForSliceSpacing
  211|      0|                {
  212|      0|                    var minSpacedRadius = calculateMinimumRadiusForSpacedSlice(
  213|      0|                        center: center,
  214|      0|                        radius: radius,
  215|      0|                        angle: sliceAngle * CGFloat(phaseY),
  216|      0|                        arcStartPointX: arcStartPointX,
  217|      0|                        arcStartPointY: arcStartPointY,
  218|      0|                        startAngle: startAngleOuter,
  219|      0|                        sweepAngle: sweepAngleOuter)
  220|      0|                    if minSpacedRadius < 0.0
  221|      0|                    {
  222|      0|                        minSpacedRadius = -minSpacedRadius
  223|      0|                    }
  224|      0|                    innerRadius = min(max(innerRadius, minSpacedRadius), radius)
  225|      0|                }
  226|      0|
  227|      0|                let sliceSpaceAngleInner = visibleAngleCount == 1 || innerRadius == 0.0 ?
  228|      0|                    0.0 :
  229|      0|                    sliceSpace / innerRadius.DEG2RAD
  230|      0|                let startAngleInner = rotationAngle + (angle + sliceSpaceAngleInner / 2.0) * CGFloat(phaseY)
  231|      0|                var sweepAngleInner = (sliceAngle - sliceSpaceAngleInner) * CGFloat(phaseY)
  232|      0|                if sweepAngleInner < 0.0
  233|      0|                {
  234|      0|                    sweepAngleInner = 0.0
  235|      0|                }
  236|      0|                let endAngleInner = startAngleInner + sweepAngleInner
  237|      0|
  238|      0|                path.addLine(
  239|      0|                    to: CGPoint(
  240|      0|                        x: center.x + innerRadius * cos(endAngleInner.DEG2RAD),
  241|      0|                        y: center.y + innerRadius * sin(endAngleInner.DEG2RAD)))
  242|      0|
  243|      0|                path.addRelativeArc(center: center, radius: innerRadius, startAngle: endAngleInner.DEG2RAD, delta: -sweepAngleInner.DEG2RAD)
  244|      0|            }
  245|      0|            else
  246|      0|            {
  247|      0|                if accountForSliceSpacing
  248|      0|                {
  249|      0|                    let angleMiddle = startAngleOuter + sweepAngleOuter / 2.0
  250|      0|
  251|      0|                    let sliceSpaceOffset =
  252|      0|                        calculateMinimumRadiusForSpacedSlice(
  253|      0|                            center: center,
  254|      0|                            radius: radius,
  255|      0|                            angle: sliceAngle * CGFloat(phaseY),
  256|      0|                            arcStartPointX: arcStartPointX,
  257|      0|                            arcStartPointY: arcStartPointY,
  258|      0|                            startAngle: startAngleOuter,
  259|      0|                            sweepAngle: sweepAngleOuter)
  260|      0|
  261|      0|                    let arcEndPointX = center.x + sliceSpaceOffset * cos(angleMiddle.DEG2RAD)
  262|      0|                    let arcEndPointY = center.y + sliceSpaceOffset * sin(angleMiddle.DEG2RAD)
  263|      0|
  264|      0|                    path.addLine(
  265|      0|                        to: CGPoint(
  266|      0|                            x: arcEndPointX,
  267|      0|                            y: arcEndPointY))
  268|      0|                }
  269|      0|                else
  270|      0|                {
  271|      0|                    path.addLine(to: center)
  272|      0|                }
  273|      0|            }
  274|      0|
  275|      0|            path.closeSubpath()
  276|      0|
  277|      0|            context.beginPath()
  278|      0|            context.addPath(path)
  279|      0|            context.fillPath(using: .evenOdd)
  280|      0|
  281|      0|            let axElement = createAccessibleElement(withIndex: j,
  282|      0|                                                    container: chart,
  283|      0|                                                    dataSet: dataSet)
  284|      0|            { (element) in
  285|      0|                element.accessibilityFrame = path.boundingBoxOfPath
  286|      0|            }
  287|      0|
  288|      0|            accessibleChartElements.append(axElement)
  289|      0|        }
  290|      0|
  291|      0|        // Post this notification to let VoiceOver account for the redrawn frames
  292|      0|        accessibilityPostLayoutChangedNotification()
  293|      0|
  294|      0|        context.restoreGState()
  295|      0|    }
  296|       |
  297|       |    open override func drawValues(context: CGContext)
  298|      0|    {
  299|      0|        guard
  300|      0|            let chart = chart,
  301|      0|            let data = chart.data
  302|      0|            else { return }
  303|      0|
  304|      0|        let center = chart.centerCircleBox
  305|      0|
  306|      0|        // get whole the radius
  307|      0|        let radius = chart.radius
  308|      0|        let rotationAngle = chart.rotationAngle
  309|      0|        let drawAngles = chart.drawAngles
  310|      0|        let absoluteAngles = chart.absoluteAngles
  311|      0|
  312|      0|        let phaseX = animator.phaseX
  313|      0|        let phaseY = animator.phaseY
  314|      0|
  315|      0|        var labelRadiusOffset = radius / 10.0 * 3.0
  316|      0|
  317|      0|        if chart.drawHoleEnabled
  318|      0|        {
  319|      0|            labelRadiusOffset = (radius - (radius * chart.holeRadiusPercent)) / 2.0
  320|      0|        }
  321|      0|
  322|      0|        let labelRadius = radius - labelRadiusOffset
  323|      0|
  324|      0|        let dataSets = data.dataSets
  325|      0|
  326|      0|        let yValueSum = (data as! PieChartData).yValueSum
  327|      0|
  328|      0|        let drawEntryLabels = chart.isDrawEntryLabelsEnabled
  329|      0|        let usePercentValuesEnabled = chart.usePercentValuesEnabled
  330|      0|
  331|      0|        var angle: CGFloat = 0.0
  332|      0|        var xIndex = 0
  333|      0|
  334|      0|        context.saveGState()
  335|      0|        defer { context.restoreGState() }
  336|      0|
  337|      0|        for i in 0 ..< dataSets.count
  338|      0|        {
  339|      0|            guard let dataSet = dataSets[i] as? IPieChartDataSet else { continue }
  340|      0|
  341|      0|            let drawValues = dataSet.isDrawValuesEnabled
  342|      0|
  343|      0|            if !drawValues && !drawEntryLabels && !dataSet.isDrawIconsEnabled
  344|      0|            {
  345|      0|                continue
  346|      0|            }
  347|      0|
  348|      0|            let iconsOffset = dataSet.iconsOffset
  349|      0|
  350|      0|            let xValuePosition = dataSet.xValuePosition
  351|      0|            let yValuePosition = dataSet.yValuePosition
  352|      0|
  353|      0|            let valueFont = dataSet.valueFont
  354|      0|            let entryLabelFont = dataSet.entryLabelFont ?? chart.entryLabelFont
  355|      0|            let lineHeight = valueFont.lineHeight
  356|      0|
  357|      0|            guard let formatter = dataSet.valueFormatter else { continue }
  358|      0|
  359|      0|            for j in 0 ..< dataSet.entryCount
  360|      0|            {
  361|      0|                guard let e = dataSet.entryForIndex(j) else { continue }
  362|      0|                let pe = e as? PieChartDataEntry
  363|      0|
  364|      0|                if xIndex == 0
  365|      0|                {
  366|      0|                    angle = 0.0
  367|      0|                }
  368|      0|                else
  369|      0|                {
  370|      0|                    angle = absoluteAngles[xIndex - 1] * CGFloat(phaseX)
  371|      0|                }
  372|      0|
  373|      0|                let sliceAngle = drawAngles[xIndex]
  374|      0|                let sliceSpace = getSliceSpace(dataSet: dataSet)
  375|      0|                let sliceSpaceMiddleAngle = sliceSpace / labelRadius.DEG2RAD
  376|      0|
  377|      0|                // offset needed to center the drawn text in the slice
  378|      0|                let angleOffset = (sliceAngle - sliceSpaceMiddleAngle / 2.0) / 2.0
  379|      0|
  380|      0|                angle = angle + angleOffset
  381|      0|
  382|      0|                let transformedAngle = rotationAngle + angle * CGFloat(phaseY)
  383|      0|
  384|      0|                let value = usePercentValuesEnabled ? e.y / yValueSum * 100.0 : e.y
  385|      0|                let valueText = formatter.stringForValue(
  386|      0|                    value,
  387|      0|                    entry: e,
  388|      0|                    dataSetIndex: i,
  389|      0|                    viewPortHandler: viewPortHandler)
  390|      0|
  391|      0|                let sliceXBase = cos(transformedAngle.DEG2RAD)
  392|      0|                let sliceYBase = sin(transformedAngle.DEG2RAD)
  393|      0|
  394|      0|                let drawXOutside = drawEntryLabels && xValuePosition == .outsideSlice
  395|      0|                let drawYOutside = drawValues && yValuePosition == .outsideSlice
  396|      0|                let drawXInside = drawEntryLabels && xValuePosition == .insideSlice
  397|      0|                let drawYInside = drawValues && yValuePosition == .insideSlice
  398|      0|
  399|      0|                let valueTextColor = dataSet.valueTextColorAt(j)
  400|      0|                let entryLabelColor = dataSet.entryLabelColor ?? chart.entryLabelColor
  401|      0|
  402|      0|                if drawXOutside || drawYOutside
  403|      0|                {
  404|      0|                    let valueLineLength1 = dataSet.valueLinePart1Length
  405|      0|                    let valueLineLength2 = dataSet.valueLinePart2Length
  406|      0|                    let valueLinePart1OffsetPercentage = dataSet.valueLinePart1OffsetPercentage
  407|      0|
  408|      0|                    var pt2: CGPoint
  409|      0|                    var labelPoint: CGPoint
  410|      0|                    var align: NSTextAlignment
  411|      0|
  412|      0|                    var line1Radius: CGFloat
  413|      0|
  414|      0|                    if chart.drawHoleEnabled
  415|      0|                    {
  416|      0|                        line1Radius = (radius - (radius * chart.holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * chart.holeRadiusPercent)
  417|      0|                    }
  418|      0|                    else
  419|      0|                    {
  420|      0|                        line1Radius = radius * valueLinePart1OffsetPercentage
  421|      0|                    }
  422|      0|
  423|      0|                    let polyline2Length = dataSet.valueLineVariableLength
  424|      0|                        ? labelRadius * valueLineLength2 * abs(sin(transformedAngle.DEG2RAD))
  425|      0|                        : labelRadius * valueLineLength2
  426|      0|
  427|      0|                    let pt0 = CGPoint(
  428|      0|                        x: line1Radius * sliceXBase + center.x,
  429|      0|                        y: line1Radius * sliceYBase + center.y)
  430|      0|
  431|      0|                    let pt1 = CGPoint(
  432|      0|                        x: labelRadius * (1 + valueLineLength1) * sliceXBase + center.x,
  433|      0|                        y: labelRadius * (1 + valueLineLength1) * sliceYBase + center.y)
  434|      0|
  435|      0|                    if transformedAngle.truncatingRemainder(dividingBy: 360.0) >= 90.0 && transformedAngle.truncatingRemainder(dividingBy: 360.0) <= 270.0
  436|      0|                    {
  437|      0|                        pt2 = CGPoint(x: pt1.x - polyline2Length, y: pt1.y)
  438|      0|                        align = .right
  439|      0|                        labelPoint = CGPoint(x: pt2.x - 5, y: pt2.y - lineHeight)
  440|      0|                    }
  441|      0|                    else
  442|      0|                    {
  443|      0|                        pt2 = CGPoint(x: pt1.x + polyline2Length, y: pt1.y)
  444|      0|                        align = .left
  445|      0|                        labelPoint = CGPoint(x: pt2.x + 5, y: pt2.y - lineHeight)
  446|      0|                    }
  447|      0|
  448|      0|                    DrawLine: do
  449|      0|                    {
  450|      0|                        if dataSet.useValueColorForLine
  451|      0|                        {
  452|      0|                            context.setStrokeColor(dataSet.color(atIndex: j).cgColor)
  453|      0|                        }
  454|      0|                        else if let valueLineColor = dataSet.valueLineColor
  455|      0|                        {
  456|      0|                            context.setStrokeColor(valueLineColor.cgColor)
  457|      0|                        }
  458|      0|                        else
  459|      0|                        {
  460|      0|                            return
  461|      0|                        }
  462|      0|                        context.setLineWidth(dataSet.valueLineWidth)
  463|      0|
  464|      0|                        context.move(to: CGPoint(x: pt0.x, y: pt0.y))
  465|      0|                        context.addLine(to: CGPoint(x: pt1.x, y: pt1.y))
  466|      0|                        context.addLine(to: CGPoint(x: pt2.x, y: pt2.y))
  467|      0|
  468|      0|                        context.drawPath(using: CGPathDrawingMode.stroke)
  469|      0|                    }
  470|      0|                    
  471|      0|                    if drawXOutside && drawYOutside
  472|      0|                    {
  473|      0|                        ChartUtils.drawText(
  474|      0|                            context: context,
  475|      0|                            text: valueText,
  476|      0|                            point: labelPoint,
  477|      0|                            align: align,
  478|      0|                            attributes: [NSAttributedString.Key.font: valueFont, NSAttributedString.Key.foregroundColor: valueTextColor]
  479|      0|                        )
  480|      0|
  481|      0|                        if j < data.entryCount && pe?.label != nil
  482|      0|                        {
  483|      0|                            ChartUtils.drawText(
  484|      0|                                context: context,
  485|      0|                                text: pe!.label!,
  486|      0|                                point: CGPoint(x: labelPoint.x, y: labelPoint.y + lineHeight),
  487|      0|                                align: align,
  488|      0|                                attributes: [
  489|      0|                                    NSAttributedString.Key.font: entryLabelFont ?? valueFont,
  490|      0|                                    NSAttributedString.Key.foregroundColor: entryLabelColor ?? valueTextColor]
  491|      0|                            )
  492|      0|                        }
  493|      0|                    }
  494|      0|                    else if drawXOutside
  495|      0|                    {
  496|      0|                        if j < data.entryCount && pe?.label != nil
  497|      0|                        {
  498|      0|                            ChartUtils.drawText(
  499|      0|                                context: context,
  500|      0|                                text: pe!.label!,
  501|      0|                                point: CGPoint(x: labelPoint.x, y: labelPoint.y + lineHeight / 2.0),
  502|      0|                                align: align,
  503|      0|                                attributes: [
  504|      0|                                    NSAttributedString.Key.font: entryLabelFont ?? valueFont,
  505|      0|                                    NSAttributedString.Key.foregroundColor: entryLabelColor ?? valueTextColor]
  506|      0|                            )
  507|      0|                        }
  508|      0|                    }
  509|      0|                    else if drawYOutside
  510|      0|                    {
  511|      0|                        ChartUtils.drawText(
  512|      0|                            context: context,
  513|      0|                            text: valueText,
  514|      0|                            point: CGPoint(x: labelPoint.x, y: labelPoint.y + lineHeight / 2.0),
  515|      0|                            align: align,
  516|      0|                            attributes: [NSAttributedString.Key.font: valueFont, NSAttributedString.Key.foregroundColor: valueTextColor]
  517|      0|                        )
  518|      0|                    }
  519|      0|                }
  520|      0|
  521|      0|                if drawXInside || drawYInside
  522|      0|                {
  523|      0|                    // calculate the text position
  524|      0|                    let x = labelRadius * sliceXBase + center.x
  525|      0|                    let y = labelRadius * sliceYBase + center.y - lineHeight
  526|      0|
  527|      0|                    if drawXInside && drawYInside
  528|      0|                    {
  529|      0|                        ChartUtils.drawText(
  530|      0|                            context: context,
  531|      0|                            text: valueText,
  532|      0|                            point: CGPoint(x: x, y: y),
  533|      0|                            align: .center,
  534|      0|                            attributes: [NSAttributedString.Key.font: valueFont, NSAttributedString.Key.foregroundColor: valueTextColor]
  535|      0|                        )
  536|      0|
  537|      0|                        if j < data.entryCount && pe?.label != nil
  538|      0|                        {
  539|      0|                            ChartUtils.drawText(
  540|      0|                                context: context,
  541|      0|                                text: pe!.label!,
  542|      0|                                point: CGPoint(x: x, y: y + lineHeight),
  543|      0|                                align: .center,
  544|      0|                                attributes: [
  545|      0|                                    NSAttributedString.Key.font: entryLabelFont ?? valueFont,
  546|      0|                                    NSAttributedString.Key.foregroundColor: entryLabelColor ?? valueTextColor]
  547|      0|                            )
  548|      0|                        }
  549|      0|                    }
  550|      0|                    else if drawXInside
  551|      0|                    {
  552|      0|                        if j < data.entryCount && pe?.label != nil
  553|      0|                        {
  554|      0|                            ChartUtils.drawText(
  555|      0|                                context: context,
  556|      0|                                text: pe!.label!,
  557|      0|                                point: CGPoint(x: x, y: y + lineHeight / 2.0),
  558|      0|                                align: .center,
  559|      0|                                attributes: [
  560|      0|                                    NSAttributedString.Key.font: entryLabelFont ?? valueFont,
  561|      0|                                    NSAttributedString.Key.foregroundColor: entryLabelColor ?? valueTextColor]
  562|      0|                            )
  563|      0|                        }
  564|      0|                    }
  565|      0|                    else if drawYInside
  566|      0|                    {
  567|      0|                        ChartUtils.drawText(
  568|      0|                            context: context,
  569|      0|                            text: valueText,
  570|      0|                            point: CGPoint(x: x, y: y + lineHeight / 2.0),
  571|      0|                            align: .center,
  572|      0|                            attributes: [NSAttributedString.Key.font: valueFont, NSAttributedString.Key.foregroundColor: valueTextColor]
  573|      0|                        )
  574|      0|                    }
  575|      0|                }
  576|      0|
  577|      0|                if let icon = e.icon, dataSet.isDrawIconsEnabled
  578|      0|                {
  579|      0|                    // calculate the icon's position
  580|      0|
  581|      0|                    let x = (labelRadius + iconsOffset.y) * sliceXBase + center.x
  582|      0|                    var y = (labelRadius + iconsOffset.y) * sliceYBase + center.y
  583|      0|                    y += iconsOffset.x
  584|      0|
  585|      0|                    ChartUtils.drawImage(context: context,
  586|      0|                                         image: icon,
  587|      0|                                         x: x,
  588|      0|                                         y: y,
  589|      0|                                         size: icon.size)
  590|      0|                }
  591|      0|
  592|      0|                xIndex += 1
  593|      0|            }
  594|      0|        }
  595|      0|    }
  596|       |
  597|       |    open override func drawExtras(context: CGContext)
  598|      0|    {
  599|      0|        drawHole(context: context)
  600|      0|        drawCenterText(context: context)
  601|      0|    }
  602|       |
  603|       |    /// draws the hole in the center of the chart and the transparent circle / hole
  604|       |    private func drawHole(context: CGContext)
  605|      0|    {
  606|      0|        guard let chart = chart else { return }
  607|      0|
  608|      0|        if chart.drawHoleEnabled
  609|      0|        {
  610|      0|            context.saveGState()
  611|      0|
  612|      0|            let radius = chart.radius
  613|      0|            let holeRadius = radius * chart.holeRadiusPercent
  614|      0|            let center = chart.centerCircleBox
  615|      0|
  616|      0|            if let holeColor = chart.holeColor
  617|      0|            {
  618|      0|                if holeColor != NSUIColor.clear
  619|      0|                {
  620|      0|                    // draw the hole-circle
  621|      0|                    context.setFillColor(chart.holeColor!.cgColor)
  622|      0|                    context.fillEllipse(in: CGRect(x: center.x - holeRadius, y: center.y - holeRadius, width: holeRadius * 2.0, height: holeRadius * 2.0))
  623|      0|                }
  624|      0|            }
  625|      0|
  626|      0|            // only draw the circle if it can be seen (not covered by the hole)
  627|      0|            if let transparentCircleColor = chart.transparentCircleColor
  628|      0|            {
  629|      0|                if transparentCircleColor != NSUIColor.clear &&
  630|      0|                    chart.transparentCircleRadiusPercent > chart.holeRadiusPercent
  631|      0|                {
  632|      0|                    let alpha = animator.phaseX * animator.phaseY
  633|      0|                    let secondHoleRadius = radius * chart.transparentCircleRadiusPercent
  634|      0|
  635|      0|                    // make transparent
  636|      0|                    context.setAlpha(CGFloat(alpha))
  637|      0|                    context.setFillColor(transparentCircleColor.cgColor)
  638|      0|
  639|      0|                    // draw the transparent-circle
  640|      0|                    context.beginPath()
  641|      0|                    context.addEllipse(in: CGRect(
  642|      0|                        x: center.x - secondHoleRadius,
  643|      0|                        y: center.y - secondHoleRadius,
  644|      0|                        width: secondHoleRadius * 2.0,
  645|      0|                        height: secondHoleRadius * 2.0))
  646|      0|                    context.addEllipse(in: CGRect(
  647|      0|                        x: center.x - holeRadius,
  648|      0|                        y: center.y - holeRadius,
  649|      0|                        width: holeRadius * 2.0,
  650|      0|                        height: holeRadius * 2.0))
  651|      0|                    context.fillPath(using: .evenOdd)
  652|      0|                }
  653|      0|            }
  654|      0|
  655|      0|            context.restoreGState()
  656|      0|        }
  657|      0|    }
  658|       |
  659|       |    /// draws the description text in the center of the pie chart makes most sense when center-hole is enabled
  660|       |    private func drawCenterText(context: CGContext)
  661|      0|    {
  662|      0|        guard
  663|      0|            let chart = chart,
  664|      0|            let centerAttributedText = chart.centerAttributedText
  665|      0|            else { return }
  666|      0|
  667|      0|        if chart.drawCenterTextEnabled && centerAttributedText.length > 0
  668|      0|        {
  669|      0|            let center = chart.centerCircleBox
  670|      0|            let offset = chart.centerTextOffset
  671|      0|            let innerRadius = chart.drawHoleEnabled && !chart.drawSlicesUnderHoleEnabled ? chart.radius * chart.holeRadiusPercent : chart.radius
  672|      0|
  673|      0|            let x = center.x + offset.x
  674|      0|            let y = center.y + offset.y
  675|      0|
  676|      0|            let holeRect = CGRect(
  677|      0|                x: x - innerRadius,
  678|      0|                y: y - innerRadius,
  679|      0|                width: innerRadius * 2.0,
  680|      0|                height: innerRadius * 2.0)
  681|      0|            var boundingRect = holeRect
  682|      0|
  683|      0|            if chart.centerTextRadiusPercent > 0.0
  684|      0|            {
  685|      0|                boundingRect = boundingRect.insetBy(dx: (boundingRect.width - boundingRect.width * chart.centerTextRadiusPercent) / 2.0, dy: (boundingRect.height - boundingRect.height * chart.centerTextRadiusPercent) / 2.0)
  686|      0|            }
  687|      0|
  688|      0|            let textBounds = centerAttributedText.boundingRect(with: boundingRect.size, options: [.usesLineFragmentOrigin, .usesFontLeading, .truncatesLastVisibleLine], context: nil)
  689|      0|
  690|      0|            var drawingRect = boundingRect
  691|      0|            drawingRect.origin.x += (boundingRect.size.width - textBounds.size.width) / 2.0
  692|      0|            drawingRect.origin.y += (boundingRect.size.height - textBounds.size.height) / 2.0
  693|      0|            drawingRect.size = textBounds.size
  694|      0|
  695|      0|            context.saveGState()
  696|      0|
  697|      0|            let clippingPath = CGPath(ellipseIn: holeRect, transform: nil)
  698|      0|            context.beginPath()
  699|      0|            context.addPath(clippingPath)
  700|      0|            context.clip()
  701|      0|
  702|      0|            centerAttributedText.draw(with: drawingRect, options: [.usesLineFragmentOrigin, .usesFontLeading, .truncatesLastVisibleLine], context: nil)
  703|      0|
  704|      0|            context.restoreGState()
  705|      0|        }
  706|      0|    }
  707|       |
  708|       |    open override func drawHighlighted(context: CGContext, indices: [Highlight])
  709|      0|    {
  710|      0|        guard
  711|      0|            let chart = chart,
  712|      0|            let data = chart.data
  713|      0|            else { return }
  714|      0|
  715|      0|        context.saveGState()
  716|      0|
  717|      0|        let phaseX = animator.phaseX
  718|      0|        let phaseY = animator.phaseY
  719|      0|
  720|      0|        var angle: CGFloat = 0.0
  721|      0|        let rotationAngle = chart.rotationAngle
  722|      0|
  723|      0|        let drawAngles = chart.drawAngles
  724|      0|        let absoluteAngles = chart.absoluteAngles
  725|      0|        let center = chart.centerCircleBox
  726|      0|        let radius = chart.radius
  727|      0|        let drawInnerArc = chart.drawHoleEnabled && !chart.drawSlicesUnderHoleEnabled
  728|      0|        let userInnerRadius = drawInnerArc ? radius * chart.holeRadiusPercent : 0.0
  729|      0|
  730|      0|        // Append highlighted accessibility slices into this array, so we can prioritize them over unselected slices
  731|      0|        var highlightedAccessibleElements: [NSUIAccessibilityElement] = []
  732|      0|
  733|      0|        for i in 0 ..< indices.count
  734|      0|        {
  735|      0|            // get the index to highlight
  736|      0|            let index = Int(indices[i].x)
  737|      0|            if index >= drawAngles.count
  738|      0|            {
  739|      0|                continue
  740|      0|            }
  741|      0|
  742|      0|            guard let set = data.getDataSetByIndex(indices[i].dataSetIndex) as? IPieChartDataSet else { continue }
  743|      0|            
  744|      0|            if !set.isHighlightEnabled { continue }
  745|      0|
  746|      0|            let entryCount = set.entryCount
  747|      0|            var visibleAngleCount = 0
  748|      0|            for j in 0 ..< entryCount
  749|      0|            {
  750|      0|                guard let e = set.entryForIndex(j) else { continue }
  751|      0|                if ((abs(e.y) > Double.ulpOfOne))
  752|      0|                {
  753|      0|                    visibleAngleCount += 1
  754|      0|                }
  755|      0|            }
  756|      0|
  757|      0|            if index == 0
  758|      0|            {
  759|      0|                angle = 0.0
  760|      0|            }
  761|      0|            else
  762|      0|            {
  763|      0|                angle = absoluteAngles[index - 1] * CGFloat(phaseX)
  764|      0|            }
  765|      0|
  766|      0|            let sliceSpace = visibleAngleCount <= 1 ? 0.0 : set.sliceSpace
  767|      0|
  768|      0|            let sliceAngle = drawAngles[index]
  769|      0|            var innerRadius = userInnerRadius
  770|      0|
  771|      0|            let shift = set.selectionShift
  772|      0|            let highlightedRadius = radius + shift
  773|      0|
  774|      0|            let accountForSliceSpacing = sliceSpace > 0.0 && sliceAngle <= 180.0
  775|      0|
  776|      0|            context.setFillColor(set.highlightColor?.cgColor ?? set.color(atIndex: index).cgColor)
  777|      0|
  778|      0|            let sliceSpaceAngleOuter = visibleAngleCount == 1 ?
  779|      0|                0.0 :
  780|      0|                sliceSpace / radius.DEG2RAD
  781|      0|
  782|      0|            let sliceSpaceAngleShifted = visibleAngleCount == 1 ?
  783|      0|                0.0 :
  784|      0|                sliceSpace / highlightedRadius.DEG2RAD
  785|      0|
  786|      0|            let startAngleOuter = rotationAngle + (angle + sliceSpaceAngleOuter / 2.0) * CGFloat(phaseY)
  787|      0|            var sweepAngleOuter = (sliceAngle - sliceSpaceAngleOuter) * CGFloat(phaseY)
  788|      0|            if sweepAngleOuter < 0.0
  789|      0|            {
  790|      0|                sweepAngleOuter = 0.0
  791|      0|            }
  792|      0|
  793|      0|            let startAngleShifted = rotationAngle + (angle + sliceSpaceAngleShifted / 2.0) * CGFloat(phaseY)
  794|      0|            var sweepAngleShifted = (sliceAngle - sliceSpaceAngleShifted) * CGFloat(phaseY)
  795|      0|            if sweepAngleShifted < 0.0
  796|      0|            {
  797|      0|                sweepAngleShifted = 0.0
  798|      0|            }
  799|      0|
  800|      0|            let path = CGMutablePath()
  801|      0|
  802|      0|            path.move(to: CGPoint(x: center.x + highlightedRadius * cos(startAngleShifted.DEG2RAD),
  803|      0|                                  y: center.y + highlightedRadius * sin(startAngleShifted.DEG2RAD)))
  804|      0|
  805|      0|            path.addRelativeArc(center: center, radius: highlightedRadius, startAngle: startAngleShifted.DEG2RAD,
  806|      0|                                delta: sweepAngleShifted.DEG2RAD)
  807|      0|
  808|      0|            var sliceSpaceRadius: CGFloat = 0.0
  809|      0|            if accountForSliceSpacing
  810|      0|            {
  811|      0|                sliceSpaceRadius = calculateMinimumRadiusForSpacedSlice(
  812|      0|                    center: center,
  813|      0|                    radius: radius,
  814|      0|                    angle: sliceAngle * CGFloat(phaseY),
  815|      0|                    arcStartPointX: center.x + radius * cos(startAngleOuter.DEG2RAD),
  816|      0|                    arcStartPointY: center.y + radius * sin(startAngleOuter.DEG2RAD),
  817|      0|                    startAngle: startAngleOuter,
  818|      0|                    sweepAngle: sweepAngleOuter)
  819|      0|            }
  820|      0|
  821|      0|            if drawInnerArc &&
  822|      0|                (innerRadius > 0.0 || accountForSliceSpacing)
  823|      0|            {
  824|      0|                if accountForSliceSpacing
  825|      0|                {
  826|      0|                    var minSpacedRadius = sliceSpaceRadius
  827|      0|                    if minSpacedRadius < 0.0
  828|      0|                    {
  829|      0|                        minSpacedRadius = -minSpacedRadius
  830|      0|                    }
  831|      0|                    innerRadius = min(max(innerRadius, minSpacedRadius), radius)
  832|      0|                }
  833|      0|
  834|      0|                let sliceSpaceAngleInner = visibleAngleCount == 1 || innerRadius == 0.0 ?
  835|      0|                    0.0 :
  836|      0|                    sliceSpace / innerRadius.DEG2RAD
  837|      0|                let startAngleInner = rotationAngle + (angle + sliceSpaceAngleInner / 2.0) * CGFloat(phaseY)
  838|      0|                var sweepAngleInner = (sliceAngle - sliceSpaceAngleInner) * CGFloat(phaseY)
  839|      0|                if sweepAngleInner < 0.0
  840|      0|                {
  841|      0|                    sweepAngleInner = 0.0
  842|      0|                }
  843|      0|                let endAngleInner = startAngleInner + sweepAngleInner
  844|      0|
  845|      0|                path.addLine(
  846|      0|                    to: CGPoint(
  847|      0|                        x: center.x + innerRadius * cos(endAngleInner.DEG2RAD),
  848|      0|                        y: center.y + innerRadius * sin(endAngleInner.DEG2RAD)))
  849|      0|
  850|      0|                path.addRelativeArc(center: center, radius: innerRadius,
  851|      0|                                    startAngle: endAngleInner.DEG2RAD,
  852|      0|                                    delta: -sweepAngleInner.DEG2RAD)
  853|      0|            }
  854|      0|            else
  855|      0|            {
  856|      0|                if accountForSliceSpacing
  857|      0|                {
  858|      0|                    let angleMiddle = startAngleOuter + sweepAngleOuter / 2.0
  859|      0|
  860|      0|                    let arcEndPointX = center.x + sliceSpaceRadius * cos(angleMiddle.DEG2RAD)
  861|      0|                    let arcEndPointY = center.y + sliceSpaceRadius * sin(angleMiddle.DEG2RAD)
  862|      0|
  863|      0|                    path.addLine(
  864|      0|                        to: CGPoint(
  865|      0|                            x: arcEndPointX,
  866|      0|                            y: arcEndPointY))
  867|      0|                }
  868|      0|                else
  869|      0|                {
  870|      0|                    path.addLine(to: center)
  871|      0|                }
  872|      0|            }
  873|      0|
  874|      0|            path.closeSubpath()
  875|      0|
  876|      0|            context.beginPath()
  877|      0|            context.addPath(path)
  878|      0|            context.fillPath(using: .evenOdd)
  879|      0|
  880|      0|            let axElement = createAccessibleElement(withIndex: index,
  881|      0|                                                    container: chart,
  882|      0|                                                    dataSet: set)
  883|      0|            { (element) in
  884|      0|                element.accessibilityFrame = path.boundingBoxOfPath
  885|      0|                element.isSelected = true
  886|      0|            }
  887|      0|
  888|      0|            highlightedAccessibleElements.append(axElement)
  889|      0|        }
  890|      0|
  891|      0|        // Prepend selected slices before the already rendered unselected ones.
  892|      0|        // NOTE: - This relies on drawDataSet() being called before drawHighlighted in PieChartView.
  893|      0|        if !accessibleChartElements.isEmpty {
  894|      0|            accessibleChartElements.insert(contentsOf: highlightedAccessibleElements, at: 1)
  895|      0|        }
  896|      0|
  897|      0|        context.restoreGState()
  898|      0|    }
  899|       |
  900|       |    /// Creates an NSUIAccessibilityElement representing a slice of the PieChart.
  901|       |    /// The element only has it's container and label set based on the chart and dataSet. Use the modifier to alter traits and frame.
  902|       |    private func createAccessibleElement(withIndex idx: Int,
  903|       |                                         container: PieChartView,
  904|       |                                         dataSet: IPieChartDataSet,
  905|      0|                                         modifier: (NSUIAccessibilityElement) -> ()) -> NSUIAccessibilityElement {
  906|      0|
  907|      0|        let element = NSUIAccessibilityElement(accessibilityContainer: container)
  908|      0|
  909|      0|        guard let e = dataSet.entryForIndex(idx) else { return element }
  910|      0|        guard let formatter = dataSet.valueFormatter else { return element }
  911|      0|        guard let data = container.data as? PieChartData else { return element }
  912|      0|
  913|      0|        var elementValueText = formatter.stringForValue(
  914|      0|            e.y,
  915|      0|            entry: e,
  916|      0|            dataSetIndex: idx,
  917|      0|            viewPortHandler: viewPortHandler)
  918|      0|
  919|      0|        if container.usePercentValuesEnabled {
  920|      0|            let value = e.y / data.yValueSum * 100.0
  921|      0|            let valueText = formatter.stringForValue(
  922|      0|                value,
  923|      0|                entry: e,
  924|      0|                dataSetIndex: idx,
  925|      0|                viewPortHandler: viewPortHandler)
  926|      0|
  927|      0|            elementValueText = valueText
  928|      0|        }
  929|      0|
  930|      0|        let pieChartDataEntry = (dataSet.entryForIndex(idx) as? PieChartDataEntry)
  931|      0|        let isCount = data.accessibilityEntryLabelSuffixIsCount
  932|      0|        let prefix = data.accessibilityEntryLabelPrefix?.appending("\(idx + 1)") ?? pieChartDataEntry?.label ?? ""
  933|      0|        let suffix = data.accessibilityEntryLabelSuffix ?? ""
  934|      0|        element.accessibilityLabel = "\(prefix) : \(elementValueText) \(suffix  + (isCount ? (e.y == 1.0 ? "" : "s") : "") )"
  935|      0|
  936|      0|        // The modifier allows changing of traits and frame depending on highlight, rotation, etc
  937|      0|        modifier(element)
  938|      0|
  939|      0|        return element
  940|      0|    }
  941|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/RadarChartRenderer.swift:
    1|       |//
    2|       |//  RadarChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class RadarChartRenderer: LineRadarRenderer
   16|       |{
   17|      0|    private lazy var accessibilityXLabels: [String] = {
   18|      0|        guard let chart = chart else { return [] }
   19|      0|        guard let formatter = chart.xAxis.valueFormatter else { return [] }
   20|      0|
   21|      0|        let maxEntryCount = chart.data?.maxEntryCountSet?.entryCount ?? 0
   22|      0|        return stride(from: 0, to: maxEntryCount, by: 1).map {
   23|      0|            formatter.stringForValue(Double($0), axis: chart.xAxis)
   24|      0|        }
   25|      0|    }()
   26|       |
   27|       |    @objc open weak var chart: RadarChartView?
   28|       |
   29|       |    @objc public init(chart: RadarChartView, animator: Animator, viewPortHandler: ViewPortHandler)
   30|      0|    {
   31|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   32|      0|        
   33|      0|        self.chart = chart
   34|      0|    }
   35|       |    
   36|       |    open override func drawData(context: CGContext)
   37|      0|    {
   38|      0|        guard let chart = chart else { return }
   39|      0|        
   40|      0|        let radarData = chart.data
   41|      0|        
   42|      0|        if radarData != nil
   43|      0|        {
   44|      0|            let mostEntries = radarData?.maxEntryCountSet?.entryCount ?? 0
   45|      0|
   46|      0|            // If we redraw the data, remove and repopulate accessible elements to update label values and frames
   47|      0|            self.accessibleChartElements.removeAll()
   48|      0|
   49|      0|            // Make the chart header the first element in the accessible elements array
   50|      0|            if let accessibilityHeaderData = radarData as? RadarChartData {
   51|      0|                let element = createAccessibleHeader(usingChart: chart,
   52|      0|                                                     andData: accessibilityHeaderData,
   53|      0|                                                     withDefaultDescription: "Radar Chart")
   54|      0|                self.accessibleChartElements.append(element)
   55|      0|            }
   56|      0|
   57|      0|            for set in radarData!.dataSets as! [IRadarChartDataSet] where set.isVisible
   58|      0|            {
   59|      0|                drawDataSet(context: context, dataSet: set, mostEntries: mostEntries)
   60|      0|            }
   61|      0|        }
   62|      0|    }
   63|       |    
   64|       |    /// Draws the RadarDataSet
   65|       |    ///
   66|       |    /// - Parameters:
   67|       |    ///   - context:
   68|       |    ///   - dataSet:
   69|       |    ///   - mostEntries: the entry count of the dataset with the most entries
   70|       |    internal func drawDataSet(context: CGContext, dataSet: IRadarChartDataSet, mostEntries: Int)
   71|      0|    {
   72|      0|        guard let chart = chart else { return }
   73|      0|        
   74|      0|        context.saveGState()
   75|      0|        
   76|      0|        let phaseX = animator.phaseX
   77|      0|        let phaseY = animator.phaseY
   78|      0|        
   79|      0|        let sliceangle = chart.sliceAngle
   80|      0|        
   81|      0|        // calculate the factor that is needed for transforming the value to pixels
   82|      0|        let factor = chart.factor
   83|      0|        
   84|      0|        let center = chart.centerOffsets
   85|      0|        let entryCount = dataSet.entryCount
   86|      0|        let path = CGMutablePath()
   87|      0|        var hasMovedToPoint = false
   88|      0|
   89|      0|        let prefix: String = chart.data?.accessibilityEntryLabelPrefix ?? "Item"
   90|      0|        let description = dataSet.label ?? ""
   91|      0|
   92|      0|        // Make a tuple of (xLabels, value, originalIndex) then sort it
   93|      0|        // This is done, so that the labels are narrated in decreasing order of their corresponding value
   94|      0|        // Otherwise, there is no non-visual logic to the data presented
   95|      0|        let accessibilityEntryValues =  Array(0 ..< entryCount).map { (dataSet.entryForIndex($0)?.y ?? 0, $0) }
   96|      0|        let accessibilityAxisLabelValueTuples = zip(accessibilityXLabels, accessibilityEntryValues).map { ($0, $1.0, $1.1) }.sorted { $0.1 > $1.1 }
   97|      0|        let accessibilityDataSetDescription: String = description + ". \(entryCount) \(prefix + (entryCount == 1 ? "" : "s")). "
   98|      0|        let accessibilityFrameWidth: CGFloat = 22.0 // To allow a tap target of 44x44
   99|      0|
  100|      0|        var accessibilityEntryElements: [NSUIAccessibilityElement] = []
  101|      0|
  102|      0|        for j in 0 ..< entryCount
  103|      0|        {
  104|      0|            guard let e = dataSet.entryForIndex(j) else { continue }
  105|      0|            
  106|      0|            let p = center.moving(distance: CGFloat((e.y - chart.chartYMin) * Double(factor) * phaseY),
  107|      0|                                  atAngle: sliceangle * CGFloat(j) * CGFloat(phaseX) + chart.rotationAngle)
  108|      0|            
  109|      0|            if p.x.isNaN
  110|      0|            {
  111|      0|                continue
  112|      0|            }
  113|      0|            
  114|      0|            if !hasMovedToPoint
  115|      0|            {
  116|      0|                path.move(to: p)
  117|      0|                hasMovedToPoint = true
  118|      0|            }
  119|      0|            else
  120|      0|            {
  121|      0|                path.addLine(to: p)
  122|      0|            }
  123|      0|
  124|      0|            let accessibilityLabel = accessibilityAxisLabelValueTuples[j].0
  125|      0|            let accessibilityValue = accessibilityAxisLabelValueTuples[j].1
  126|      0|            let accessibilityValueIndex = accessibilityAxisLabelValueTuples[j].2
  127|      0|
  128|      0|            let axp = center.moving(distance: CGFloat((accessibilityValue - chart.chartYMin) * Double(factor) * phaseY),
  129|      0|                                    atAngle: sliceangle * CGFloat(accessibilityValueIndex) * CGFloat(phaseX) + chart.rotationAngle)
  130|      0|
  131|      0|            let axDescription = description + " - " + accessibilityLabel + ": \(accessibilityValue) \(chart.data?.accessibilityEntryLabelSuffix ?? "")"
  132|      0|            let axElement = createAccessibleElement(withDescription: axDescription,
  133|      0|                                                    container: chart,
  134|      0|                                                    dataSet: dataSet)
  135|      0|            { (element) in
  136|      0|                element.accessibilityFrame = CGRect(x: axp.x - accessibilityFrameWidth,
  137|      0|                                                    y: axp.y - accessibilityFrameWidth,
  138|      0|                                                    width: 2 * accessibilityFrameWidth,
  139|      0|                                                    height: 2 * accessibilityFrameWidth)
  140|      0|            }
  141|      0|
  142|      0|            accessibilityEntryElements.append(axElement)
  143|      0|        }
  144|      0|        
  145|      0|        // if this is the largest set, close it
  146|      0|        if dataSet.entryCount < mostEntries
  147|      0|        {
  148|      0|            // if this is not the largest set, draw a line to the center before closing
  149|      0|            path.addLine(to: center)
  150|      0|        }
  151|      0|        
  152|      0|        path.closeSubpath()
  153|      0|        
  154|      0|        // draw filled
  155|      0|        if dataSet.isDrawFilledEnabled
  156|      0|        {
  157|      0|            if dataSet.fill != nil
  158|      0|            {
  159|      0|                drawFilledPath(context: context, path: path, fill: dataSet.fill!, fillAlpha: dataSet.fillAlpha)
  160|      0|            }
  161|      0|            else
  162|      0|            {
  163|      0|                drawFilledPath(context: context, path: path, fillColor: dataSet.fillColor, fillAlpha: dataSet.fillAlpha)
  164|      0|            }
  165|      0|        }
  166|      0|        
  167|      0|        // draw the line (only if filled is disabled or alpha is below 255)
  168|      0|        if !dataSet.isDrawFilledEnabled || dataSet.fillAlpha < 1.0
  169|      0|        {
  170|      0|            context.setStrokeColor(dataSet.color(atIndex: 0).cgColor)
  171|      0|            context.setLineWidth(dataSet.lineWidth)
  172|      0|            context.setAlpha(1.0)
  173|      0|
  174|      0|            context.beginPath()
  175|      0|            context.addPath(path)
  176|      0|            context.strokePath()
  177|      0|
  178|      0|            let axElement = createAccessibleElement(withDescription: accessibilityDataSetDescription,
  179|      0|                                                    container: chart,
  180|      0|                                                    dataSet: dataSet)
  181|      0|            { (element) in
  182|      0|                element.isHeader = true
  183|      0|                element.accessibilityFrame = path.boundingBoxOfPath
  184|      0|            }
  185|      0|
  186|      0|            accessibleChartElements.append(axElement)
  187|      0|            accessibleChartElements.append(contentsOf: accessibilityEntryElements)
  188|      0|        }
  189|      0|        
  190|      0|        accessibilityPostLayoutChangedNotification()
  191|      0|
  192|      0|        context.restoreGState()
  193|      0|    }
  194|       |    
  195|       |    open override func drawValues(context: CGContext)
  196|      0|    {
  197|      0|        guard
  198|      0|            let chart = chart,
  199|      0|            let data = chart.data
  200|      0|            else { return }
  201|      0|        
  202|      0|        let phaseX = animator.phaseX
  203|      0|        let phaseY = animator.phaseY
  204|      0|        
  205|      0|        let sliceangle = chart.sliceAngle
  206|      0|        
  207|      0|        // calculate the factor that is needed for transforming the value to pixels
  208|      0|        let factor = chart.factor
  209|      0|        
  210|      0|        let center = chart.centerOffsets
  211|      0|        
  212|      0|        let yoffset = CGFloat(5.0)
  213|      0|        
  214|      0|        for i in 0 ..< data.dataSetCount
  215|      0|        {
  216|      0|            guard let
  217|      0|                dataSet = data.getDataSetByIndex(i) as? IRadarChartDataSet,
  218|      0|                shouldDrawValues(forDataSet: dataSet)
  219|      0|                else { continue }
  220|      0|            
  221|      0|            let entryCount = dataSet.entryCount
  222|      0|            
  223|      0|            let iconsOffset = dataSet.iconsOffset
  224|      0|            
  225|      0|            for j in 0 ..< entryCount
  226|      0|            {
  227|      0|                guard let e = dataSet.entryForIndex(j) else { continue }
  228|      0|                
  229|      0|                let p = center.moving(distance: CGFloat(e.y - chart.chartYMin) * factor * CGFloat(phaseY),
  230|      0|                                      atAngle: sliceangle * CGFloat(j) * CGFloat(phaseX) + chart.rotationAngle)
  231|      0|                
  232|      0|                let valueFont = dataSet.valueFont
  233|      0|                
  234|      0|                guard let formatter = dataSet.valueFormatter else { continue }
  235|      0|                
  236|      0|                if dataSet.isDrawValuesEnabled
  237|      0|                {
  238|      0|                    ChartUtils.drawText(
  239|      0|                        context: context,
  240|      0|                        text: formatter.stringForValue(
  241|      0|                            e.y,
  242|      0|                            entry: e,
  243|      0|                            dataSetIndex: i,
  244|      0|                            viewPortHandler: viewPortHandler),
  245|      0|                        point: CGPoint(x: p.x, y: p.y - yoffset - valueFont.lineHeight),
  246|      0|                        align: .center,
  247|      0|                        attributes: [NSAttributedString.Key.font: valueFont,
  248|      0|                            NSAttributedString.Key.foregroundColor: dataSet.valueTextColorAt(j)]
  249|      0|                    )
  250|      0|                }
  251|      0|                
  252|      0|                if let icon = e.icon, dataSet.isDrawIconsEnabled
  253|      0|                {
  254|      0|                    var pIcon = center.moving(distance: CGFloat(e.y) * factor * CGFloat(phaseY) + iconsOffset.y,
  255|      0|                                              atAngle: sliceangle * CGFloat(j) * CGFloat(phaseX) + chart.rotationAngle)
  256|      0|                    pIcon.y += iconsOffset.x
  257|      0|                    
  258|      0|                    ChartUtils.drawImage(context: context,
  259|      0|                                         image: icon,
  260|      0|                                         x: pIcon.x,
  261|      0|                                         y: pIcon.y,
  262|      0|                                         size: icon.size)
  263|      0|                }
  264|      0|            }
  265|      0|        }
  266|      0|    }
  267|       |    
  268|       |    open override func drawExtras(context: CGContext)
  269|      0|    {
  270|      0|        drawWeb(context: context)
  271|      0|    }
  272|       |    
  273|      0|    private var _webLineSegmentsBuffer = [CGPoint](repeating: CGPoint(), count: 2)
  274|       |    
  275|       |    @objc open func drawWeb(context: CGContext)
  276|      0|    {
  277|      0|        guard
  278|      0|            let chart = chart,
  279|      0|            let data = chart.data
  280|      0|            else { return }
  281|      0|        
  282|      0|        let sliceangle = chart.sliceAngle
  283|      0|        
  284|      0|        context.saveGState()
  285|      0|        
  286|      0|        // calculate the factor that is needed for transforming the value to
  287|      0|        // pixels
  288|      0|        let factor = chart.factor
  289|      0|        let rotationangle = chart.rotationAngle
  290|      0|        
  291|      0|        let center = chart.centerOffsets
  292|      0|        
  293|      0|        // draw the web lines that come from the center
  294|      0|        context.setLineWidth(chart.webLineWidth)
  295|      0|        context.setStrokeColor(chart.webColor.cgColor)
  296|      0|        context.setAlpha(chart.webAlpha)
  297|      0|        
  298|      0|        let xIncrements = 1 + chart.skipWebLineCount
  299|      0|        let maxEntryCount = chart.data?.maxEntryCountSet?.entryCount ?? 0
  300|      0|
  301|      0|        for i in stride(from: 0, to: maxEntryCount, by: xIncrements)
  302|      0|        {
  303|      0|            let p = center.moving(distance: CGFloat(chart.yRange) * factor,
  304|      0|                                  atAngle: sliceangle * CGFloat(i) + rotationangle)
  305|      0|            
  306|      0|            _webLineSegmentsBuffer[0].x = center.x
  307|      0|            _webLineSegmentsBuffer[0].y = center.y
  308|      0|            _webLineSegmentsBuffer[1].x = p.x
  309|      0|            _webLineSegmentsBuffer[1].y = p.y
  310|      0|            
  311|      0|            context.strokeLineSegments(between: _webLineSegmentsBuffer)
  312|      0|        }
  313|      0|        
  314|      0|        // draw the inner-web
  315|      0|        context.setLineWidth(chart.innerWebLineWidth)
  316|      0|        context.setStrokeColor(chart.innerWebColor.cgColor)
  317|      0|        context.setAlpha(chart.webAlpha)
  318|      0|        
  319|      0|        let labelCount = chart.yAxis.entryCount
  320|      0|        
  321|      0|        for j in 0 ..< labelCount
  322|      0|        {
  323|      0|            for i in 0 ..< data.entryCount
  324|      0|            {
  325|      0|                let r = CGFloat(chart.yAxis.entries[j] - chart.chartYMin) * factor
  326|      0|
  327|      0|                let p1 = center.moving(distance: r, atAngle: sliceangle * CGFloat(i) + rotationangle)
  328|      0|                let p2 = center.moving(distance: r, atAngle: sliceangle * CGFloat(i + 1) + rotationangle)
  329|      0|                
  330|      0|                _webLineSegmentsBuffer[0].x = p1.x
  331|      0|                _webLineSegmentsBuffer[0].y = p1.y
  332|      0|                _webLineSegmentsBuffer[1].x = p2.x
  333|      0|                _webLineSegmentsBuffer[1].y = p2.y
  334|      0|                
  335|      0|                context.strokeLineSegments(between: _webLineSegmentsBuffer)
  336|      0|            }
  337|      0|        }
  338|      0|        
  339|      0|        context.restoreGState()
  340|      0|    }
  341|       |    
  342|      0|    private var _highlightPointBuffer = CGPoint()
  343|       |
  344|       |    open override func drawHighlighted(context: CGContext, indices: [Highlight])
  345|      0|    {
  346|      0|        guard
  347|      0|            let chart = chart,
  348|      0|            let radarData = chart.data as? RadarChartData
  349|      0|            else { return }
  350|      0|        
  351|      0|        context.saveGState()
  352|      0|        
  353|      0|        let sliceangle = chart.sliceAngle
  354|      0|        
  355|      0|        // calculate the factor that is needed for transforming the value pixels
  356|      0|        let factor = chart.factor
  357|      0|        
  358|      0|        let center = chart.centerOffsets
  359|      0|        
  360|      0|        for high in indices
  361|      0|        {
  362|      0|            guard
  363|      0|                let set = chart.data?.getDataSetByIndex(high.dataSetIndex) as? IRadarChartDataSet,
  364|      0|                set.isHighlightEnabled
  365|      0|                else { continue }
  366|      0|            
  367|      0|            guard let e = set.entryForIndex(Int(high.x)) as? RadarChartDataEntry
  368|      0|                else { continue }
  369|      0|            
  370|      0|            if !isInBoundsX(entry: e, dataSet: set)
  371|      0|            {
  372|      0|                continue
  373|      0|            }
  374|      0|            
  375|      0|            context.setLineWidth(radarData.highlightLineWidth)
  376|      0|            if radarData.highlightLineDashLengths != nil
  377|      0|            {
  378|      0|                context.setLineDash(phase: radarData.highlightLineDashPhase, lengths: radarData.highlightLineDashLengths!)
  379|      0|            }
  380|      0|            else
  381|      0|            {
  382|      0|                context.setLineDash(phase: 0.0, lengths: [])
  383|      0|            }
  384|      0|            
  385|      0|            context.setStrokeColor(set.highlightColor.cgColor)
  386|      0|            
  387|      0|            let y = e.y - chart.chartYMin
  388|      0|            
  389|      0|            _highlightPointBuffer = center.moving(distance: CGFloat(y) * factor * CGFloat(animator.phaseY),
  390|      0|                                                  atAngle: sliceangle * CGFloat(high.x) * CGFloat(animator.phaseX) + chart.rotationAngle)
  391|      0|            
  392|      0|            high.setDraw(pt: _highlightPointBuffer)
  393|      0|            
  394|      0|            // draw the lines
  395|      0|            drawHighlightLines(context: context, point: _highlightPointBuffer, set: set)
  396|      0|            
  397|      0|            if set.isDrawHighlightCircleEnabled
  398|      0|            {
  399|      0|                if !_highlightPointBuffer.x.isNaN && !_highlightPointBuffer.y.isNaN
  400|      0|                {
  401|      0|                    var strokeColor = set.highlightCircleStrokeColor
  402|      0|                    if strokeColor == nil
  403|      0|                    {
  404|      0|                        strokeColor = set.color(atIndex: 0)
  405|      0|                    }
  406|      0|                    if set.highlightCircleStrokeAlpha < 1.0
  407|      0|                    {
  408|      0|                        strokeColor = strokeColor?.withAlphaComponent(set.highlightCircleStrokeAlpha)
  409|      0|                    }
  410|      0|                    
  411|      0|                    drawHighlightCircle(
  412|      0|                        context: context,
  413|      0|                        atPoint: _highlightPointBuffer,
  414|      0|                        innerRadius: set.highlightCircleInnerRadius,
  415|      0|                        outerRadius: set.highlightCircleOuterRadius,
  416|      0|                        fillColor: set.highlightCircleFillColor,
  417|      0|                        strokeColor: strokeColor,
  418|      0|                        strokeWidth: set.highlightCircleStrokeWidth)
  419|      0|                }
  420|      0|            }
  421|      0|        }
  422|      0|        
  423|      0|        context.restoreGState()
  424|      0|    }
  425|       |    
  426|       |    internal func drawHighlightCircle(
  427|       |        context: CGContext,
  428|       |        atPoint point: CGPoint,
  429|       |        innerRadius: CGFloat,
  430|       |        outerRadius: CGFloat,
  431|       |        fillColor: NSUIColor?,
  432|       |        strokeColor: NSUIColor?,
  433|       |        strokeWidth: CGFloat)
  434|      0|    {
  435|      0|        context.saveGState()
  436|      0|        
  437|      0|        if let fillColor = fillColor
  438|      0|        {
  439|      0|            context.beginPath()
  440|      0|            context.addEllipse(in: CGRect(x: point.x - outerRadius, y: point.y - outerRadius, width: outerRadius * 2.0, height: outerRadius * 2.0))
  441|      0|            if innerRadius > 0.0
  442|      0|            {
  443|      0|                context.addEllipse(in: CGRect(x: point.x - innerRadius, y: point.y - innerRadius, width: innerRadius * 2.0, height: innerRadius * 2.0))
  444|      0|            }
  445|      0|            
  446|      0|            context.setFillColor(fillColor.cgColor)
  447|      0|            context.fillPath(using: .evenOdd)
  448|      0|        }
  449|      0|            
  450|      0|        if let strokeColor = strokeColor
  451|      0|        {
  452|      0|            context.beginPath()
  453|      0|            context.addEllipse(in: CGRect(x: point.x - outerRadius, y: point.y - outerRadius, width: outerRadius * 2.0, height: outerRadius * 2.0))
  454|      0|            context.setStrokeColor(strokeColor.cgColor)
  455|      0|            context.setLineWidth(strokeWidth)
  456|      0|            context.strokePath()
  457|      0|        }
  458|      0|        
  459|      0|        context.restoreGState()
  460|      0|    }
  461|       |
  462|       |    private func createAccessibleElement(withDescription description: String,
  463|       |                                         container: RadarChartView,
  464|       |                                         dataSet: IRadarChartDataSet,
  465|      0|                                         modifier: (NSUIAccessibilityElement) -> ()) -> NSUIAccessibilityElement {
  466|      0|
  467|      0|        let element = NSUIAccessibilityElement(accessibilityContainer: container)
  468|      0|        element.accessibilityLabel = description
  469|      0|
  470|      0|        // The modifier allows changing of traits and frame depending on highlight, rotation, etc
  471|      0|        modifier(element)
  472|      0|
  473|      0|        return element
  474|      0|    }
  475|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/Renderer.swift:
    1|       |//
    2|       |//  Renderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartRenderer)
   16|       |open class Renderer: NSObject
   17|       |{
   18|       |    /// the component that handles the drawing area of the chart and it's offsets
   19|       |    @objc public let viewPortHandler: ViewPortHandler
   20|       |
   21|       |    @objc public init(viewPortHandler: ViewPortHandler)
   22|      0|    {
   23|      0|        self.viewPortHandler = viewPortHandler
   24|      0|        super.init()
   25|      0|    }
   26|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/Scatter/ChevronDownShapeRenderer.swift:
    1|       |//
    2|       |//  ChevronDownShapeRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |import Foundation
   12|       |import CoreGraphics
   13|       |
   14|       |open class ChevronDownShapeRenderer : NSObject, IShapeRenderer
   15|       |{
   16|       |    open func renderShape(
   17|       |        context: CGContext,
   18|       |                dataSet: IScatterChartDataSet,
   19|       |                viewPortHandler: ViewPortHandler,
   20|       |                point: CGPoint,
   21|       |                color: NSUIColor)
   22|      0|    {
   23|      0|        let shapeSize = dataSet.scatterShapeSize
   24|      0|        let shapeHalf = shapeSize / 2.0
   25|      0|        
   26|      0|        context.setLineWidth(1.0)
   27|      0|        context.setStrokeColor(color.cgColor)
   28|      0|        
   29|      0|        context.beginPath()
   30|      0|        context.move(to: CGPoint(x: point.x, y: point.y + 2 * shapeHalf))
   31|      0|        context.addLine(to: CGPoint(x: point.x + 2 * shapeHalf, y: point.y))
   32|      0|        context.move(to: CGPoint(x: point.x, y: point.y + 2 * shapeHalf))
   33|      0|        context.addLine(to: CGPoint(x: point.x - 2 * shapeHalf, y: point.y))
   34|      0|        context.strokePath()
   35|      0|    }
   36|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/Scatter/ChevronUpShapeRenderer.swift:
    1|       |//
    2|       |//  ChevronUpShapeRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |import Foundation
   12|       |import CoreGraphics
   13|       |
   14|       |open class ChevronUpShapeRenderer : NSObject, IShapeRenderer
   15|       |{
   16|       |    open func renderShape(
   17|       |        context: CGContext,
   18|       |                dataSet: IScatterChartDataSet,
   19|       |                viewPortHandler: ViewPortHandler,
   20|       |                point: CGPoint,
   21|       |                color: NSUIColor)
   22|      0|    {
   23|      0|        let shapeSize = dataSet.scatterShapeSize
   24|      0|        let shapeHalf = shapeSize / 2.0
   25|      0|        
   26|      0|        context.setLineWidth(1.0)
   27|      0|        context.setStrokeColor(color.cgColor)
   28|      0|        
   29|      0|        context.beginPath()
   30|      0|        context.move(to: CGPoint(x: point.x, y: point.y - 2 * shapeHalf))
   31|      0|        context.addLine(to: CGPoint(x: point.x + 2 * shapeHalf, y: point.y))
   32|      0|        context.move(to: CGPoint(x: point.x, y: point.y - 2 * shapeHalf))
   33|      0|        context.addLine(to: CGPoint(x: point.x - 2 * shapeHalf, y: point.y))
   34|      0|        context.strokePath()
   35|      0|    }
   36|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/Scatter/CircleShapeRenderer.swift:
    1|       |//
    2|       |//  CircleShapeRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |import Foundation
   12|       |import CoreGraphics
   13|       |
   14|       |open class CircleShapeRenderer : NSObject, IShapeRenderer
   15|       |{
   16|       |    open func renderShape(
   17|       |        context: CGContext,
   18|       |        dataSet: IScatterChartDataSet,
   19|       |        viewPortHandler: ViewPortHandler,
   20|       |        point: CGPoint,
   21|       |        color: NSUIColor)
   22|      0|    {
   23|      0|        let shapeSize = dataSet.scatterShapeSize
   24|      0|        let shapeHalf = shapeSize / 2.0
   25|      0|        let shapeHoleSizeHalf = dataSet.scatterShapeHoleRadius
   26|      0|        let shapeHoleSize = shapeHoleSizeHalf * 2.0
   27|      0|        let shapeHoleColor = dataSet.scatterShapeHoleColor
   28|      0|        let shapeStrokeSize = (shapeSize - shapeHoleSize) / 2.0
   29|      0|        let shapeStrokeSizeHalf = shapeStrokeSize / 2.0
   30|      0|        
   31|      0|        if shapeHoleSize > 0.0
   32|      0|        {
   33|      0|            context.setStrokeColor(color.cgColor)
   34|      0|            context.setLineWidth(shapeStrokeSize)
   35|      0|            var rect = CGRect()
   36|      0|            rect.origin.x = point.x - shapeHoleSizeHalf - shapeStrokeSizeHalf
   37|      0|            rect.origin.y = point.y - shapeHoleSizeHalf - shapeStrokeSizeHalf
   38|      0|            rect.size.width = shapeHoleSize + shapeStrokeSize
   39|      0|            rect.size.height = shapeHoleSize + shapeStrokeSize
   40|      0|            context.strokeEllipse(in: rect)
   41|      0|            
   42|      0|            if let shapeHoleColor = shapeHoleColor
   43|      0|            {
   44|      0|                context.setFillColor(shapeHoleColor.cgColor)
   45|      0|                rect.origin.x = point.x - shapeHoleSizeHalf
   46|      0|                rect.origin.y = point.y - shapeHoleSizeHalf
   47|      0|                rect.size.width = shapeHoleSize
   48|      0|                rect.size.height = shapeHoleSize
   49|      0|                context.fillEllipse(in: rect)
   50|      0|            }
   51|      0|        }
   52|      0|        else
   53|      0|        {
   54|      0|            context.setFillColor(color.cgColor)
   55|      0|            var rect = CGRect()
   56|      0|            rect.origin.x = point.x - shapeHalf
   57|      0|            rect.origin.y = point.y - shapeHalf
   58|      0|            rect.size.width = shapeSize
   59|      0|            rect.size.height = shapeSize
   60|      0|            context.fillEllipse(in: rect)
   61|      0|        }
   62|      0|    }
   63|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/Scatter/CrossShapeRenderer.swift:
    1|       |//
    2|       |//  CrossShapeRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |import Foundation
   12|       |import CoreGraphics
   13|       |
   14|       |open class CrossShapeRenderer : NSObject, IShapeRenderer
   15|       |{
   16|       |    open func renderShape(
   17|       |        context: CGContext,
   18|       |        dataSet: IScatterChartDataSet,
   19|       |        viewPortHandler: ViewPortHandler,
   20|       |        point: CGPoint,
   21|       |        color: NSUIColor)
   22|      0|    {
   23|      0|        let shapeSize = dataSet.scatterShapeSize
   24|      0|        let shapeHalf = shapeSize / 2.0
   25|      0|        
   26|      0|        context.setLineWidth(1.0)
   27|      0|        context.setStrokeColor(color.cgColor)
   28|      0|        
   29|      0|        context.beginPath()
   30|      0|        context.move(to: CGPoint(x: point.x - shapeHalf, y: point.y))
   31|      0|        context.addLine(to: CGPoint(x: point.x + shapeHalf, y: point.y))
   32|      0|        context.move(to: CGPoint(x: point.x, y: point.y - shapeHalf))
   33|      0|        context.addLine(to: CGPoint(x: point.x, y: point.y + shapeHalf))
   34|      0|        context.strokePath()
   35|      0|    }
   36|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/Scatter/SquareShapeRenderer.swift:
    1|       |//
    2|       |//  SquareShapeRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |import Foundation
   12|       |import CoreGraphics
   13|       |
   14|       |open class SquareShapeRenderer : NSObject, IShapeRenderer
   15|       |{
   16|       |    open func renderShape(
   17|       |        context: CGContext,
   18|       |        dataSet: IScatterChartDataSet,
   19|       |        viewPortHandler: ViewPortHandler,
   20|       |        point: CGPoint,
   21|       |        color: NSUIColor)
   22|      0|    {
   23|      0|        let shapeSize = dataSet.scatterShapeSize
   24|      0|        let shapeHalf = shapeSize / 2.0
   25|      0|        let shapeHoleSizeHalf = dataSet.scatterShapeHoleRadius
   26|      0|        let shapeHoleSize = shapeHoleSizeHalf * 2.0
   27|      0|        let shapeHoleColor = dataSet.scatterShapeHoleColor
   28|      0|        let shapeStrokeSize = (shapeSize - shapeHoleSize) / 2.0
   29|      0|        let shapeStrokeSizeHalf = shapeStrokeSize / 2.0
   30|      0|        
   31|      0|        if shapeHoleSize > 0.0
   32|      0|        {
   33|      0|            context.setStrokeColor(color.cgColor)
   34|      0|            context.setLineWidth(shapeStrokeSize)
   35|      0|            var rect = CGRect()
   36|      0|            rect.origin.x = point.x - shapeHoleSizeHalf - shapeStrokeSizeHalf
   37|      0|            rect.origin.y = point.y - shapeHoleSizeHalf - shapeStrokeSizeHalf
   38|      0|            rect.size.width = shapeHoleSize + shapeStrokeSize
   39|      0|            rect.size.height = shapeHoleSize + shapeStrokeSize
   40|      0|            context.stroke(rect)
   41|      0|            
   42|      0|            if let shapeHoleColor = shapeHoleColor
   43|      0|            {
   44|      0|                context.setFillColor(shapeHoleColor.cgColor)
   45|      0|                rect.origin.x = point.x - shapeHoleSizeHalf
   46|      0|                rect.origin.y = point.y - shapeHoleSizeHalf
   47|      0|                rect.size.width = shapeHoleSize
   48|      0|                rect.size.height = shapeHoleSize
   49|      0|                context.fill(rect)
   50|      0|            }
   51|      0|        }
   52|      0|        else
   53|      0|        {
   54|      0|            context.setFillColor(color.cgColor)
   55|      0|            var rect = CGRect()
   56|      0|            rect.origin.x = point.x - shapeHalf
   57|      0|            rect.origin.y = point.y - shapeHalf
   58|      0|            rect.size.width = shapeSize
   59|      0|            rect.size.height = shapeSize
   60|      0|            context.fill(rect)
   61|      0|        }
   62|      0|    }
   63|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/Scatter/TriangleShapeRenderer.swift:
    1|       |//
    2|       |//  TriangleShapeRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |import Foundation
   12|       |import CoreGraphics
   13|       |
   14|       |open class TriangleShapeRenderer : NSObject, IShapeRenderer
   15|       |{
   16|       |    open func renderShape(
   17|       |        context: CGContext,
   18|       |        dataSet: IScatterChartDataSet,
   19|       |        viewPortHandler: ViewPortHandler,
   20|       |        point: CGPoint,
   21|       |        color: NSUIColor)
   22|      0|    {
   23|      0|        let shapeSize = dataSet.scatterShapeSize
   24|      0|        let shapeHalf = shapeSize / 2.0
   25|      0|        let shapeHoleSizeHalf = dataSet.scatterShapeHoleRadius
   26|      0|        let shapeHoleSize = shapeHoleSizeHalf * 2.0
   27|      0|        let shapeHoleColor = dataSet.scatterShapeHoleColor
   28|      0|        let shapeStrokeSize = (shapeSize - shapeHoleSize) / 2.0
   29|      0|        
   30|      0|        context.setFillColor(color.cgColor)
   31|      0|        
   32|      0|        // create a triangle path
   33|      0|        context.beginPath()
   34|      0|        context.move(to: CGPoint(x: point.x, y: point.y - shapeHalf))
   35|      0|        context.addLine(to: CGPoint(x: point.x + shapeHalf, y: point.y + shapeHalf))
   36|      0|        context.addLine(to: CGPoint(x: point.x - shapeHalf, y: point.y + shapeHalf))
   37|      0|        
   38|      0|        if shapeHoleSize > 0.0
   39|      0|        {
   40|      0|            context.addLine(to: CGPoint(x: point.x, y: point.y - shapeHalf))
   41|      0|            
   42|      0|            context.move(to: CGPoint(x: point.x - shapeHalf + shapeStrokeSize, y: point.y + shapeHalf - shapeStrokeSize))
   43|      0|            context.addLine(to: CGPoint(x: point.x + shapeHalf - shapeStrokeSize, y: point.y + shapeHalf - shapeStrokeSize))
   44|      0|            context.addLine(to: CGPoint(x: point.x, y: point.y - shapeHalf + shapeStrokeSize))
   45|      0|            context.addLine(to: CGPoint(x: point.x - shapeHalf + shapeStrokeSize, y: point.y + shapeHalf - shapeStrokeSize))
   46|      0|        }
   47|      0|        
   48|      0|        context.closePath()
   49|      0|        
   50|      0|        context.fillPath()
   51|      0|        
   52|      0|        if shapeHoleSize > 0.0 && shapeHoleColor != nil
   53|      0|        {
   54|      0|            context.setFillColor(shapeHoleColor!.cgColor)
   55|      0|            
   56|      0|            // create a triangle path
   57|      0|            context.beginPath()
   58|      0|            context.move(to: CGPoint(x: point.x, y: point.y - shapeHalf + shapeStrokeSize))
   59|      0|            context.addLine(to: CGPoint(x: point.x + shapeHalf - shapeStrokeSize, y: point.y + shapeHalf - shapeStrokeSize))
   60|      0|            context.addLine(to: CGPoint(x: point.x - shapeHalf + shapeStrokeSize, y: point.y + shapeHalf - shapeStrokeSize))
   61|      0|            context.closePath()
   62|      0|            
   63|      0|            context.fillPath()
   64|      0|        }
   65|      0|    }
   66|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/Scatter/XShapeRenderer.swift:
    1|       |//
    2|       |//  XShapeRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |import Foundation
   12|       |import CoreGraphics
   13|       |
   14|       |open class XShapeRenderer : NSObject, IShapeRenderer
   15|       |{
   16|       |    open func renderShape(
   17|       |        context: CGContext,
   18|       |        dataSet: IScatterChartDataSet,
   19|       |        viewPortHandler: ViewPortHandler,
   20|       |        point: CGPoint,
   21|       |        color: NSUIColor)
   22|      0|    {
   23|      0|        let shapeSize = dataSet.scatterShapeSize
   24|      0|        let shapeHalf = shapeSize / 2.0
   25|      0|        
   26|      0|        context.setLineWidth(1.0)
   27|      0|        context.setStrokeColor(color.cgColor)
   28|      0|        
   29|      0|        context.beginPath()
   30|      0|        context.move(to: CGPoint(x: point.x - shapeHalf, y: point.y - shapeHalf))
   31|      0|        context.addLine(to: CGPoint(x: point.x + shapeHalf, y: point.y + shapeHalf))
   32|      0|        context.move(to: CGPoint(x: point.x + shapeHalf, y: point.y - shapeHalf))
   33|      0|        context.addLine(to: CGPoint(x: point.x - shapeHalf, y: point.y + shapeHalf))
   34|      0|        context.strokePath()
   35|      0|    }
   36|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/ScatterChartRenderer.swift:
    1|       |//
    2|       |//  ScatterChartRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class ScatterChartRenderer: LineScatterCandleRadarRenderer
   16|       |{
   17|       |    @objc open weak var dataProvider: ScatterChartDataProvider?
   18|       |    
   19|       |    @objc public init(dataProvider: ScatterChartDataProvider, animator: Animator, viewPortHandler: ViewPortHandler)
   20|      0|    {
   21|      0|        super.init(animator: animator, viewPortHandler: viewPortHandler)
   22|      0|        
   23|      0|        self.dataProvider = dataProvider
   24|      0|    }
   25|       |
   26|       |    open override func drawData(context: CGContext)
   27|      0|    {
   28|      0|        guard let scatterData = dataProvider?.scatterData else { return }
   29|      0|
   30|      0|        // If we redraw the data, remove and repopulate accessible elements to update label values and frames
   31|      0|        accessibleChartElements.removeAll()
   32|      0|        
   33|      0|        if let chart = dataProvider as? ScatterChartView {
   34|      0|            // Make the chart header the first element in the accessible elements array
   35|      0|            let element = createAccessibleHeader(usingChart: chart,
   36|      0|                                                 andData: scatterData,
   37|      0|                                                 withDefaultDescription: "Scatter Chart")
   38|      0|            accessibleChartElements.append(element)
   39|      0|        }
   40|      0|
   41|      0|        // TODO: Due to the potential complexity of data presented in Scatter charts, a more usable way
   42|      0|        // for VO accessibility would be to use axis based traversal rather than by dataset.
   43|      0|        // Hence, accessibleChartElements is not populated below. (Individual renderers guard against dataSource being their respective views)
   44|      0|        for i in 0 ..< scatterData.dataSetCount
   45|      0|        {
   46|      0|            guard let set = scatterData.getDataSetByIndex(i) else { continue }
   47|      0|            
   48|      0|            if set.isVisible
   49|      0|            {
   50|      0|                if !(set is IScatterChartDataSet)
   51|      0|                {
   52|      0|                    fatalError("Datasets for ScatterChartRenderer must conform to IScatterChartDataSet")
   53|      0|                }
   54|      0|                
   55|      0|                drawDataSet(context: context, dataSet: set as! IScatterChartDataSet)
   56|      0|            }
   57|      0|        }
   58|      0|    }
   59|       |    
   60|      0|    private var _lineSegments = [CGPoint](repeating: CGPoint(), count: 2)
   61|       |    
   62|       |    @objc open func drawDataSet(context: CGContext, dataSet: IScatterChartDataSet)
   63|      0|    {
   64|      0|        guard let dataProvider = dataProvider else { return }
   65|      0|        
   66|      0|        let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
   67|      0|        
   68|      0|        let phaseY = animator.phaseY
   69|      0|        
   70|      0|        let entryCount = dataSet.entryCount
   71|      0|        
   72|      0|        var point = CGPoint()
   73|      0|        
   74|      0|        let valueToPixelMatrix = trans.valueToPixelMatrix
   75|      0|        
   76|      0|        if let renderer = dataSet.shapeRenderer
   77|      0|        {
   78|      0|            context.saveGState()
   79|      0|            
   80|      0|            for j in 0 ..< Int(min(ceil(Double(entryCount) * animator.phaseX), Double(entryCount)))
   81|      0|            {
   82|      0|                guard let e = dataSet.entryForIndex(j) else { continue }
   83|      0|                
   84|      0|                point.x = CGFloat(e.x)
   85|      0|                point.y = CGFloat(e.y * phaseY)
   86|      0|                point = point.applying(valueToPixelMatrix)
   87|      0|                
   88|      0|                if !viewPortHandler.isInBoundsRight(point.x)
   89|      0|                {
   90|      0|                    break
   91|      0|                }
   92|      0|                
   93|      0|                if !viewPortHandler.isInBoundsLeft(point.x) ||
   94|      0|                    !viewPortHandler.isInBoundsY(point.y)
   95|      0|                {
   96|      0|                    continue
   97|      0|                }
   98|      0|                
   99|      0|                renderer.renderShape(context: context, dataSet: dataSet, viewPortHandler: viewPortHandler, point: point, color: dataSet.color(atIndex: j))
  100|      0|            }
  101|      0|            
  102|      0|            context.restoreGState()
  103|      0|        }
  104|      0|        else
  105|      0|        {
  106|      0|            print("There's no IShapeRenderer specified for ScatterDataSet", terminator: "\n")
  107|      0|        }
  108|      0|    }
  109|       |    
  110|       |    open override func drawValues(context: CGContext)
  111|      0|    {
  112|      0|        guard
  113|      0|            let dataProvider = dataProvider,
  114|      0|            let scatterData = dataProvider.scatterData
  115|      0|            else { return }
  116|      0|        
  117|      0|        // if values are drawn
  118|      0|        if isDrawingValuesAllowed(dataProvider: dataProvider)
  119|      0|        {
  120|      0|            guard let dataSets = scatterData.dataSets as? [IScatterChartDataSet] else { return }
  121|      0|            
  122|      0|            let phaseY = animator.phaseY
  123|      0|            
  124|      0|            var pt = CGPoint()
  125|      0|            
  126|      0|            for i in 0 ..< scatterData.dataSetCount
  127|      0|            {
  128|      0|                let dataSet = dataSets[i]
  129|      0|                guard let
  130|      0|                    formatter = dataSet.valueFormatter,
  131|      0|                    shouldDrawValues(forDataSet: dataSet)
  132|      0|                    else { continue }
  133|      0|                
  134|      0|                let valueFont = dataSet.valueFont
  135|      0|                
  136|      0|                let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
  137|      0|                let valueToPixelMatrix = trans.valueToPixelMatrix
  138|      0|                
  139|      0|                let iconsOffset = dataSet.iconsOffset
  140|      0|                
  141|      0|                let shapeSize = dataSet.scatterShapeSize
  142|      0|                let lineHeight = valueFont.lineHeight
  143|      0|                
  144|      0|                _xBounds.set(chart: dataProvider, dataSet: dataSet, animator: animator)
  145|      0|                
  146|      0|                for j in _xBounds
  147|      0|                {
  148|      0|                    guard let e = dataSet.entryForIndex(j) else { break }
  149|      0|                    
  150|      0|                    pt.x = CGFloat(e.x)
  151|      0|                    pt.y = CGFloat(e.y * phaseY)
  152|      0|                    pt = pt.applying(valueToPixelMatrix)
  153|      0|                    
  154|      0|                    if (!viewPortHandler.isInBoundsRight(pt.x))
  155|      0|                    {
  156|      0|                        break
  157|      0|                    }
  158|      0|                    
  159|      0|                    // make sure the lines don't do shitty things outside bounds
  160|      0|                    if (!viewPortHandler.isInBoundsLeft(pt.x)
  161|      0|                        || !viewPortHandler.isInBoundsY(pt.y))
  162|      0|                    {
  163|      0|                        continue
  164|      0|                    }
  165|      0|                    
  166|      0|                    let text = formatter.stringForValue(
  167|      0|                        e.y,
  168|      0|                        entry: e,
  169|      0|                        dataSetIndex: i,
  170|      0|                        viewPortHandler: viewPortHandler)
  171|      0|                    
  172|      0|                    if dataSet.isDrawValuesEnabled
  173|      0|                    {
  174|      0|                        ChartUtils.drawText(
  175|      0|                            context: context,
  176|      0|                            text: text,
  177|      0|                            point: CGPoint(
  178|      0|                                x: pt.x,
  179|      0|                                y: pt.y - shapeSize - lineHeight),
  180|      0|                            align: .center,
  181|      0|                            attributes: [NSAttributedString.Key.font: valueFont, NSAttributedString.Key.foregroundColor: dataSet.valueTextColorAt(j)]
  182|      0|                        )
  183|      0|                    }
  184|      0|                    
  185|      0|                    if let icon = e.icon, dataSet.isDrawIconsEnabled
  186|      0|                    {
  187|      0|                        ChartUtils.drawImage(context: context,
  188|      0|                                             image: icon,
  189|      0|                                             x: pt.x + iconsOffset.x,
  190|      0|                                             y: pt.y + iconsOffset.y,
  191|      0|                                             size: icon.size)
  192|      0|                    }
  193|      0|                }
  194|      0|            }
  195|      0|        }
  196|      0|    }
  197|       |    
  198|       |    open override func drawExtras(context: CGContext)
  199|      0|    {
  200|      0|        
  201|      0|    }
  202|       |    
  203|       |    open override func drawHighlighted(context: CGContext, indices: [Highlight])
  204|      0|    {
  205|      0|        guard
  206|      0|            let dataProvider = dataProvider,
  207|      0|            let scatterData = dataProvider.scatterData
  208|      0|            else { return }
  209|      0|        
  210|      0|        context.saveGState()
  211|      0|        
  212|      0|        for high in indices
  213|      0|        {
  214|      0|            guard
  215|      0|                let set = scatterData.getDataSetByIndex(high.dataSetIndex) as? IScatterChartDataSet,
  216|      0|                set.isHighlightEnabled
  217|      0|                else { continue }
  218|      0|            
  219|      0|            guard let entry = set.entryForXValue(high.x, closestToY: high.y) else { continue }
  220|      0|            
  221|      0|            if !isInBoundsX(entry: entry, dataSet: set) { continue }
  222|      0|            
  223|      0|            context.setStrokeColor(set.highlightColor.cgColor)
  224|      0|            context.setLineWidth(set.highlightLineWidth)
  225|      0|            if set.highlightLineDashLengths != nil
  226|      0|            {
  227|      0|                context.setLineDash(phase: set.highlightLineDashPhase, lengths: set.highlightLineDashLengths!)
  228|      0|            }
  229|      0|            else
  230|      0|            {
  231|      0|                context.setLineDash(phase: 0.0, lengths: [])
  232|      0|            }
  233|      0|            
  234|      0|            let x = entry.x // get the x-position
  235|      0|            let y = entry.y * Double(animator.phaseY)
  236|      0|            
  237|      0|            let trans = dataProvider.getTransformer(forAxis: set.axisDependency)
  238|      0|            
  239|      0|            let pt = trans.pixelForValues(x: x, y: y)
  240|      0|            
  241|      0|            high.setDraw(pt: pt)
  242|      0|            
  243|      0|            // draw the lines
  244|      0|            drawHighlightLines(context: context, point: pt, set: set)
  245|      0|        }
  246|      0|        
  247|      0|        context.restoreGState()
  248|      0|    }
  249|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/XAxisRenderer.swift:
    1|       |//
    2|       |//  XAxisRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |@objc(ChartXAxisRenderer)
   24|       |open class XAxisRenderer: AxisRendererBase
   25|       |{
   26|       |    @objc public init(viewPortHandler: ViewPortHandler, xAxis: XAxis?, transformer: Transformer?)
   27|      0|    {
   28|      0|        super.init(viewPortHandler: viewPortHandler, transformer: transformer, axis: xAxis)
   29|      0|    }
   30|       |    
   31|       |    open override func computeAxis(min: Double, max: Double, inverted: Bool)
   32|      0|    {
   33|      0|        var min = min, max = max
   34|      0|        
   35|      0|        if let transformer = self.transformer
   36|      0|        {
   37|      0|            // calculate the starting and entry point of the y-labels (depending on
   38|      0|            // zoom / contentrect bounds)
   39|      0|            if viewPortHandler.contentWidth > 10 && !viewPortHandler.isFullyZoomedOutX
   40|      0|            {
   41|      0|                let p1 = transformer.valueForTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
   42|      0|                let p2 = transformer.valueForTouchPoint(CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentTop))
   43|      0|                
   44|      0|                if inverted
   45|      0|                {
   46|      0|                    min = Double(p2.x)
   47|      0|                    max = Double(p1.x)
   48|      0|                }
   49|      0|                else
   50|      0|                {
   51|      0|                    min = Double(p1.x)
   52|      0|                    max = Double(p2.x)
   53|      0|                }
   54|      0|            }
   55|      0|        }
   56|      0|        
   57|      0|        computeAxisValues(min: min, max: max)
   58|      0|    }
   59|       |    
   60|       |    open override func computeAxisValues(min: Double, max: Double)
   61|      0|    {
   62|      0|        super.computeAxisValues(min: min, max: max)
   63|      0|        
   64|      0|        computeSize()
   65|      0|    }
   66|       |    
   67|       |    @objc open func computeSize()
   68|      0|    {
   69|      0|        guard let
   70|      0|            xAxis = self.axis as? XAxis
   71|      0|            else { return }
   72|      0|        
   73|      0|        let longest = xAxis.getLongestLabel()
   74|      0|        
   75|      0|        let labelSize = longest.size(withAttributes: [NSAttributedString.Key.font: xAxis.labelFont])
   76|      0|        
   77|      0|        let labelWidth = labelSize.width
   78|      0|        let labelHeight = labelSize.height
   79|      0|        
   80|      0|        let labelRotatedSize = labelSize.rotatedBy(degrees: xAxis.labelRotationAngle)
   81|      0|        
   82|      0|        xAxis.labelWidth = labelWidth
   83|      0|        xAxis.labelHeight = labelHeight
   84|      0|        xAxis.labelRotatedWidth = labelRotatedSize.width
   85|      0|        xAxis.labelRotatedHeight = labelRotatedSize.height
   86|      0|    }
   87|       |    
   88|       |    open override func renderAxisLabels(context: CGContext)
   89|      0|    {
   90|      0|        guard let xAxis = self.axis as? XAxis else { return }
   91|      0|        
   92|      0|        if !xAxis.isEnabled || !xAxis.isDrawLabelsEnabled
   93|      0|        {
   94|      0|            return
   95|      0|        }
   96|      0|        
   97|      0|        let yOffset = xAxis.yOffset
   98|      0|        
   99|      0|        if xAxis.labelPosition == .top
  100|      0|        {
  101|      0|            drawLabels(context: context, pos: viewPortHandler.contentTop - yOffset, anchor: CGPoint(x: 0.5, y: 1.0))
  102|      0|        }
  103|      0|        else if xAxis.labelPosition == .topInside
  104|      0|        {
  105|      0|            drawLabels(context: context, pos: viewPortHandler.contentTop + yOffset + xAxis.labelRotatedHeight, anchor: CGPoint(x: 0.5, y: 1.0))
  106|      0|        }
  107|      0|        else if xAxis.labelPosition == .bottom
  108|      0|        {
  109|      0|            drawLabels(context: context, pos: viewPortHandler.contentBottom + yOffset, anchor: CGPoint(x: 0.5, y: 0.0))
  110|      0|        }
  111|      0|        else if xAxis.labelPosition == .bottomInside
  112|      0|        {
  113|      0|            drawLabels(context: context, pos: viewPortHandler.contentBottom - yOffset - xAxis.labelRotatedHeight, anchor: CGPoint(x: 0.5, y: 0.0))
  114|      0|        }
  115|      0|        else
  116|      0|        { // BOTH SIDED
  117|      0|            drawLabels(context: context, pos: viewPortHandler.contentTop - yOffset, anchor: CGPoint(x: 0.5, y: 1.0))
  118|      0|            drawLabels(context: context, pos: viewPortHandler.contentBottom + yOffset, anchor: CGPoint(x: 0.5, y: 0.0))
  119|      0|        }
  120|      0|    }
  121|       |    
  122|      0|    private var _axisLineSegmentsBuffer = [CGPoint](repeating: CGPoint(), count: 2)
  123|       |    
  124|       |    open override func renderAxisLine(context: CGContext)
  125|      0|    {
  126|      0|        guard let xAxis = self.axis as? XAxis else { return }
  127|      0|        
  128|      0|        if !xAxis.isEnabled || !xAxis.isDrawAxisLineEnabled
  129|      0|        {
  130|      0|            return
  131|      0|        }
  132|      0|        
  133|      0|        context.saveGState()
  134|      0|        
  135|      0|        context.setStrokeColor(xAxis.axisLineColor.cgColor)
  136|      0|        context.setLineWidth(xAxis.axisLineWidth)
  137|      0|        if xAxis.axisLineDashLengths != nil
  138|      0|        {
  139|      0|            context.setLineDash(phase: xAxis.axisLineDashPhase, lengths: xAxis.axisLineDashLengths)
  140|      0|        }
  141|      0|        else
  142|      0|        {
  143|      0|            context.setLineDash(phase: 0.0, lengths: [])
  144|      0|        }
  145|      0|        
  146|      0|        if xAxis.labelPosition == .top
  147|      0|            || xAxis.labelPosition == .topInside
  148|      0|            || xAxis.labelPosition == .bothSided
  149|      0|        {
  150|      0|            _axisLineSegmentsBuffer[0].x = viewPortHandler.contentLeft
  151|      0|            _axisLineSegmentsBuffer[0].y = viewPortHandler.contentTop
  152|      0|            _axisLineSegmentsBuffer[1].x = viewPortHandler.contentRight
  153|      0|            _axisLineSegmentsBuffer[1].y = viewPortHandler.contentTop
  154|      0|            context.strokeLineSegments(between: _axisLineSegmentsBuffer)
  155|      0|        }
  156|      0|        
  157|      0|        if xAxis.labelPosition == .bottom
  158|      0|            || xAxis.labelPosition == .bottomInside
  159|      0|            || xAxis.labelPosition == .bothSided
  160|      0|        {
  161|      0|            _axisLineSegmentsBuffer[0].x = viewPortHandler.contentLeft
  162|      0|            _axisLineSegmentsBuffer[0].y = viewPortHandler.contentBottom
  163|      0|            _axisLineSegmentsBuffer[1].x = viewPortHandler.contentRight
  164|      0|            _axisLineSegmentsBuffer[1].y = viewPortHandler.contentBottom
  165|      0|            context.strokeLineSegments(between: _axisLineSegmentsBuffer)
  166|      0|        }
  167|      0|        
  168|      0|        context.restoreGState()
  169|      0|    }
  170|       |    
  171|       |    /// draws the x-labels on the specified y-position
  172|       |    @objc open func drawLabels(context: CGContext, pos: CGFloat, anchor: CGPoint)
  173|      0|    {
  174|      0|        guard
  175|      0|            let xAxis = self.axis as? XAxis,
  176|      0|            let transformer = self.transformer
  177|      0|            else { return }
  178|      0|        
  179|      0|        let paraStyle = NSParagraphStyle.default.mutableCopy() as! NSMutableParagraphStyle
  180|      0|        paraStyle.alignment = .center
  181|      0|        
  182|      0|        let labelAttrs: [NSAttributedString.Key : Any] = [
  183|      0|            .font: xAxis.labelFont,
  184|      0|            .foregroundColor: xAxis.labelTextColor,
  185|      0|            .paragraphStyle: paraStyle
  186|      0|        ]
  187|      0|        let labelRotationAngleRadians = xAxis.labelRotationAngle.DEG2RAD
  188|      0|        
  189|      0|        let centeringEnabled = xAxis.isCenterAxisLabelsEnabled
  190|      0|
  191|      0|        let valueToPixelMatrix = transformer.valueToPixelMatrix
  192|      0|        
  193|      0|        var position = CGPoint(x: 0.0, y: 0.0)
  194|      0|        
  195|      0|        var labelMaxSize = CGSize()
  196|      0|        
  197|      0|        if xAxis.isWordWrapEnabled
  198|      0|        {
  199|      0|            labelMaxSize.width = xAxis.wordWrapWidthPercent * valueToPixelMatrix.a
  200|      0|        }
  201|      0|        
  202|      0|        let entries = xAxis.entries
  203|      0|        
  204|      0|        for i in stride(from: 0, to: entries.count, by: 1)
  205|      0|        {
  206|      0|            if centeringEnabled
  207|      0|            {
  208|      0|                position.x = CGFloat(xAxis.centeredEntries[i])
  209|      0|            }
  210|      0|            else
  211|      0|            {
  212|      0|                position.x = CGFloat(entries[i])
  213|      0|            }
  214|      0|            
  215|      0|            position.y = 0.0
  216|      0|            position = position.applying(valueToPixelMatrix)
  217|      0|            
  218|      0|            if viewPortHandler.isInBoundsX(position.x)
  219|      0|            {
  220|      0|                let label = xAxis.valueFormatter?.stringForValue(xAxis.entries[i], axis: xAxis) ?? ""
  221|      0|
  222|      0|                let labelns = label as NSString
  223|      0|                
  224|      0|                if xAxis.isAvoidFirstLastClippingEnabled
  225|      0|                {
  226|      0|                    // avoid clipping of the last
  227|      0|                    if i == xAxis.entryCount - 1 && xAxis.entryCount > 1
  228|      0|                    {
  229|      0|                        let width = labelns.boundingRect(with: labelMaxSize, options: .usesLineFragmentOrigin, attributes: labelAttrs, context: nil).size.width
  230|      0|                        
  231|      0|                        if width > viewPortHandler.offsetRight * 2.0
  232|      0|                            && position.x + width > viewPortHandler.chartWidth
  233|      0|                        {
  234|      0|                            position.x -= width / 2.0
  235|      0|                        }
  236|      0|                    }
  237|      0|                    else if i == 0
  238|      0|                    { // avoid clipping of the first
  239|      0|                        let width = labelns.boundingRect(with: labelMaxSize, options: .usesLineFragmentOrigin, attributes: labelAttrs, context: nil).size.width
  240|      0|                        position.x += width / 2.0
  241|      0|                    }
  242|      0|                }
  243|      0|                
  244|      0|                drawLabel(context: context,
  245|      0|                          formattedLabel: label,
  246|      0|                          x: position.x,
  247|      0|                          y: pos,
  248|      0|                          attributes: labelAttrs,
  249|      0|                          constrainedToSize: labelMaxSize,
  250|      0|                          anchor: anchor,
  251|      0|                          angleRadians: labelRotationAngleRadians)
  252|      0|            }
  253|      0|        }
  254|      0|    }
  255|       |    
  256|       |    @objc open func drawLabel(
  257|       |        context: CGContext,
  258|       |        formattedLabel: String,
  259|       |        x: CGFloat,
  260|       |        y: CGFloat,
  261|       |        attributes: [NSAttributedString.Key : Any],
  262|       |        constrainedToSize: CGSize,
  263|       |        anchor: CGPoint,
  264|       |        angleRadians: CGFloat)
  265|      0|    {
  266|      0|        ChartUtils.drawMultilineText(
  267|      0|            context: context,
  268|      0|            text: formattedLabel,
  269|      0|            point: CGPoint(x: x, y: y),
  270|      0|            attributes: attributes,
  271|      0|            constrainedToSize: constrainedToSize,
  272|      0|            anchor: anchor,
  273|      0|            angleRadians: angleRadians)
  274|      0|    }
  275|       |    
  276|       |    open override func renderGridLines(context: CGContext)
  277|      0|    {
  278|      0|        guard
  279|      0|            let xAxis = self.axis as? XAxis,
  280|      0|            let transformer = self.transformer
  281|      0|            else { return }
  282|      0|        
  283|      0|        if !xAxis.isDrawGridLinesEnabled || !xAxis.isEnabled
  284|      0|        {
  285|      0|            return
  286|      0|        }
  287|      0|        
  288|      0|        context.saveGState()
  289|      0|        defer { context.restoreGState() }
  290|      0|        context.clip(to: self.gridClippingRect)
  291|      0|        
  292|      0|        context.setShouldAntialias(xAxis.gridAntialiasEnabled)
  293|      0|        context.setStrokeColor(xAxis.gridColor.cgColor)
  294|      0|        context.setLineWidth(xAxis.gridLineWidth)
  295|      0|        context.setLineCap(xAxis.gridLineCap)
  296|      0|        
  297|      0|        if xAxis.gridLineDashLengths != nil
  298|      0|        {
  299|      0|            context.setLineDash(phase: xAxis.gridLineDashPhase, lengths: xAxis.gridLineDashLengths)
  300|      0|        }
  301|      0|        else
  302|      0|        {
  303|      0|            context.setLineDash(phase: 0.0, lengths: [])
  304|      0|        }
  305|      0|        
  306|      0|        let valueToPixelMatrix = transformer.valueToPixelMatrix
  307|      0|        
  308|      0|        var position = CGPoint(x: 0.0, y: 0.0)
  309|      0|        
  310|      0|        let entries = xAxis.entries
  311|      0|        
  312|      0|        for i in stride(from: 0, to: entries.count, by: 1)
  313|      0|        {
  314|      0|            position.x = CGFloat(entries[i])
  315|      0|            position.y = position.x
  316|      0|            position = position.applying(valueToPixelMatrix)
  317|      0|            
  318|      0|            drawGridLine(context: context, x: position.x, y: position.y)
  319|      0|        }
  320|      0|    }
  321|       |    
  322|       |    @objc open var gridClippingRect: CGRect
  323|      0|    {
  324|      0|        var contentRect = viewPortHandler.contentRect
  325|      0|        let dx = self.axis?.gridLineWidth ?? 0.0
  326|      0|        contentRect.origin.x -= dx / 2.0
  327|      0|        contentRect.size.width += dx
  328|      0|        return contentRect
  329|      0|    }
  330|       |    
  331|       |    @objc open func drawGridLine(context: CGContext, x: CGFloat, y: CGFloat)
  332|      0|    {
  333|      0|        if x >= viewPortHandler.offsetLeft
  334|      0|            && x <= viewPortHandler.chartWidth
  335|      0|        {
  336|      0|            context.beginPath()
  337|      0|            context.move(to: CGPoint(x: x, y: viewPortHandler.contentTop))
  338|      0|            context.addLine(to: CGPoint(x: x, y: viewPortHandler.contentBottom))
  339|      0|            context.strokePath()
  340|      0|        }
  341|      0|    }
  342|       |    
  343|       |    open override func renderLimitLines(context: CGContext)
  344|      0|    {
  345|      0|        guard
  346|      0|            let xAxis = self.axis as? XAxis,
  347|      0|            let transformer = self.transformer,
  348|      0|            !xAxis.limitLines.isEmpty
  349|      0|            else { return }
  350|      0|        
  351|      0|        let trans = transformer.valueToPixelMatrix
  352|      0|        
  353|      0|        var position = CGPoint(x: 0.0, y: 0.0)
  354|      0|        
  355|      0|        for l in xAxis.limitLines where l.isEnabled
  356|      0|        {
  357|      0|            context.saveGState()
  358|      0|            defer { context.restoreGState() }
  359|      0|            
  360|      0|            var clippingRect = viewPortHandler.contentRect
  361|      0|            clippingRect.origin.x -= l.lineWidth / 2.0
  362|      0|            clippingRect.size.width += l.lineWidth
  363|      0|            context.clip(to: clippingRect)
  364|      0|            
  365|      0|            position.x = CGFloat(l.limit)
  366|      0|            position.y = 0.0
  367|      0|            position = position.applying(trans)
  368|      0|            
  369|      0|            renderLimitLineLine(context: context, limitLine: l, position: position)
  370|      0|            renderLimitLineLabel(context: context, limitLine: l, position: position, yOffset: 2.0 + l.yOffset)
  371|      0|        }
  372|      0|    }
  373|       |    
  374|       |    @objc open func renderLimitLineLine(context: CGContext, limitLine: ChartLimitLine, position: CGPoint)
  375|      0|    {
  376|      0|        
  377|      0|        context.beginPath()
  378|      0|        context.move(to: CGPoint(x: position.x, y: viewPortHandler.contentTop))
  379|      0|        context.addLine(to: CGPoint(x: position.x, y: viewPortHandler.contentBottom))
  380|      0|        
  381|      0|        context.setStrokeColor(limitLine.lineColor.cgColor)
  382|      0|        context.setLineWidth(limitLine.lineWidth)
  383|      0|        if limitLine.lineDashLengths != nil
  384|      0|        {
  385|      0|            context.setLineDash(phase: limitLine.lineDashPhase, lengths: limitLine.lineDashLengths!)
  386|      0|        }
  387|      0|        else
  388|      0|        {
  389|      0|            context.setLineDash(phase: 0.0, lengths: [])
  390|      0|        }
  391|      0|        
  392|      0|        context.strokePath()
  393|      0|    }
  394|       |    
  395|       |    @objc open func renderLimitLineLabel(context: CGContext, limitLine: ChartLimitLine, position: CGPoint, yOffset: CGFloat)
  396|      0|    {
  397|      0|        
  398|      0|        let label = limitLine.label
  399|      0|        guard limitLine.drawLabelEnabled, !label.isEmpty else { return }
  400|      0|
  401|      0|        let labelLineHeight = limitLine.valueFont.lineHeight
  402|      0|
  403|      0|        let xOffset: CGFloat = limitLine.lineWidth + limitLine.xOffset
  404|      0|        let attributes: [NSAttributedString.Key : Any] = [
  405|      0|            .font : limitLine.valueFont,
  406|      0|            .foregroundColor : limitLine.valueTextColor
  407|      0|        ]
  408|      0|
  409|      0|        let (point, align): (CGPoint, NSTextAlignment)
  410|      0|        switch limitLine.labelPosition {
  411|      0|        case .topRight:
  412|      0|            point = CGPoint(
  413|      0|                x: position.x + xOffset,
  414|      0|                y: viewPortHandler.contentTop + yOffset
  415|      0|            )
  416|      0|            align = .left
  417|      0|
  418|      0|        case .bottomRight:
  419|      0|            point = CGPoint(
  420|      0|                x: position.x + xOffset,
  421|      0|                y: viewPortHandler.contentBottom - labelLineHeight - yOffset
  422|      0|            )
  423|      0|            align = .left
  424|      0|
  425|      0|        case .topLeft:
  426|      0|            point = CGPoint(
  427|      0|                x: position.x - xOffset,
  428|      0|                y: viewPortHandler.contentTop + yOffset
  429|      0|            )
  430|      0|            align = .right
  431|      0|
  432|      0|        case .bottomLeft:
  433|      0|            point = CGPoint(
  434|      0|                x: position.x - xOffset,
  435|      0|                y: viewPortHandler.contentBottom - labelLineHeight - yOffset
  436|      0|            )
  437|      0|            align = .right
  438|      0|        }
  439|      0|
  440|      0|        ChartUtils.drawText(
  441|      0|            context: context,
  442|      0|            text: label,
  443|      0|            point: point,
  444|      0|            align: align,
  445|      0|            attributes: attributes
  446|      0|        )
  447|      0|    }
  448|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/XAxisRendererHorizontalBarChart.swift:
    1|       |//
    2|       |//  XAxisRendererHorizontalBarChart.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class XAxisRendererHorizontalBarChart: XAxisRenderer
   16|       |{
   17|       |    internal weak var chart: BarChartView?
   18|       |    
   19|       |    @objc public init(viewPortHandler: ViewPortHandler, xAxis: XAxis?, transformer: Transformer?, chart: BarChartView)
   20|      0|    {
   21|      0|        super.init(viewPortHandler: viewPortHandler, xAxis: xAxis, transformer: transformer)
   22|      0|        
   23|      0|        self.chart = chart
   24|      0|    }
   25|       |    
   26|       |    open override func computeAxis(min: Double, max: Double, inverted: Bool)
   27|      0|    {
   28|      0|        var min = min, max = max
   29|      0|        
   30|      0|        if let transformer = self.transformer
   31|      0|        {
   32|      0|            // calculate the starting and entry point of the y-labels (depending on
   33|      0|            // zoom / contentrect bounds)
   34|      0|            if viewPortHandler.contentWidth > 10 && !viewPortHandler.isFullyZoomedOutY
   35|      0|            {
   36|      0|                let p1 = transformer.valueForTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentBottom))
   37|      0|                let p2 = transformer.valueForTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
   38|      0|                
   39|      0|                if inverted
   40|      0|                {
   41|      0|                    min = Double(p2.y)
   42|      0|                    max = Double(p1.y)
   43|      0|                }
   44|      0|                else
   45|      0|                {
   46|      0|                    min = Double(p1.y)
   47|      0|                    max = Double(p2.y)
   48|      0|                }
   49|      0|            }
   50|      0|        }
   51|      0|        
   52|      0|        computeAxisValues(min: min, max: max)
   53|      0|    }
   54|       |    
   55|       |    open override func computeSize()
   56|      0|    {
   57|      0|        guard let
   58|      0|            xAxis = self.axis as? XAxis
   59|      0|            else { return }
   60|      0|       
   61|      0|        let longest = xAxis.getLongestLabel() as NSString
   62|      0|        
   63|      0|        let labelSize = longest.size(withAttributes: [NSAttributedString.Key.font: xAxis.labelFont])
   64|      0|        
   65|      0|        let labelWidth = floor(labelSize.width + xAxis.xOffset * 3.5)
   66|      0|        let labelHeight = labelSize.height
   67|      0|        let labelRotatedSize = CGSize(width: labelSize.width, height: labelHeight).rotatedBy(degrees: xAxis.labelRotationAngle)
   68|      0|
   69|      0|        xAxis.labelWidth = labelWidth
   70|      0|        xAxis.labelHeight = labelHeight
   71|      0|        xAxis.labelRotatedWidth = round(labelRotatedSize.width + xAxis.xOffset * 3.5)
   72|      0|        xAxis.labelRotatedHeight = round(labelRotatedSize.height)
   73|      0|    }
   74|       |
   75|       |    open override func renderAxisLabels(context: CGContext)
   76|      0|    {
   77|      0|        guard
   78|      0|            let xAxis = self.axis as? XAxis
   79|      0|            else { return }
   80|      0|        
   81|      0|        if !xAxis.isEnabled || !xAxis.isDrawLabelsEnabled || chart?.data === nil
   82|      0|        {
   83|      0|            return
   84|      0|        }
   85|      0|        
   86|      0|        let xoffset = xAxis.xOffset
   87|      0|        
   88|      0|        if xAxis.labelPosition == .top
   89|      0|        {
   90|      0|            drawLabels(context: context, pos: viewPortHandler.contentRight + xoffset, anchor: CGPoint(x: 0.0, y: 0.5))
   91|      0|        }
   92|      0|        else if xAxis.labelPosition == .topInside
   93|      0|        {
   94|      0|            drawLabels(context: context, pos: viewPortHandler.contentRight - xoffset, anchor: CGPoint(x: 1.0, y: 0.5))
   95|      0|        }
   96|      0|        else if xAxis.labelPosition == .bottom
   97|      0|        {
   98|      0|            drawLabels(context: context, pos: viewPortHandler.contentLeft - xoffset, anchor: CGPoint(x: 1.0, y: 0.5))
   99|      0|        }
  100|      0|        else if xAxis.labelPosition == .bottomInside
  101|      0|        {
  102|      0|            drawLabels(context: context, pos: viewPortHandler.contentLeft + xoffset, anchor: CGPoint(x: 0.0, y: 0.5))
  103|      0|        }
  104|      0|        else
  105|      0|        { // BOTH SIDED
  106|      0|            drawLabels(context: context, pos: viewPortHandler.contentRight + xoffset, anchor: CGPoint(x: 0.0, y: 0.5))
  107|      0|            drawLabels(context: context, pos: viewPortHandler.contentLeft - xoffset, anchor: CGPoint(x: 1.0, y: 0.5))
  108|      0|        }
  109|      0|    }
  110|       |
  111|       |    /// draws the x-labels on the specified y-position
  112|       |    open override func drawLabels(context: CGContext, pos: CGFloat, anchor: CGPoint)
  113|      0|    {
  114|      0|        guard
  115|      0|            let xAxis = self.axis as? XAxis,
  116|      0|            let transformer = self.transformer
  117|      0|            else { return }
  118|      0|        
  119|      0|        let labelFont = xAxis.labelFont
  120|      0|        let labelTextColor = xAxis.labelTextColor
  121|      0|        let labelRotationAngleRadians = xAxis.labelRotationAngle.DEG2RAD
  122|      0|        
  123|      0|        let centeringEnabled = xAxis.isCenterAxisLabelsEnabled
  124|      0|        
  125|      0|        // pre allocate to save performance (dont allocate in loop)
  126|      0|        var position = CGPoint(x: 0.0, y: 0.0)
  127|      0|        
  128|      0|        for i in stride(from: 0, to: xAxis.entryCount, by: 1)
  129|      0|        {
  130|      0|            // only fill x values
  131|      0|            
  132|      0|            position.x = 0.0
  133|      0|            
  134|      0|            if centeringEnabled
  135|      0|            {
  136|      0|                position.y = CGFloat(xAxis.centeredEntries[i])
  137|      0|            }
  138|      0|            else
  139|      0|            {
  140|      0|                position.y = CGFloat(xAxis.entries[i])
  141|      0|            }
  142|      0|            
  143|      0|            transformer.pointValueToPixel(&position)
  144|      0|            
  145|      0|            if viewPortHandler.isInBoundsY(position.y)
  146|      0|            {
  147|      0|                if let label = xAxis.valueFormatter?.stringForValue(xAxis.entries[i], axis: xAxis)
  148|      0|                {
  149|      0|                    drawLabel(
  150|      0|                        context: context,
  151|      0|                        formattedLabel: label,
  152|      0|                        x: pos,
  153|      0|                        y: position.y,
  154|      0|                        attributes: [NSAttributedString.Key.font: labelFont, NSAttributedString.Key.foregroundColor: labelTextColor],
  155|      0|                        anchor: anchor,
  156|      0|                        angleRadians: labelRotationAngleRadians)
  157|      0|                }
  158|      0|            }
  159|      0|        }
  160|      0|    }
  161|       |    
  162|       |    @objc open func drawLabel(
  163|       |        context: CGContext,
  164|       |        formattedLabel: String,
  165|       |        x: CGFloat,
  166|       |        y: CGFloat,
  167|       |        attributes: [NSAttributedString.Key : Any],
  168|       |        anchor: CGPoint,
  169|       |        angleRadians: CGFloat)
  170|      0|    {
  171|      0|        ChartUtils.drawText(
  172|      0|            context: context,
  173|      0|            text: formattedLabel,
  174|      0|            point: CGPoint(x: x, y: y),
  175|      0|            attributes: attributes,
  176|      0|            anchor: anchor,
  177|      0|            angleRadians: angleRadians)
  178|      0|    }
  179|       |    
  180|       |    open override var gridClippingRect: CGRect
  181|      0|    {
  182|      0|        var contentRect = viewPortHandler.contentRect
  183|      0|        let dy = self.axis?.gridLineWidth ?? 0.0
  184|      0|        contentRect.origin.y -= dy / 2.0
  185|      0|        contentRect.size.height += dy
  186|      0|        return contentRect
  187|      0|    }
  188|       |    
  189|      0|    private var _gridLineSegmentsBuffer = [CGPoint](repeating: CGPoint(), count: 2)
  190|       |    
  191|       |    open override func drawGridLine(context: CGContext, x: CGFloat, y: CGFloat)
  192|      0|    {
  193|      0|        if viewPortHandler.isInBoundsY(y)
  194|      0|        {
  195|      0|            context.beginPath()
  196|      0|            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: y))
  197|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: y))
  198|      0|            context.strokePath()
  199|      0|        }
  200|      0|    }
  201|       |    
  202|       |    open override func renderAxisLine(context: CGContext)
  203|      0|    {
  204|      0|        guard let xAxis = self.axis as? XAxis else { return }
  205|      0|        
  206|      0|        if !xAxis.isEnabled || !xAxis.isDrawAxisLineEnabled
  207|      0|        {
  208|      0|            return
  209|      0|        }
  210|      0|        
  211|      0|        context.saveGState()
  212|      0|        
  213|      0|        context.setStrokeColor(xAxis.axisLineColor.cgColor)
  214|      0|        context.setLineWidth(xAxis.axisLineWidth)
  215|      0|        if xAxis.axisLineDashLengths != nil
  216|      0|        {
  217|      0|            context.setLineDash(phase: xAxis.axisLineDashPhase, lengths: xAxis.axisLineDashLengths)
  218|      0|        }
  219|      0|        else
  220|      0|        {
  221|      0|            context.setLineDash(phase: 0.0, lengths: [])
  222|      0|        }
  223|      0|        
  224|      0|        if xAxis.labelPosition == .top ||
  225|      0|            xAxis.labelPosition == .topInside ||
  226|      0|            xAxis.labelPosition == .bothSided
  227|      0|        {
  228|      0|            context.beginPath()
  229|      0|            context.move(to: CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentTop))
  230|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentBottom))
  231|      0|            context.strokePath()
  232|      0|        }
  233|      0|        
  234|      0|        if xAxis.labelPosition == .bottom ||
  235|      0|            xAxis.labelPosition == .bottomInside ||
  236|      0|            xAxis.labelPosition == .bothSided
  237|      0|        {
  238|      0|            context.beginPath()
  239|      0|            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
  240|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentBottom))
  241|      0|            context.strokePath()
  242|      0|        }
  243|      0|        
  244|      0|        context.restoreGState()
  245|      0|    }
  246|       |    
  247|       |    open override func renderLimitLines(context: CGContext)
  248|      0|    {
  249|      0|        guard
  250|      0|            let xAxis = self.axis as? XAxis,
  251|      0|            let transformer = self.transformer
  252|      0|            else { return }
  253|      0|        
  254|      0|        let limitLines = xAxis.limitLines
  255|      0|        
  256|      0|        if limitLines.count == 0
  257|      0|        {
  258|      0|            return
  259|      0|        }
  260|      0|        
  261|      0|        let trans = transformer.valueToPixelMatrix
  262|      0|        
  263|      0|        var position = CGPoint(x: 0.0, y: 0.0)
  264|      0|        
  265|      0|        for i in 0 ..< limitLines.count
  266|      0|        {
  267|      0|            let l = limitLines[i]
  268|      0|            
  269|      0|            if !l.isEnabled
  270|      0|            {
  271|      0|                continue
  272|      0|            }
  273|      0|            
  274|      0|            context.saveGState()
  275|      0|            defer { context.restoreGState() }
  276|      0|            
  277|      0|            var clippingRect = viewPortHandler.contentRect
  278|      0|            clippingRect.origin.y -= l.lineWidth / 2.0
  279|      0|            clippingRect.size.height += l.lineWidth
  280|      0|            context.clip(to: clippingRect)
  281|      0|
  282|      0|            position.x = 0.0
  283|      0|            position.y = CGFloat(l.limit)
  284|      0|            position = position.applying(trans)
  285|      0|            
  286|      0|            context.beginPath()
  287|      0|            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: position.y))
  288|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: position.y))
  289|      0|            
  290|      0|            context.setStrokeColor(l.lineColor.cgColor)
  291|      0|            context.setLineWidth(l.lineWidth)
  292|      0|            if l.lineDashLengths != nil
  293|      0|            {
  294|      0|                context.setLineDash(phase: l.lineDashPhase, lengths: l.lineDashLengths!)
  295|      0|            }
  296|      0|            else
  297|      0|            {
  298|      0|                context.setLineDash(phase: 0.0, lengths: [])
  299|      0|            }
  300|      0|            
  301|      0|            context.strokePath()
  302|      0|            
  303|      0|            let label = l.label
  304|      0|            
  305|      0|            // if drawing the limit-value label is enabled
  306|      0|            if l.drawLabelEnabled && label.count > 0
  307|      0|            {
  308|      0|                let labelLineHeight = l.valueFont.lineHeight
  309|      0|                
  310|      0|                let xOffset: CGFloat = 4.0 + l.xOffset
  311|      0|                let yOffset: CGFloat = l.lineWidth + labelLineHeight + l.yOffset
  312|      0|                
  313|      0|                if l.labelPosition == .topRight
  314|      0|                {
  315|      0|                    ChartUtils.drawText(context: context,
  316|      0|                        text: label,
  317|      0|                        point: CGPoint(
  318|      0|                            x: viewPortHandler.contentRight - xOffset,
  319|      0|                            y: position.y - yOffset),
  320|      0|                        align: .right,
  321|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  322|      0|                }
  323|      0|                else if l.labelPosition == .bottomRight
  324|      0|                {
  325|      0|                    ChartUtils.drawText(context: context,
  326|      0|                        text: label,
  327|      0|                        point: CGPoint(
  328|      0|                            x: viewPortHandler.contentRight - xOffset,
  329|      0|                            y: position.y + yOffset - labelLineHeight),
  330|      0|                        align: .right,
  331|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  332|      0|                }
  333|      0|                else if l.labelPosition == .topLeft
  334|      0|                {
  335|      0|                    ChartUtils.drawText(context: context,
  336|      0|                        text: label,
  337|      0|                        point: CGPoint(
  338|      0|                            x: viewPortHandler.contentLeft + xOffset,
  339|      0|                            y: position.y - yOffset),
  340|      0|                        align: .left,
  341|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  342|      0|                }
  343|      0|                else
  344|      0|                {
  345|      0|                    ChartUtils.drawText(context: context,
  346|      0|                        text: label,
  347|      0|                        point: CGPoint(
  348|      0|                            x: viewPortHandler.contentLeft + xOffset,
  349|      0|                            y: position.y + yOffset - labelLineHeight),
  350|      0|                        align: .left,
  351|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  352|      0|                }
  353|      0|            }
  354|      0|        }
  355|      0|    }
  356|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/XAxisRendererRadarChart.swift:
    1|       |//
    2|       |//  XAxisRendererRadarChart.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class XAxisRendererRadarChart: XAxisRenderer
   16|       |{
   17|       |    @objc open weak var chart: RadarChartView?
   18|       |    
   19|       |    @objc public init(viewPortHandler: ViewPortHandler, xAxis: XAxis?, chart: RadarChartView)
   20|      0|    {
   21|      0|        super.init(viewPortHandler: viewPortHandler, xAxis: xAxis, transformer: nil)
   22|      0|        
   23|      0|        self.chart = chart
   24|      0|    }
   25|       |    
   26|       |    open override func renderAxisLabels(context: CGContext)
   27|      0|    {
   28|      0|        guard let
   29|      0|            xAxis = axis as? XAxis,
   30|      0|            let chart = chart
   31|      0|            else { return }
   32|      0|        
   33|      0|        if !xAxis.isEnabled || !xAxis.isDrawLabelsEnabled
   34|      0|        {
   35|      0|            return
   36|      0|        }
   37|      0|        
   38|      0|        let labelFont = xAxis.labelFont
   39|      0|        let labelTextColor = xAxis.labelTextColor
   40|      0|        let labelRotationAngleRadians = xAxis.labelRotationAngle.RAD2DEG
   41|      0|        let drawLabelAnchor = CGPoint(x: 0.5, y: 0.25)
   42|      0|        
   43|      0|        let sliceangle = chart.sliceAngle
   44|      0|        
   45|      0|        // calculate the factor that is needed for transforming the value to pixels
   46|      0|        let factor = chart.factor
   47|      0|        
   48|      0|        let center = chart.centerOffsets
   49|      0|        
   50|      0|        for i in stride(from: 0, to: chart.data?.maxEntryCountSet?.entryCount ?? 0, by: 1)
   51|      0|        {
   52|      0|            
   53|      0|            let label = xAxis.valueFormatter?.stringForValue(Double(i), axis: xAxis) ?? ""
   54|      0|            
   55|      0|            let angle = (sliceangle * CGFloat(i) + chart.rotationAngle).truncatingRemainder(dividingBy: 360.0)
   56|      0|            
   57|      0|            let p = center.moving(distance: CGFloat(chart.yRange) * factor + xAxis.labelRotatedWidth / 2.0, atAngle: angle)
   58|      0|            
   59|      0|            drawLabel(context: context,
   60|      0|                      formattedLabel: label,
   61|      0|                      x: p.x,
   62|      0|                      y: p.y - xAxis.labelRotatedHeight / 2.0,
   63|      0|                      attributes: [NSAttributedString.Key.font: labelFont, NSAttributedString.Key.foregroundColor: labelTextColor],
   64|      0|                      anchor: drawLabelAnchor,
   65|      0|                      angleRadians: labelRotationAngleRadians)
   66|      0|        }
   67|      0|    }
   68|       |    
   69|       |    @objc open func drawLabel(
   70|       |        context: CGContext,
   71|       |        formattedLabel: String,
   72|       |        x: CGFloat,
   73|       |        y: CGFloat,
   74|       |        attributes: [NSAttributedString.Key : Any],
   75|       |        anchor: CGPoint,
   76|       |        angleRadians: CGFloat)
   77|      0|    {
   78|      0|        ChartUtils.drawText(
   79|      0|            context: context,
   80|      0|            text: formattedLabel,
   81|      0|            point: CGPoint(x: x, y: y),
   82|      0|            attributes: attributes,
   83|      0|            anchor: anchor,
   84|      0|            angleRadians: angleRadians)
   85|      0|    }
   86|       |    
   87|       |    open override func renderLimitLines(context: CGContext)
   88|      0|    {
   89|      0|        /// XAxis LimitLines on RadarChart not yet supported.
   90|      0|    }
   91|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/YAxisRenderer.swift:
    1|       |//
    2|       |//  YAxisRenderer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |@objc(ChartYAxisRenderer)
   24|       |open class YAxisRenderer: AxisRendererBase
   25|       |{
   26|       |    @objc public init(viewPortHandler: ViewPortHandler, yAxis: YAxis?, transformer: Transformer?)
   27|      0|    {
   28|      0|        super.init(viewPortHandler: viewPortHandler, transformer: transformer, axis: yAxis)
   29|      0|    }
   30|       |    
   31|       |    /// draws the y-axis labels to the screen
   32|       |    open override func renderAxisLabels(context: CGContext)
   33|      0|    {
   34|      0|        guard let yAxis = self.axis as? YAxis else { return }
   35|      0|        
   36|      0|        if !yAxis.isEnabled || !yAxis.isDrawLabelsEnabled
   37|      0|        {
   38|      0|            return
   39|      0|        }
   40|      0|        
   41|      0|        let xoffset = yAxis.xOffset
   42|      0|        let yoffset = yAxis.labelFont.lineHeight / 2.5 + yAxis.yOffset
   43|      0|        
   44|      0|        let dependency = yAxis.axisDependency
   45|      0|        let labelPosition = yAxis.labelPosition
   46|      0|        
   47|      0|        var xPos = CGFloat(0.0)
   48|      0|        
   49|      0|        var textAlign: NSTextAlignment
   50|      0|        
   51|      0|        if dependency == .left
   52|      0|        {
   53|      0|            if labelPosition == .outsideChart
   54|      0|            {
   55|      0|                textAlign = .right
   56|      0|                xPos = viewPortHandler.offsetLeft - xoffset
   57|      0|            }
   58|      0|            else
   59|      0|            {
   60|      0|                textAlign = .left
   61|      0|                xPos = viewPortHandler.offsetLeft + xoffset
   62|      0|            }
   63|      0|            
   64|      0|        }
   65|      0|        else
   66|      0|        {
   67|      0|            if labelPosition == .outsideChart
   68|      0|            {
   69|      0|                textAlign = .left
   70|      0|                xPos = viewPortHandler.contentRight + xoffset
   71|      0|            }
   72|      0|            else
   73|      0|            {
   74|      0|                textAlign = .right
   75|      0|                xPos = viewPortHandler.contentRight - xoffset
   76|      0|            }
   77|      0|        }
   78|      0|        
   79|      0|        drawYLabels(
   80|      0|            context: context,
   81|      0|            fixedPosition: xPos,
   82|      0|            positions: transformedPositions(),
   83|      0|            offset: yoffset - yAxis.labelFont.lineHeight,
   84|      0|            textAlign: textAlign)
   85|      0|    }
   86|       |    
   87|       |    open override func renderAxisLine(context: CGContext)
   88|      0|    {
   89|      0|        guard let yAxis = self.axis as? YAxis else { return }
   90|      0|        
   91|      0|        if !yAxis.isEnabled || !yAxis.drawAxisLineEnabled
   92|      0|        {
   93|      0|            return
   94|      0|        }
   95|      0|        
   96|      0|        context.saveGState()
   97|      0|        
   98|      0|        context.setStrokeColor(yAxis.axisLineColor.cgColor)
   99|      0|        context.setLineWidth(yAxis.axisLineWidth)
  100|      0|        if yAxis.axisLineDashLengths != nil
  101|      0|        {
  102|      0|            context.setLineDash(phase: yAxis.axisLineDashPhase, lengths: yAxis.axisLineDashLengths)
  103|      0|        }
  104|      0|        else
  105|      0|        {
  106|      0|            context.setLineDash(phase: 0.0, lengths: [])
  107|      0|        }
  108|      0|        
  109|      0|        if yAxis.axisDependency == .left
  110|      0|        {
  111|      0|            context.beginPath()
  112|      0|            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
  113|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentBottom))
  114|      0|            context.strokePath()
  115|      0|        }
  116|      0|        else
  117|      0|        {
  118|      0|            context.beginPath()
  119|      0|            context.move(to: CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentTop))
  120|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentBottom))
  121|      0|            context.strokePath()
  122|      0|        }
  123|      0|        
  124|      0|        context.restoreGState()
  125|      0|    }
  126|       |    
  127|       |    /// draws the y-labels on the specified x-position
  128|       |    open func drawYLabels(
  129|       |        context: CGContext,
  130|       |        fixedPosition: CGFloat,
  131|       |        positions: [CGPoint],
  132|       |        offset: CGFloat,
  133|       |        textAlign: NSTextAlignment)
  134|      0|    {
  135|      0|        guard
  136|      0|            let yAxis = self.axis as? YAxis
  137|      0|            else { return }
  138|      0|        
  139|      0|        let labelFont = yAxis.labelFont
  140|      0|        let labelTextColor = yAxis.labelTextColor
  141|      0|        
  142|      0|        let from = yAxis.isDrawBottomYLabelEntryEnabled ? 0 : 1
  143|      0|        let to = yAxis.isDrawTopYLabelEntryEnabled ? yAxis.entryCount : (yAxis.entryCount - 1)
  144|      0|        
  145|      0|        let xOffset = yAxis.labelXOffset
  146|      0|        
  147|      0|        for i in stride(from: from, to: to, by: 1)
  148|      0|        {
  149|      0|            let text = yAxis.getFormattedLabel(i)
  150|      0|            
  151|      0|            ChartUtils.drawText(
  152|      0|                context: context,
  153|      0|                text: text,
  154|      0|                point: CGPoint(x: fixedPosition + xOffset, y: positions[i].y + offset),
  155|      0|                align: textAlign,
  156|      0|                attributes: [.font: labelFont, .foregroundColor: labelTextColor]
  157|      0|            )
  158|      0|        }
  159|      0|    }
  160|       |    
  161|       |    open override func renderGridLines(context: CGContext)
  162|      0|    {
  163|      0|        guard let
  164|      0|            yAxis = self.axis as? YAxis
  165|      0|            else { return }
  166|      0|        
  167|      0|        if !yAxis.isEnabled
  168|      0|        {
  169|      0|            return
  170|      0|        }
  171|      0|        
  172|      0|        if yAxis.drawGridLinesEnabled
  173|      0|        {
  174|      0|            let positions = transformedPositions()
  175|      0|            
  176|      0|            context.saveGState()
  177|      0|            defer { context.restoreGState() }
  178|      0|            context.clip(to: self.gridClippingRect)
  179|      0|            
  180|      0|            context.setShouldAntialias(yAxis.gridAntialiasEnabled)
  181|      0|            context.setStrokeColor(yAxis.gridColor.cgColor)
  182|      0|            context.setLineWidth(yAxis.gridLineWidth)
  183|      0|            context.setLineCap(yAxis.gridLineCap)
  184|      0|            
  185|      0|            if yAxis.gridLineDashLengths != nil
  186|      0|            {
  187|      0|                context.setLineDash(phase: yAxis.gridLineDashPhase, lengths: yAxis.gridLineDashLengths)
  188|      0|                
  189|      0|            }
  190|      0|            else
  191|      0|            {
  192|      0|                context.setLineDash(phase: 0.0, lengths: [])
  193|      0|            }
  194|      0|            
  195|      0|            // draw the grid
  196|      0|            positions.forEach { drawGridLine(context: context, position: $0) }
  197|      0|        }
  198|      0|
  199|      0|        if yAxis.drawZeroLineEnabled
  200|      0|        {
  201|      0|            // draw zero line
  202|      0|            drawZeroLine(context: context)
  203|      0|        }
  204|      0|    }
  205|       |    
  206|       |    @objc open var gridClippingRect: CGRect
  207|      0|    {
  208|      0|        var contentRect = viewPortHandler.contentRect
  209|      0|        let dy = self.axis?.gridLineWidth ?? 0.0
  210|      0|        contentRect.origin.y -= dy / 2.0
  211|      0|        contentRect.size.height += dy
  212|      0|        return contentRect
  213|      0|    }
  214|       |    
  215|       |    @objc open func drawGridLine(
  216|       |        context: CGContext,
  217|       |        position: CGPoint)
  218|      0|    {
  219|      0|        context.beginPath()
  220|      0|        context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: position.y))
  221|      0|        context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: position.y))
  222|      0|        context.strokePath()
  223|      0|    }
  224|       |    
  225|       |    @objc open func transformedPositions() -> [CGPoint]
  226|      0|    {
  227|      0|        guard
  228|      0|            let yAxis = self.axis as? YAxis,
  229|      0|            let transformer = self.transformer
  230|      0|            else { return [CGPoint]() }
  231|      0|        
  232|      0|        var positions = [CGPoint]()
  233|      0|        positions.reserveCapacity(yAxis.entryCount)
  234|      0|        
  235|      0|        let entries = yAxis.entries
  236|      0|        
  237|      0|        for i in stride(from: 0, to: yAxis.entryCount, by: 1)
  238|      0|        {
  239|      0|            positions.append(CGPoint(x: 0.0, y: entries[i]))
  240|      0|        }
  241|      0|
  242|      0|        transformer.pointValuesToPixel(&positions)
  243|      0|        
  244|      0|        return positions
  245|      0|    }
  246|       |
  247|       |    /// Draws the zero line at the specified position.
  248|       |    @objc open func drawZeroLine(context: CGContext)
  249|      0|    {
  250|      0|        guard
  251|      0|            let yAxis = self.axis as? YAxis,
  252|      0|            let transformer = self.transformer,
  253|      0|            let zeroLineColor = yAxis.zeroLineColor
  254|      0|            else { return }
  255|      0|        
  256|      0|        context.saveGState()
  257|      0|        defer { context.restoreGState() }
  258|      0|        
  259|      0|        var clippingRect = viewPortHandler.contentRect
  260|      0|        clippingRect.origin.y -= yAxis.zeroLineWidth / 2.0
  261|      0|        clippingRect.size.height += yAxis.zeroLineWidth
  262|      0|        context.clip(to: clippingRect)
  263|      0|
  264|      0|        context.setStrokeColor(zeroLineColor.cgColor)
  265|      0|        context.setLineWidth(yAxis.zeroLineWidth)
  266|      0|        
  267|      0|        let pos = transformer.pixelForValues(x: 0.0, y: 0.0)
  268|      0|    
  269|      0|        if yAxis.zeroLineDashLengths != nil
  270|      0|        {
  271|      0|            context.setLineDash(phase: yAxis.zeroLineDashPhase, lengths: yAxis.zeroLineDashLengths!)
  272|      0|        }
  273|      0|        else
  274|      0|        {
  275|      0|            context.setLineDash(phase: 0.0, lengths: [])
  276|      0|        }
  277|      0|        
  278|      0|        context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: pos.y))
  279|      0|        context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: pos.y))
  280|      0|        context.drawPath(using: CGPathDrawingMode.stroke)
  281|      0|    }
  282|       |    
  283|       |    open override func renderLimitLines(context: CGContext)
  284|      0|    {
  285|      0|        guard
  286|      0|            let yAxis = self.axis as? YAxis,
  287|      0|            let transformer = self.transformer
  288|      0|            else { return }
  289|      0|        
  290|      0|        let limitLines = yAxis.limitLines
  291|      0|        
  292|      0|        if limitLines.count == 0
  293|      0|        {
  294|      0|            return
  295|      0|        }
  296|      0|        
  297|      0|        context.saveGState()
  298|      0|        
  299|      0|        let trans = transformer.valueToPixelMatrix
  300|      0|        
  301|      0|        var position = CGPoint(x: 0.0, y: 0.0)
  302|      0|        
  303|      0|        for i in 0 ..< limitLines.count
  304|      0|        {
  305|      0|            let l = limitLines[i]
  306|      0|            
  307|      0|            if !l.isEnabled
  308|      0|            {
  309|      0|                continue
  310|      0|            }
  311|      0|            
  312|      0|            context.saveGState()
  313|      0|            defer { context.restoreGState() }
  314|      0|            
  315|      0|            var clippingRect = viewPortHandler.contentRect
  316|      0|            clippingRect.origin.y -= l.lineWidth / 2.0
  317|      0|            clippingRect.size.height += l.lineWidth
  318|      0|            context.clip(to: clippingRect)
  319|      0|            
  320|      0|            position.x = 0.0
  321|      0|            position.y = CGFloat(l.limit)
  322|      0|            position = position.applying(trans)
  323|      0|            
  324|      0|            context.beginPath()
  325|      0|            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: position.y))
  326|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: position.y))
  327|      0|            
  328|      0|            context.setStrokeColor(l.lineColor.cgColor)
  329|      0|            context.setLineWidth(l.lineWidth)
  330|      0|            if l.lineDashLengths != nil
  331|      0|            {
  332|      0|                context.setLineDash(phase: l.lineDashPhase, lengths: l.lineDashLengths!)
  333|      0|            }
  334|      0|            else
  335|      0|            {
  336|      0|                context.setLineDash(phase: 0.0, lengths: [])
  337|      0|            }
  338|      0|            
  339|      0|            context.strokePath()
  340|      0|            
  341|      0|            let label = l.label
  342|      0|            
  343|      0|            // if drawing the limit-value label is enabled
  344|      0|            if l.drawLabelEnabled && label.count > 0
  345|      0|            {
  346|      0|                let labelLineHeight = l.valueFont.lineHeight
  347|      0|                
  348|      0|                let xOffset: CGFloat = 4.0 + l.xOffset
  349|      0|                let yOffset: CGFloat = l.lineWidth + labelLineHeight + l.yOffset
  350|      0|                
  351|      0|                if l.labelPosition == .topRight
  352|      0|                {
  353|      0|                    ChartUtils.drawText(context: context,
  354|      0|                        text: label,
  355|      0|                        point: CGPoint(
  356|      0|                            x: viewPortHandler.contentRight - xOffset,
  357|      0|                            y: position.y - yOffset),
  358|      0|                        align: .right,
  359|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  360|      0|                }
  361|      0|                else if l.labelPosition == .bottomRight
  362|      0|                {
  363|      0|                    ChartUtils.drawText(context: context,
  364|      0|                        text: label,
  365|      0|                        point: CGPoint(
  366|      0|                            x: viewPortHandler.contentRight - xOffset,
  367|      0|                            y: position.y + yOffset - labelLineHeight),
  368|      0|                        align: .right,
  369|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  370|      0|                }
  371|      0|                else if l.labelPosition == .topLeft
  372|      0|                {
  373|      0|                    ChartUtils.drawText(context: context,
  374|      0|                        text: label,
  375|      0|                        point: CGPoint(
  376|      0|                            x: viewPortHandler.contentLeft + xOffset,
  377|      0|                            y: position.y - yOffset),
  378|      0|                        align: .left,
  379|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  380|      0|                }
  381|      0|                else
  382|      0|                {
  383|      0|                    ChartUtils.drawText(context: context,
  384|      0|                        text: label,
  385|      0|                        point: CGPoint(
  386|      0|                            x: viewPortHandler.contentLeft + xOffset,
  387|      0|                            y: position.y + yOffset - labelLineHeight),
  388|      0|                        align: .left,
  389|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  390|      0|                }
  391|      0|            }
  392|      0|        }
  393|      0|        
  394|      0|        context.restoreGState()
  395|      0|    }
  396|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/YAxisRendererHorizontalBarChart.swift:
    1|       |//
    2|       |//  YAxisRendererHorizontalBarChart.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class YAxisRendererHorizontalBarChart: YAxisRenderer
   16|       |{
   17|       |    public override init(viewPortHandler: ViewPortHandler, yAxis: YAxis?, transformer: Transformer?)
   18|      0|    {
   19|      0|        super.init(viewPortHandler: viewPortHandler, yAxis: yAxis, transformer: transformer)
   20|      0|    }
   21|       |
   22|       |    /// Computes the axis values.
   23|       |    open override func computeAxis(min: Double, max: Double, inverted: Bool)
   24|      0|    {
   25|      0|        guard let transformer = self.transformer else { return }
   26|      0|        
   27|      0|        var min = min, max = max
   28|      0|        
   29|      0|        // calculate the starting and entry point of the y-labels (depending on zoom / contentrect bounds)
   30|      0|        if viewPortHandler.contentHeight > 10.0 && !viewPortHandler.isFullyZoomedOutX
   31|      0|        {
   32|      0|            let p1 = transformer.valueForTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
   33|      0|            let p2 = transformer.valueForTouchPoint(CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentTop))
   34|      0|            
   35|      0|            if !inverted
   36|      0|            {
   37|      0|                min = Double(p1.x)
   38|      0|                max = Double(p2.x)
   39|      0|            }
   40|      0|            else
   41|      0|            {
   42|      0|                min = Double(p2.x)
   43|      0|                max = Double(p1.x)
   44|      0|            }
   45|      0|        }
   46|      0|        
   47|      0|        computeAxisValues(min: min, max: max)
   48|      0|    }
   49|       |
   50|       |    /// draws the y-axis labels to the screen
   51|       |    open override func renderAxisLabels(context: CGContext)
   52|      0|    {
   53|      0|        guard let yAxis = axis as? YAxis else { return }
   54|      0|        
   55|      0|        if !yAxis.isEnabled || !yAxis.isDrawLabelsEnabled
   56|      0|        {
   57|      0|            return
   58|      0|        }
   59|      0|        
   60|      0|        let lineHeight = yAxis.labelFont.lineHeight
   61|      0|        let baseYOffset: CGFloat = 2.5
   62|      0|        
   63|      0|        let dependency = yAxis.axisDependency
   64|      0|        let labelPosition = yAxis.labelPosition
   65|      0|        
   66|      0|        var yPos: CGFloat = 0.0
   67|      0|        
   68|      0|        if dependency == .left
   69|      0|        {
   70|      0|            if labelPosition == .outsideChart
   71|      0|            {
   72|      0|                yPos = viewPortHandler.contentTop - baseYOffset
   73|      0|            }
   74|      0|            else
   75|      0|            {
   76|      0|                yPos = viewPortHandler.contentTop - baseYOffset
   77|      0|            }
   78|      0|        }
   79|      0|        else
   80|      0|        {
   81|      0|            if labelPosition == .outsideChart
   82|      0|            {
   83|      0|                yPos = viewPortHandler.contentBottom + lineHeight + baseYOffset
   84|      0|            }
   85|      0|            else
   86|      0|            {
   87|      0|                yPos = viewPortHandler.contentBottom + lineHeight + baseYOffset
   88|      0|            }
   89|      0|        }
   90|      0|        
   91|      0|        // For compatibility with Android code, we keep above calculation the same,
   92|      0|        // And here we pull the line back up
   93|      0|        yPos -= lineHeight
   94|      0|        
   95|      0|        drawYLabels(
   96|      0|            context: context,
   97|      0|            fixedPosition: yPos,
   98|      0|            positions: transformedPositions(),
   99|      0|            offset: yAxis.yOffset)
  100|      0|    }
  101|       |    
  102|       |    open override func renderAxisLine(context: CGContext)
  103|      0|    {
  104|      0|        guard let yAxis = axis as? YAxis else { return }
  105|      0|        
  106|      0|        if !yAxis.isEnabled || !yAxis.drawAxisLineEnabled
  107|      0|        {
  108|      0|            return
  109|      0|        }
  110|      0|        
  111|      0|        context.saveGState()
  112|      0|        
  113|      0|        context.setStrokeColor(yAxis.axisLineColor.cgColor)
  114|      0|        context.setLineWidth(yAxis.axisLineWidth)
  115|      0|        if yAxis.axisLineDashLengths != nil
  116|      0|        {
  117|      0|            context.setLineDash(phase: yAxis.axisLineDashPhase, lengths: yAxis.axisLineDashLengths)
  118|      0|        }
  119|      0|        else
  120|      0|        {
  121|      0|            context.setLineDash(phase: 0.0, lengths: [])
  122|      0|        }
  123|      0|
  124|      0|        if yAxis.axisDependency == .left
  125|      0|        {
  126|      0|            context.beginPath()
  127|      0|            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
  128|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentTop))
  129|      0|            context.strokePath()
  130|      0|        }
  131|      0|        else
  132|      0|        {
  133|      0|            context.beginPath()
  134|      0|            context.move(to: CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentBottom))
  135|      0|            context.addLine(to: CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentBottom))
  136|      0|            context.strokePath()        }
  137|      0|        
  138|      0|        context.restoreGState()
  139|      0|    }
  140|       |
  141|       |    /// draws the y-labels on the specified x-position
  142|       |    @objc open func drawYLabels(
  143|       |        context: CGContext,
  144|       |        fixedPosition: CGFloat,
  145|       |        positions: [CGPoint],
  146|       |        offset: CGFloat)
  147|      0|    {
  148|      0|        guard let
  149|      0|            yAxis = axis as? YAxis
  150|      0|            else { return }
  151|      0|        
  152|      0|        let labelFont = yAxis.labelFont
  153|      0|        let labelTextColor = yAxis.labelTextColor
  154|      0|        
  155|      0|        let from = yAxis.isDrawBottomYLabelEntryEnabled ? 0 : 1
  156|      0|        let to = yAxis.isDrawTopYLabelEntryEnabled ? yAxis.entryCount : (yAxis.entryCount - 1)
  157|      0|        
  158|      0|        let xOffset = yAxis.labelXOffset
  159|      0|        
  160|      0|        for i in stride(from: from, to: to, by: 1)
  161|      0|        {
  162|      0|            let text = yAxis.getFormattedLabel(i)
  163|      0|            
  164|      0|            ChartUtils.drawText(
  165|      0|                context: context,
  166|      0|                text: text,
  167|      0|                point: CGPoint(
  168|      0|                    x: positions[i].x, y:
  169|      0|                    fixedPosition - offset + xOffset
  170|      0|                ),
  171|      0|                align: .center,
  172|      0|                attributes: [NSAttributedString.Key.font: labelFont, NSAttributedString.Key.foregroundColor: labelTextColor])
  173|      0|        }
  174|      0|    }
  175|       |    
  176|       |    open override var gridClippingRect: CGRect
  177|      0|    {
  178|      0|        var contentRect = viewPortHandler.contentRect
  179|      0|        let dx = self.axis?.gridLineWidth ?? 0.0
  180|      0|        contentRect.origin.x -= dx / 2.0
  181|      0|        contentRect.size.width += dx
  182|      0|        return contentRect
  183|      0|    }
  184|       |    
  185|       |    open override func drawGridLine(
  186|       |        context: CGContext,
  187|       |        position: CGPoint)
  188|      0|    {
  189|      0|        context.beginPath()
  190|      0|        context.move(to: CGPoint(x: position.x, y: viewPortHandler.contentTop))
  191|      0|        context.addLine(to: CGPoint(x: position.x, y: viewPortHandler.contentBottom))
  192|      0|        context.strokePath()
  193|      0|    }
  194|       |    
  195|       |    open override func transformedPositions() -> [CGPoint]
  196|      0|    {
  197|      0|        guard
  198|      0|            let yAxis = self.axis as? YAxis,
  199|      0|            let transformer = self.transformer
  200|      0|            else { return [CGPoint]() }
  201|      0|        
  202|      0|        var positions = [CGPoint]()
  203|      0|        positions.reserveCapacity(yAxis.entryCount)
  204|      0|        
  205|      0|        let entries = yAxis.entries
  206|      0|        
  207|      0|        for i in stride(from: 0, to: yAxis.entryCount, by: 1)
  208|      0|        {
  209|      0|            positions.append(CGPoint(x: entries[i], y: 0.0))
  210|      0|        }
  211|      0|        
  212|      0|        transformer.pointValuesToPixel(&positions)
  213|      0|        
  214|      0|        return positions
  215|      0|    }
  216|       |    
  217|       |    /// Draws the zero line at the specified position.
  218|       |    open override func drawZeroLine(context: CGContext)
  219|      0|    {
  220|      0|        guard
  221|      0|            let yAxis = self.axis as? YAxis,
  222|      0|            let transformer = self.transformer,
  223|      0|            let zeroLineColor = yAxis.zeroLineColor
  224|      0|            else { return }
  225|      0|        
  226|      0|        context.saveGState()
  227|      0|        defer { context.restoreGState() }
  228|      0|        
  229|      0|        var clippingRect = viewPortHandler.contentRect
  230|      0|        clippingRect.origin.x -= yAxis.zeroLineWidth / 2.0
  231|      0|        clippingRect.size.width += yAxis.zeroLineWidth
  232|      0|        context.clip(to: clippingRect)
  233|      0|        
  234|      0|        context.setStrokeColor(zeroLineColor.cgColor)
  235|      0|        context.setLineWidth(yAxis.zeroLineWidth)
  236|      0|        
  237|      0|        let pos = transformer.pixelForValues(x: 0.0, y: 0.0)
  238|      0|        
  239|      0|        if yAxis.zeroLineDashLengths != nil
  240|      0|        {
  241|      0|            context.setLineDash(phase: yAxis.zeroLineDashPhase, lengths: yAxis.zeroLineDashLengths!)
  242|      0|        }
  243|      0|        else
  244|      0|        {
  245|      0|            context.setLineDash(phase: 0.0, lengths: [])
  246|      0|        }
  247|      0|        
  248|      0|        context.move(to: CGPoint(x: pos.x - 1.0, y: viewPortHandler.contentTop))
  249|      0|        context.addLine(to: CGPoint(x: pos.x - 1.0, y: viewPortHandler.contentBottom))
  250|      0|        context.drawPath(using: CGPathDrawingMode.stroke)
  251|      0|    }
  252|       |    
  253|      0|    private var _limitLineSegmentsBuffer = [CGPoint](repeating: CGPoint(), count: 2)
  254|       |    
  255|       |    open override func renderLimitLines(context: CGContext)
  256|      0|    {
  257|      0|        guard
  258|      0|            let yAxis = axis as? YAxis,
  259|      0|            let transformer = self.transformer
  260|      0|            else { return }
  261|      0|        
  262|      0|        let limitLines = yAxis.limitLines
  263|      0|
  264|      0|        if limitLines.count <= 0
  265|      0|        {
  266|      0|            return
  267|      0|        }
  268|      0|        
  269|      0|        context.saveGState()
  270|      0|        
  271|      0|        let trans = transformer.valueToPixelMatrix
  272|      0|        
  273|      0|        var position = CGPoint(x: 0.0, y: 0.0)
  274|      0|        
  275|      0|        for i in 0 ..< limitLines.count
  276|      0|        {
  277|      0|            let l = limitLines[i]
  278|      0|            
  279|      0|            if !l.isEnabled
  280|      0|            {
  281|      0|                continue
  282|      0|            }
  283|      0|            
  284|      0|            context.saveGState()
  285|      0|            defer { context.restoreGState() }
  286|      0|
  287|      0|            var clippingRect = viewPortHandler.contentRect
  288|      0|            clippingRect.origin.x -= l.lineWidth / 2.0
  289|      0|            clippingRect.size.width += l.lineWidth
  290|      0|            context.clip(to: clippingRect)
  291|      0|            
  292|      0|            position.x = CGFloat(l.limit)
  293|      0|            position.y = 0.0
  294|      0|            position = position.applying(trans)
  295|      0|            
  296|      0|            context.beginPath()
  297|      0|            context.move(to: CGPoint(x: position.x, y: viewPortHandler.contentTop))
  298|      0|            context.addLine(to: CGPoint(x: position.x, y: viewPortHandler.contentBottom))
  299|      0|            
  300|      0|            context.setStrokeColor(l.lineColor.cgColor)
  301|      0|            context.setLineWidth(l.lineWidth)
  302|      0|            if l.lineDashLengths != nil
  303|      0|            {
  304|      0|                context.setLineDash(phase: l.lineDashPhase, lengths: l.lineDashLengths!)
  305|      0|            }
  306|      0|            else
  307|      0|            {
  308|      0|                context.setLineDash(phase: 0.0, lengths: [])
  309|      0|            }
  310|      0|            
  311|      0|            context.strokePath()
  312|      0|            
  313|      0|            let label = l.label
  314|      0|
  315|      0|            // if drawing the limit-value label is enabled
  316|      0|            if l.drawLabelEnabled && label.count > 0
  317|      0|            {
  318|      0|                let labelLineHeight = l.valueFont.lineHeight
  319|      0|                
  320|      0|                let xOffset: CGFloat = l.lineWidth + l.xOffset
  321|      0|                let yOffset: CGFloat = 2.0 + l.yOffset
  322|      0|
  323|      0|                if l.labelPosition == .topRight
  324|      0|                {
  325|      0|                    ChartUtils.drawText(context: context,
  326|      0|                        text: label,
  327|      0|                        point: CGPoint(
  328|      0|                            x: position.x + xOffset,
  329|      0|                            y: viewPortHandler.contentTop + yOffset),
  330|      0|                        align: .left,
  331|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  332|      0|                }
  333|      0|                else if l.labelPosition == .bottomRight
  334|      0|                {
  335|      0|                    ChartUtils.drawText(context: context,
  336|      0|                        text: label,
  337|      0|                        point: CGPoint(
  338|      0|                            x: position.x + xOffset,
  339|      0|                            y: viewPortHandler.contentBottom - labelLineHeight - yOffset),
  340|      0|                        align: .left,
  341|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  342|      0|                }
  343|      0|                else if l.labelPosition == .topLeft
  344|      0|                {
  345|      0|                    ChartUtils.drawText(context: context,
  346|      0|                        text: label,
  347|      0|                        point: CGPoint(
  348|      0|                            x: position.x - xOffset,
  349|      0|                            y: viewPortHandler.contentTop + yOffset),
  350|      0|                        align: .right,
  351|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  352|      0|                }
  353|      0|                else
  354|      0|                {
  355|      0|                    ChartUtils.drawText(context: context,
  356|      0|                        text: label,
  357|      0|                        point: CGPoint(
  358|      0|                            x: position.x - xOffset,
  359|      0|                            y: viewPortHandler.contentBottom - labelLineHeight - yOffset),
  360|      0|                        align: .right,
  361|      0|                        attributes: [NSAttributedString.Key.font: l.valueFont, NSAttributedString.Key.foregroundColor: l.valueTextColor])
  362|      0|                }
  363|      0|            }
  364|      0|        }
  365|      0|        
  366|      0|        context.restoreGState()
  367|      0|    }
  368|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Renderers/YAxisRendererRadarChart.swift:
    1|       |//
    2|       |//  YAxisRendererRadarChart.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |open class YAxisRendererRadarChart: YAxisRenderer
   24|       |{
   25|       |    private weak var chart: RadarChartView?
   26|       |    
   27|       |    @objc public init(viewPortHandler: ViewPortHandler, yAxis: YAxis?, chart: RadarChartView)
   28|      0|    {
   29|      0|        super.init(viewPortHandler: viewPortHandler, yAxis: yAxis, transformer: nil)
   30|      0|        
   31|      0|        self.chart = chart
   32|      0|    }
   33|       |    
   34|       |    open override func computeAxisValues(min yMin: Double, max yMax: Double)
   35|      0|    {
   36|      0|        guard let
   37|      0|            axis = axis as? YAxis
   38|      0|            else { return }
   39|      0|        
   40|      0|        let labelCount = axis.labelCount
   41|      0|        let range = abs(yMax - yMin)
   42|      0|        
   43|      0|        if labelCount == 0 || range <= 0 || range.isInfinite
   44|      0|        {
   45|      0|            axis.entries = [Double]()
   46|      0|            axis.centeredEntries = [Double]()
   47|      0|            return
   48|      0|        }
   49|      0|        
   50|      0|        // Find out how much spacing (in yValue space) between axis values
   51|      0|        let rawInterval = range / Double(labelCount)
   52|      0|        var interval = rawInterval.roundedToNextSignficant()
   53|      0|        
   54|      0|        // If granularity is enabled, then do not allow the interval to go below specified granularity.
   55|      0|        // This is used to avoid repeated values when rounding values for display.
   56|      0|        if axis.isGranularityEnabled
   57|      0|        {
   58|      0|            interval = interval < axis.granularity ? axis.granularity : interval
   59|      0|        }
   60|      0|        
   61|      0|        // Normalize interval
   62|      0|        let intervalMagnitude = pow(10.0, floor(log10(interval))).roundedToNextSignficant()
   63|      0|        let intervalSigDigit = Int(interval / intervalMagnitude)
   64|      0|        
   65|      0|        if intervalSigDigit > 5
   66|      0|        {
   67|      0|            // Use one order of magnitude higher, to avoid intervals like 0.9 or 90
   68|      0|            // if it's 0.0 after floor(), we use the old value
   69|      0|            interval = floor(10.0 * intervalMagnitude) == 0.0 ? interval : floor(10.0 * intervalMagnitude)
   70|      0|        }
   71|      0|        
   72|      0|        let centeringEnabled = axis.isCenterAxisLabelsEnabled
   73|      0|        var n = centeringEnabled ? 1 : 0
   74|      0|
   75|      0|        // force label count
   76|      0|        if axis.isForceLabelsEnabled
   77|      0|        {
   78|      0|            let step = Double(range) / Double(labelCount - 1)
   79|      0|            
   80|      0|            // Ensure stops contains at least n elements.
   81|      0|            axis.entries.removeAll(keepingCapacity: true)
   82|      0|            axis.entries.reserveCapacity(labelCount)
   83|      0|            
   84|      0|            var v = yMin
   85|      0|            
   86|      0|            for _ in 0 ..< labelCount
   87|      0|            {
   88|      0|                axis.entries.append(v)
   89|      0|                v += step
   90|      0|            }
   91|      0|            
   92|      0|            n = labelCount
   93|      0|        }
   94|      0|        else
   95|      0|        {
   96|      0|            // no forced count
   97|      0|            
   98|      0|            var first = interval == 0.0 ? 0.0 : ceil(yMin / interval) * interval
   99|      0|            
  100|      0|            if centeringEnabled
  101|      0|            {
  102|      0|                first -= interval
  103|      0|            }
  104|      0|
  105|      0|            let last = interval == 0.0 ? 0.0 : (floor(yMax / interval) * interval).nextUp
  106|      0|            
  107|      0|            if interval != 0.0
  108|      0|            {
  109|      0|                for _ in stride(from: first, through: last, by: interval)
  110|      0|                {
  111|      0|                    n += 1
  112|      0|                }
  113|      0|            }
  114|      0|            
  115|      0|            n += 1
  116|      0|            
  117|      0|            // Ensure stops contains at least n elements.
  118|      0|            axis.entries.removeAll(keepingCapacity: true)
  119|      0|            axis.entries.reserveCapacity(labelCount)
  120|      0|            
  121|      0|            var f = first
  122|      0|            var i = 0
  123|      0|            while i < n
  124|      0|            {
  125|      0|                if f == 0.0
  126|      0|                {
  127|      0|                    // Fix for IEEE negative zero case (Where value == -0.0, and 0.0 == -0.0)
  128|      0|                    f = 0.0
  129|      0|                }
  130|      0|
  131|      0|                axis.entries.append(Double(f))
  132|      0|                
  133|      0|                f += interval
  134|      0|                i += 1
  135|      0|            }
  136|      0|        }
  137|      0|        
  138|      0|        // set decimals
  139|      0|        if interval < 1
  140|      0|        {
  141|      0|            axis.decimals = Int(ceil(-log10(interval)))
  142|      0|        }
  143|      0|        else
  144|      0|        {
  145|      0|            axis.decimals = 0
  146|      0|        }
  147|      0|        
  148|      0|        if centeringEnabled
  149|      0|        {
  150|      0|            axis.centeredEntries.reserveCapacity(n)
  151|      0|            axis.centeredEntries.removeAll()
  152|      0|            
  153|      0|            let offset = (axis.entries[1] - axis.entries[0]) / 2.0
  154|      0|            
  155|      0|            for i in 0 ..< n
  156|      0|            {
  157|      0|                axis.centeredEntries.append(axis.entries[i] + offset)
  158|      0|            }
  159|      0|        }
  160|      0|        
  161|      0|        axis._axisMinimum = axis.entries[0]
  162|      0|        axis._axisMaximum = axis.entries[n-1]
  163|      0|        axis.axisRange = abs(axis._axisMaximum - axis._axisMinimum)
  164|      0|    }
  165|       |    
  166|       |    open override func renderAxisLabels(context: CGContext)
  167|      0|    {
  168|      0|        guard let
  169|      0|            yAxis = axis as? YAxis,
  170|      0|            let chart = chart
  171|      0|            else { return }
  172|      0|        
  173|      0|        if !yAxis.isEnabled || !yAxis.isDrawLabelsEnabled
  174|      0|        {
  175|      0|            return
  176|      0|        }
  177|      0|        
  178|      0|        let labelFont = yAxis.labelFont
  179|      0|        let labelTextColor = yAxis.labelTextColor
  180|      0|        
  181|      0|        let center = chart.centerOffsets
  182|      0|        let factor = chart.factor
  183|      0|        
  184|      0|        let labelLineHeight = yAxis.labelFont.lineHeight
  185|      0|        
  186|      0|        let from = yAxis.isDrawBottomYLabelEntryEnabled ? 0 : 1
  187|      0|        let to = yAxis.isDrawTopYLabelEntryEnabled ? yAxis.entryCount : (yAxis.entryCount - 1)
  188|      0|
  189|      0|        let alignment: NSTextAlignment = yAxis.labelAlignment
  190|      0|        let xOffset = yAxis.labelXOffset
  191|      0|        
  192|      0|        for j in stride(from: from, to: to, by: 1)
  193|      0|        {
  194|      0|            let r = CGFloat(yAxis.entries[j] - yAxis._axisMinimum) * factor
  195|      0|            
  196|      0|            let p = center.moving(distance: r, atAngle: chart.rotationAngle)
  197|      0|            
  198|      0|            let label = yAxis.getFormattedLabel(j)
  199|      0|            
  200|      0|            ChartUtils.drawText(
  201|      0|                context: context,
  202|      0|                text: label,
  203|      0|                point: CGPoint(x: p.x + xOffset, y: p.y - labelLineHeight),
  204|      0|                align: alignment,
  205|      0|                attributes: [
  206|      0|                    NSAttributedString.Key.font: labelFont,
  207|      0|                    NSAttributedString.Key.foregroundColor: labelTextColor
  208|      0|                ])
  209|      0|        }
  210|      0|    }
  211|       |    
  212|       |    open override func renderLimitLines(context: CGContext)
  213|      0|    {
  214|      0|        guard
  215|      0|            let yAxis = axis as? YAxis,
  216|      0|            let chart = chart,
  217|      0|            let data = chart.data
  218|      0|            else { return }
  219|      0|        
  220|      0|        let limitLines = yAxis.limitLines
  221|      0|        
  222|      0|        if limitLines.count == 0
  223|      0|        {
  224|      0|            return
  225|      0|        }
  226|      0|        
  227|      0|        context.saveGState()
  228|      0|        
  229|      0|        let sliceangle = chart.sliceAngle
  230|      0|        
  231|      0|        // calculate the factor that is needed for transforming the value to pixels
  232|      0|        let factor = chart.factor
  233|      0|        
  234|      0|        let center = chart.centerOffsets
  235|      0|        
  236|      0|        for i in 0 ..< limitLines.count
  237|      0|        {
  238|      0|            let l = limitLines[i]
  239|      0|            
  240|      0|            if !l.isEnabled
  241|      0|            {
  242|      0|                continue
  243|      0|            }
  244|      0|            
  245|      0|            context.setStrokeColor(l.lineColor.cgColor)
  246|      0|            context.setLineWidth(l.lineWidth)
  247|      0|            if l.lineDashLengths != nil
  248|      0|            {
  249|      0|                context.setLineDash(phase: l.lineDashPhase, lengths: l.lineDashLengths!)
  250|      0|            }
  251|      0|            else
  252|      0|            {
  253|      0|                context.setLineDash(phase: 0.0, lengths: [])
  254|      0|            }
  255|      0|            
  256|      0|            let r = CGFloat(l.limit - chart.chartYMin) * factor
  257|      0|            
  258|      0|            context.beginPath()
  259|      0|            
  260|      0|            for j in 0 ..< (data.maxEntryCountSet?.entryCount ?? 0)
  261|      0|            {
  262|      0|                let p = center.moving(distance: r, atAngle: sliceangle * CGFloat(j) + chart.rotationAngle)
  263|      0|                
  264|      0|                if j == 0
  265|      0|                {
  266|      0|                    context.move(to: CGPoint(x: p.x, y: p.y))
  267|      0|                }
  268|      0|                else
  269|      0|                {
  270|      0|                    context.addLine(to: CGPoint(x: p.x, y: p.y))
  271|      0|                }
  272|      0|            }
  273|      0|            
  274|      0|            context.closePath()
  275|      0|            
  276|      0|            context.strokePath()
  277|      0|        }
  278|      0|        
  279|      0|        context.restoreGState()
  280|      0|    }
  281|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/ChartColorTemplates.swift:
    1|       |//
    2|       |//  ChartColorTemplates.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |open class ChartColorTemplates: NSObject
   16|       |{
   17|       |    @objc open class func liberty () -> [NSUIColor]
   18|      0|    {
   19|      0|        return [
   20|      0|            NSUIColor(red: 207/255.0, green: 248/255.0, blue: 246/255.0, alpha: 1.0),
   21|      0|            NSUIColor(red: 148/255.0, green: 212/255.0, blue: 212/255.0, alpha: 1.0),
   22|      0|            NSUIColor(red: 136/255.0, green: 180/255.0, blue: 187/255.0, alpha: 1.0),
   23|      0|            NSUIColor(red: 118/255.0, green: 174/255.0, blue: 175/255.0, alpha: 1.0),
   24|      0|            NSUIColor(red: 42/255.0, green: 109/255.0, blue: 130/255.0, alpha: 1.0)
   25|      0|        ]
   26|      0|    }
   27|       |    
   28|       |    @objc open class func joyful () -> [NSUIColor]
   29|      0|    {
   30|      0|        return [
   31|      0|            NSUIColor(red: 217/255.0, green: 80/255.0, blue: 138/255.0, alpha: 1.0),
   32|      0|            NSUIColor(red: 254/255.0, green: 149/255.0, blue: 7/255.0, alpha: 1.0),
   33|      0|            NSUIColor(red: 254/255.0, green: 247/255.0, blue: 120/255.0, alpha: 1.0),
   34|      0|            NSUIColor(red: 106/255.0, green: 167/255.0, blue: 134/255.0, alpha: 1.0),
   35|      0|            NSUIColor(red: 53/255.0, green: 194/255.0, blue: 209/255.0, alpha: 1.0)
   36|      0|        ]
   37|      0|    }
   38|       |    
   39|       |    @objc open class func pastel () -> [NSUIColor]
   40|      0|    {
   41|      0|        return [
   42|      0|            NSUIColor(red: 64/255.0, green: 89/255.0, blue: 128/255.0, alpha: 1.0),
   43|      0|            NSUIColor(red: 149/255.0, green: 165/255.0, blue: 124/255.0, alpha: 1.0),
   44|      0|            NSUIColor(red: 217/255.0, green: 184/255.0, blue: 162/255.0, alpha: 1.0),
   45|      0|            NSUIColor(red: 191/255.0, green: 134/255.0, blue: 134/255.0, alpha: 1.0),
   46|      0|            NSUIColor(red: 179/255.0, green: 48/255.0, blue: 80/255.0, alpha: 1.0)
   47|      0|        ]
   48|      0|    }
   49|       |    
   50|       |    @objc open class func colorful () -> [NSUIColor]
   51|      0|    {
   52|      0|        return [
   53|      0|            NSUIColor(red: 193/255.0, green: 37/255.0, blue: 82/255.0, alpha: 1.0),
   54|      0|            NSUIColor(red: 255/255.0, green: 102/255.0, blue: 0/255.0, alpha: 1.0),
   55|      0|            NSUIColor(red: 245/255.0, green: 199/255.0, blue: 0/255.0, alpha: 1.0),
   56|      0|            NSUIColor(red: 106/255.0, green: 150/255.0, blue: 31/255.0, alpha: 1.0),
   57|      0|            NSUIColor(red: 179/255.0, green: 100/255.0, blue: 53/255.0, alpha: 1.0)
   58|      0|        ]
   59|      0|    }
   60|       |    
   61|       |    @objc open class func vordiplom () -> [NSUIColor]
   62|      0|    {
   63|      0|        return [
   64|      0|            NSUIColor(red: 192/255.0, green: 255/255.0, blue: 140/255.0, alpha: 1.0),
   65|      0|            NSUIColor(red: 255/255.0, green: 247/255.0, blue: 140/255.0, alpha: 1.0),
   66|      0|            NSUIColor(red: 255/255.0, green: 208/255.0, blue: 140/255.0, alpha: 1.0),
   67|      0|            NSUIColor(red: 140/255.0, green: 234/255.0, blue: 255/255.0, alpha: 1.0),
   68|      0|            NSUIColor(red: 255/255.0, green: 140/255.0, blue: 157/255.0, alpha: 1.0)
   69|      0|        ]
   70|      0|    }
   71|       |    
   72|       |    @objc open class func material () -> [NSUIColor]
   73|      0|    {
   74|      0|        return [
   75|      0|            NSUIColor(red: 46/255.0, green: 204/255.0, blue: 113/255.0, alpha: 1.0),
   76|      0|            NSUIColor(red: 241/255.0, green: 196/255.0, blue: 15/255.0, alpha: 1.0),
   77|      0|            NSUIColor(red: 231/255.0, green: 76/255.0, blue: 60/255.0, alpha: 1.0),
   78|      0|            NSUIColor(red: 52/255.0, green: 152/255.0, blue: 219/255.0, alpha: 1.0)
   79|      0|        ]
   80|      0|    }
   81|       |    
   82|       |    @objc open class func colorFromString(_ colorString: String) -> NSUIColor
   83|      0|    {
   84|      0|        let leftParenCharset: CharacterSet = CharacterSet(charactersIn: "( ")
   85|      0|        let commaCharset: CharacterSet = CharacterSet(charactersIn: ", ")
   86|      0|
   87|      0|        let colorString = colorString.lowercased()
   88|      0|        
   89|      0|        if colorString.hasPrefix("#")
   90|      0|        {
   91|      0|            var argb: [UInt] = [255, 0, 0, 0]
   92|      0|            let colorString = colorString.unicodeScalars
   93|      0|            var length = colorString.count
   94|      0|            var index = colorString.startIndex
   95|      0|            let endIndex = colorString.endIndex
   96|      0|            
   97|      0|            index = colorString.index(after: index)
   98|      0|            length = length - 1
   99|      0|            
  100|      0|            if length == 3 || length == 6 || length == 8
  101|      0|            {
  102|      0|                var i = length == 8 ? 0 : 1
  103|      0|                while index < endIndex
  104|      0|                {
  105|      0|                    var c = colorString[index]
  106|      0|                    index = colorString.index(after: index)
  107|      0|                    
  108|      0|                    var val = (c.value >= 0x61 && c.value <= 0x66) ? (c.value - 0x61 + 10) : c.value - 0x30
  109|      0|                    argb[i] = UInt(val) * 16
  110|      0|                    if length == 3
  111|      0|                    {
  112|      0|                        argb[i] = argb[i] + UInt(val)
  113|      0|                    }
  114|      0|                    else
  115|      0|                    {
  116|      0|                        c = colorString[index]
  117|      0|                        index = colorString.index(after: index)
  118|      0|                        
  119|      0|                        val = (c.value >= 0x61 && c.value <= 0x66) ? (c.value - 0x61 + 10) : c.value - 0x30
  120|      0|                        argb[i] = argb[i] + UInt(val)
  121|      0|                    }
  122|      0|                    
  123|      0|                    i += 1
  124|      0|                }
  125|      0|            }
  126|      0|            
  127|      0|            return NSUIColor(red: CGFloat(argb[1]) / 255.0, green: CGFloat(argb[2]) / 255.0, blue: CGFloat(argb[3]) / 255.0, alpha: CGFloat(argb[0]) / 255.0)
  128|      0|        }
  129|      0|        else if colorString.hasPrefix("rgba")
  130|      0|        {
  131|      0|            var a: Float = 1.0
  132|      0|            var r: Int32 = 0
  133|      0|            var g: Int32 = 0
  134|      0|            var b: Int32 = 0
  135|      0|            let scanner: Scanner = Scanner(string: colorString)
  136|      0|            scanner.scanString("rgba", into: nil)
  137|      0|            scanner.scanCharacters(from: leftParenCharset, into: nil)
  138|      0|            scanner.scanInt32(&r)
  139|      0|            scanner.scanCharacters(from: commaCharset, into: nil)
  140|      0|            scanner.scanInt32(&g)
  141|      0|            scanner.scanCharacters(from: commaCharset, into: nil)
  142|      0|            scanner.scanInt32(&b)
  143|      0|            scanner.scanCharacters(from: commaCharset, into: nil)
  144|      0|            scanner.scanFloat(&a)
  145|      0|            return NSUIColor(
  146|      0|                red: CGFloat(r) / 255.0,
  147|      0|                green: CGFloat(g) / 255.0,
  148|      0|                blue: CGFloat(b) / 255.0,
  149|      0|                alpha: CGFloat(a)
  150|      0|            )
  151|      0|        }
  152|      0|        else if colorString.hasPrefix("argb")
  153|      0|        {
  154|      0|            var a: Float = 1.0
  155|      0|            var r: Int32 = 0
  156|      0|            var g: Int32 = 0
  157|      0|            var b: Int32 = 0
  158|      0|            let scanner: Scanner = Scanner(string: colorString)
  159|      0|            scanner.scanString("argb", into: nil)
  160|      0|            scanner.scanCharacters(from: leftParenCharset, into: nil)
  161|      0|            scanner.scanFloat(&a)
  162|      0|            scanner.scanCharacters(from: commaCharset, into: nil)
  163|      0|            scanner.scanInt32(&r)
  164|      0|            scanner.scanCharacters(from: commaCharset, into: nil)
  165|      0|            scanner.scanInt32(&g)
  166|      0|            scanner.scanCharacters(from: commaCharset, into: nil)
  167|      0|            scanner.scanInt32(&b)
  168|      0|            return NSUIColor(
  169|      0|                red: CGFloat(r) / 255.0,
  170|      0|                green: CGFloat(g) / 255.0,
  171|      0|                blue: CGFloat(b) / 255.0,
  172|      0|                alpha: CGFloat(a)
  173|      0|            )
  174|      0|        }
  175|      0|        else if colorString.hasPrefix("rgb")
  176|      0|        {
  177|      0|            var r: Int32 = 0
  178|      0|            var g: Int32 = 0
  179|      0|            var b: Int32 = 0
  180|      0|            let scanner: Scanner = Scanner(string: colorString)
  181|      0|            scanner.scanString("rgb", into: nil)
  182|      0|            scanner.scanCharacters(from: leftParenCharset, into: nil)
  183|      0|            scanner.scanInt32(&r)
  184|      0|            scanner.scanCharacters(from: commaCharset, into: nil)
  185|      0|            scanner.scanInt32(&g)
  186|      0|            scanner.scanCharacters(from: commaCharset, into: nil)
  187|      0|            scanner.scanInt32(&b)
  188|      0|            return NSUIColor(
  189|      0|                red: CGFloat(r) / 255.0,
  190|      0|                green: CGFloat(g) / 255.0,
  191|      0|                blue: CGFloat(b) / 255.0,
  192|      0|                alpha: 1.0
  193|      0|            )
  194|      0|        }
  195|      0|        
  196|      0|        return NSUIColor.clear
  197|      0|    }
  198|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/ChartUtils.swift:
    1|       |//
    2|       |//  Utils.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |#if canImport(Cocoa)
   20|       |import Cocoa
   21|       |#endif
   22|       |
   23|       |extension Comparable
   24|       |{
   25|       |    func clamped(to range: ClosedRange<Self>) -> Self
   26|      0|    {
   27|      0|        if self > range.upperBound
   28|      0|        {
   29|      0|            return range.upperBound
   30|      0|        }
   31|      0|        else if self < range.lowerBound
   32|      0|        {
   33|      0|            return range.lowerBound
   34|      0|        }
   35|      0|        else
   36|      0|        {
   37|      0|            return self
   38|      0|        }
   39|      0|    }
   40|       |}
   41|       |
   42|       |extension FloatingPoint
   43|       |{
   44|       |    var DEG2RAD: Self
   45|      0|    {
   46|      0|        return self * .pi / 180
   47|      0|    }
   48|       |
   49|       |    var RAD2DEG: Self
   50|      0|    {
   51|      0|        return self * 180 / .pi
   52|      0|    }
   53|       |
   54|       |    /// - Note: Value must be in degrees
   55|       |    /// - Returns: An angle between 0.0 < 360.0 (not less than zero, less than 360)
   56|       |    var normalizedAngle: Self
   57|      0|    {
   58|      0|        let angle = truncatingRemainder(dividingBy: 360)
   59|      0|        return (sign == .minus) ? angle + 360 : angle
   60|      0|    }
   61|       |}
   62|       |
   63|       |extension CGSize
   64|       |{
   65|       |    func rotatedBy(degrees: CGFloat) -> CGSize
   66|      0|    {
   67|      0|        let radians = degrees.DEG2RAD
   68|      0|        return rotatedBy(radians: radians)
   69|      0|    }
   70|       |
   71|       |    func rotatedBy(radians: CGFloat) -> CGSize
   72|      0|    {
   73|      0|        return CGSize(
   74|      0|            width: abs(width * cos(radians)) + abs(height * sin(radians)),
   75|      0|            height: abs(width * sin(radians)) + abs(height * cos(radians))
   76|      0|        )
   77|      0|    }
   78|       |}
   79|       |
   80|       |extension Double
   81|       |{
   82|       |    /// Rounds the number to the nearest multiple of it's order of magnitude, rounding away from zero if halfway.
   83|       |    func roundedToNextSignficant() -> Double
   84|      0|    {
   85|      0|        guard
   86|      0|            !isInfinite,
   87|      0|            !isNaN,
   88|      0|            self != 0
   89|      0|            else { return self }
   90|      0|
   91|      0|        let d = ceil(log10(self < 0 ? -self : self))
   92|      0|        let pw = 1 - Int(d)
   93|      0|        let magnitude = pow(10.0, Double(pw))
   94|      0|        let shifted = (self * magnitude).rounded()
   95|      0|        return shifted / magnitude
   96|      0|    }
   97|       |
   98|       |    var decimalPlaces: Int
   99|      0|    {
  100|      0|        guard
  101|      0|            !isNaN,
  102|      0|            !isInfinite,
  103|      0|            self != 0.0
  104|      0|            else { return 0 }
  105|      0|
  106|      0|        let i = self.roundedToNextSignficant()
  107|      0|
  108|      0|        guard
  109|      0|            !i.isInfinite,
  110|      0|            !i.isNaN
  111|      0|            else { return 0 }
  112|      0|
  113|      0|        return Int(ceil(-log10(i))) + 2
  114|      0|    }
  115|       |}
  116|       |
  117|       |extension CGPoint
  118|       |{
  119|       |    /// Calculates the position around a center point, depending on the distance from the center, and the angle of the position around the center.
  120|       |    func moving(distance: CGFloat, atAngle angle: CGFloat) -> CGPoint
  121|      0|    {
  122|      0|        return CGPoint(x: x + distance * cos(angle.DEG2RAD),
  123|      0|                       y: y + distance * sin(angle.DEG2RAD))
  124|      0|    }
  125|       |}
  126|       |
  127|       |open class ChartUtils
  128|       |{
  129|       |    private static var _defaultValueFormatter: IValueFormatter = ChartUtils.generateDefaultValueFormatter()
  130|       |    
  131|       |    open class func drawImage(
  132|       |        context: CGContext,
  133|       |        image: NSUIImage,
  134|       |        x: CGFloat,
  135|       |        y: CGFloat,
  136|       |        size: CGSize)
  137|      0|    {
  138|      0|        var drawOffset = CGPoint()
  139|      0|        drawOffset.x = x - (size.width / 2)
  140|      0|        drawOffset.y = y - (size.height / 2)
  141|      0|        
  142|      0|        NSUIGraphicsPushContext(context)
  143|      0|        
  144|      0|        if image.size.width != size.width && image.size.height != size.height
  145|      0|        {
  146|      0|            let key = "resized_\(size.width)_\(size.height)"
  147|      0|            
  148|      0|            // Try to take scaled image from cache of this image
  149|      0|            var scaledImage = objc_getAssociatedObject(image, key) as? NSUIImage
  150|      0|            if scaledImage == nil
  151|      0|            {
  152|      0|                // Scale the image
  153|      0|                NSUIGraphicsBeginImageContextWithOptions(size, false, 0.0)
  154|      0|                
  155|      0|                image.draw(in: CGRect(origin: CGPoint(x: 0, y: 0), size: size))
  156|      0|                
  157|      0|                scaledImage = NSUIGraphicsGetImageFromCurrentImageContext()
  158|      0|                NSUIGraphicsEndImageContext()
  159|      0|                
  160|      0|                // Put the scaled image in a cache owned by the original image
  161|      0|                objc_setAssociatedObject(image, key, scaledImage, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  162|      0|            }
  163|      0|            
  164|      0|            scaledImage?.draw(in: CGRect(origin: drawOffset, size: size))
  165|      0|        }
  166|      0|        else
  167|      0|        {
  168|      0|            image.draw(in: CGRect(origin: drawOffset, size: size))
  169|      0|        }
  170|      0|        
  171|      0|        NSUIGraphicsPopContext()
  172|      0|    }
  173|       |    
  174|       |    open class func drawText(context: CGContext, text: String, point: CGPoint, align: NSTextAlignment, attributes: [NSAttributedString.Key : Any]?)
  175|      0|    {
  176|      0|        var point = point
  177|      0|        
  178|      0|        if align == .center
  179|      0|        {
  180|      0|            point.x -= text.size(withAttributes: attributes).width / 2.0
  181|      0|        }
  182|      0|        else if align == .right
  183|      0|        {
  184|      0|            point.x -= text.size(withAttributes: attributes).width
  185|      0|        }
  186|      0|        
  187|      0|        NSUIGraphicsPushContext(context)
  188|      0|        
  189|      0|        (text as NSString).draw(at: point, withAttributes: attributes)
  190|      0|        
  191|      0|        NSUIGraphicsPopContext()
  192|      0|    }
  193|       |    
  194|       |    open class func drawText(context: CGContext, text: String, point: CGPoint, attributes: [NSAttributedString.Key : Any]?, anchor: CGPoint, angleRadians: CGFloat)
  195|      0|    {
  196|      0|        var drawOffset = CGPoint()
  197|      0|        
  198|      0|        NSUIGraphicsPushContext(context)
  199|      0|        
  200|      0|        if angleRadians != 0.0
  201|      0|        {
  202|      0|            let size = text.size(withAttributes: attributes)
  203|      0|            
  204|      0|            // Move the text drawing rect in a way that it always rotates around its center
  205|      0|            drawOffset.x = -size.width * 0.5
  206|      0|            drawOffset.y = -size.height * 0.5
  207|      0|            
  208|      0|            var translate = point
  209|      0|            
  210|      0|            // Move the "outer" rect relative to the anchor, assuming its centered
  211|      0|            if anchor.x != 0.5 || anchor.y != 0.5
  212|      0|            {
  213|      0|                let rotatedSize = size.rotatedBy(radians: angleRadians)
  214|      0|                
  215|      0|                translate.x -= rotatedSize.width * (anchor.x - 0.5)
  216|      0|                translate.y -= rotatedSize.height * (anchor.y - 0.5)
  217|      0|            }
  218|      0|            
  219|      0|            context.saveGState()
  220|      0|            context.translateBy(x: translate.x, y: translate.y)
  221|      0|            context.rotate(by: angleRadians)
  222|      0|            
  223|      0|            (text as NSString).draw(at: drawOffset, withAttributes: attributes)
  224|      0|            
  225|      0|            context.restoreGState()
  226|      0|        }
  227|      0|        else
  228|      0|        {
  229|      0|            if anchor.x != 0.0 || anchor.y != 0.0
  230|      0|            {
  231|      0|                let size = text.size(withAttributes: attributes)
  232|      0|                
  233|      0|                drawOffset.x = -size.width * anchor.x
  234|      0|                drawOffset.y = -size.height * anchor.y
  235|      0|            }
  236|      0|            
  237|      0|            drawOffset.x += point.x
  238|      0|            drawOffset.y += point.y
  239|      0|            
  240|      0|            (text as NSString).draw(at: drawOffset, withAttributes: attributes)
  241|      0|        }
  242|      0|        
  243|      0|        NSUIGraphicsPopContext()
  244|      0|    }
  245|       |    
  246|       |    internal class func drawMultilineText(context: CGContext, text: String, knownTextSize: CGSize, point: CGPoint, attributes: [NSAttributedString.Key : Any]?, constrainedToSize: CGSize, anchor: CGPoint, angleRadians: CGFloat)
  247|      0|    {
  248|      0|        var rect = CGRect(origin: CGPoint(), size: knownTextSize)
  249|      0|        
  250|      0|        NSUIGraphicsPushContext(context)
  251|      0|        
  252|      0|        if angleRadians != 0.0
  253|      0|        {
  254|      0|            // Move the text drawing rect in a way that it always rotates around its center
  255|      0|            rect.origin.x = -knownTextSize.width * 0.5
  256|      0|            rect.origin.y = -knownTextSize.height * 0.5
  257|      0|            
  258|      0|            var translate = point
  259|      0|            
  260|      0|            // Move the "outer" rect relative to the anchor, assuming its centered
  261|      0|            if anchor.x != 0.5 || anchor.y != 0.5
  262|      0|            {
  263|      0|                let rotatedSize = knownTextSize.rotatedBy(radians: angleRadians)
  264|      0|                
  265|      0|                translate.x -= rotatedSize.width * (anchor.x - 0.5)
  266|      0|                translate.y -= rotatedSize.height * (anchor.y - 0.5)
  267|      0|            }
  268|      0|            
  269|      0|            context.saveGState()
  270|      0|            context.translateBy(x: translate.x, y: translate.y)
  271|      0|            context.rotate(by: angleRadians)
  272|      0|            
  273|      0|            (text as NSString).draw(with: rect, options: .usesLineFragmentOrigin, attributes: attributes, context: nil)
  274|      0|            
  275|      0|            context.restoreGState()
  276|      0|        }
  277|      0|        else
  278|      0|        {
  279|      0|            if anchor.x != 0.0 || anchor.y != 0.0
  280|      0|            {
  281|      0|                rect.origin.x = -knownTextSize.width * anchor.x
  282|      0|                rect.origin.y = -knownTextSize.height * anchor.y
  283|      0|            }
  284|      0|            
  285|      0|            rect.origin.x += point.x
  286|      0|            rect.origin.y += point.y
  287|      0|            
  288|      0|            (text as NSString).draw(with: rect, options: .usesLineFragmentOrigin, attributes: attributes, context: nil)
  289|      0|        }
  290|      0|        
  291|      0|        NSUIGraphicsPopContext()
  292|      0|    }
  293|       |    
  294|       |    internal class func drawMultilineText(context: CGContext, text: String, point: CGPoint, attributes: [NSAttributedString.Key : Any]?, constrainedToSize: CGSize, anchor: CGPoint, angleRadians: CGFloat)
  295|      0|    {
  296|      0|        let rect = text.boundingRect(with: constrainedToSize, options: .usesLineFragmentOrigin, attributes: attributes, context: nil)
  297|      0|        drawMultilineText(context: context, text: text, knownTextSize: rect.size, point: point, attributes: attributes, constrainedToSize: constrainedToSize, anchor: anchor, angleRadians: angleRadians)
  298|      0|    }
  299|       |
  300|       |    private class func generateDefaultValueFormatter() -> IValueFormatter
  301|      0|    {
  302|      0|        let formatter = DefaultValueFormatter(decimals: 1)
  303|      0|        return formatter
  304|      0|    }
  305|       |    
  306|       |    /// - Returns: The default value formatter used for all chart components that needs a default
  307|       |    open class func defaultValueFormatter() -> IValueFormatter
  308|      0|    {
  309|      0|        return _defaultValueFormatter
  310|      0|    }
  311|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/Fill.swift:
    1|       |//
    2|       |//  Fill.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartFillType)
   16|       |public enum FillType: Int
   17|       |{
   18|       |    case empty
   19|       |    case color
   20|       |    case linearGradient
   21|       |    case radialGradient
   22|       |    case image
   23|       |    case tiledImage
   24|       |    case layer
   25|       |}
   26|       |
   27|       |@objc(ChartFill)
   28|       |open class Fill: NSObject
   29|       |{
   30|      0|    private var _type: FillType = FillType.empty
   31|       |    private var _color: CGColor?
   32|       |    private var _gradient: CGGradient?
   33|       |    private var _gradientAngle: CGFloat = 0.0
   34|      0|    private var _gradientStartOffsetPercent: CGPoint = CGPoint()
   35|       |    private var _gradientStartRadiusPercent: CGFloat = 0.0
   36|      0|    private var _gradientEndOffsetPercent: CGPoint = CGPoint()
   37|       |    private var _gradientEndRadiusPercent: CGFloat = 0.0
   38|       |    private var _image: CGImage?
   39|       |    private var _layer: CGLayer?
   40|       |    
   41|       |    // MARK: Properties
   42|       |    
   43|       |    @objc open var type: FillType
   44|      0|    {
   45|      0|        return _type
   46|      0|    }
   47|       |    
   48|       |    @objc open var color: CGColor?
   49|      0|    {
   50|      0|        return _color
   51|      0|    }
   52|       |    
   53|       |    @objc open var gradient: CGGradient?
   54|      0|    {
   55|      0|        return _gradient
   56|      0|    }
   57|       |    
   58|       |    @objc open var gradientAngle: CGFloat
   59|      0|    {
   60|      0|        return _gradientAngle
   61|      0|    }
   62|       |    
   63|       |    @objc open var gradientStartOffsetPercent: CGPoint
   64|      0|    {
   65|      0|        return _gradientStartOffsetPercent
   66|      0|    }
   67|       |    
   68|       |    @objc open var gradientStartRadiusPercent: CGFloat
   69|      0|    {
   70|      0|        return _gradientStartRadiusPercent
   71|      0|    }
   72|       |    
   73|       |    @objc open var gradientEndOffsetPercent: CGPoint
   74|      0|    {
   75|      0|        return _gradientEndOffsetPercent
   76|      0|    }
   77|       |    
   78|       |    @objc open var gradientEndRadiusPercent: CGFloat
   79|      0|    {
   80|      0|        return _gradientEndRadiusPercent
   81|      0|    }
   82|       |    
   83|       |    @objc open var image: CGImage?
   84|      0|    {
   85|      0|        return _image
   86|      0|    }
   87|       |    
   88|       |    @objc open var layer: CGLayer?
   89|      0|    {
   90|      0|        return _layer
   91|      0|    }
   92|       |    
   93|       |    // MARK: Constructors
   94|       |    
   95|       |    public override init()
   96|      0|    {
   97|      0|    }
   98|       |    
   99|       |    @objc public init(CGColor: CGColor)
  100|      0|    {
  101|      0|        _type = .color
  102|      0|        _color = CGColor
  103|      0|    }
  104|       |    
  105|       |    @objc public convenience init(color: NSUIColor)
  106|      0|    {
  107|      0|        self.init(CGColor: color.cgColor)
  108|      0|    }
  109|       |    
  110|       |    @objc public init(linearGradient: CGGradient, angle: CGFloat)
  111|      0|    {
  112|      0|        _type = .linearGradient
  113|      0|        _gradient = linearGradient
  114|      0|        _gradientAngle = angle
  115|      0|    }
  116|       |    
  117|       |    @objc public init(
  118|       |        radialGradient: CGGradient,
  119|       |        startOffsetPercent: CGPoint,
  120|       |        startRadiusPercent: CGFloat,
  121|       |        endOffsetPercent: CGPoint,
  122|       |        endRadiusPercent: CGFloat
  123|       |        )
  124|      0|    {
  125|      0|        _type = .radialGradient
  126|      0|        _gradient = radialGradient
  127|      0|        _gradientStartOffsetPercent = startOffsetPercent
  128|      0|        _gradientStartRadiusPercent = startRadiusPercent
  129|      0|        _gradientEndOffsetPercent = endOffsetPercent
  130|      0|        _gradientEndRadiusPercent = endRadiusPercent
  131|      0|    }
  132|       |    
  133|       |    @objc public convenience init(radialGradient: CGGradient)
  134|      0|    {
  135|      0|        self.init(
  136|      0|            radialGradient: radialGradient,
  137|      0|            startOffsetPercent: CGPoint(x: 0.0, y: 0.0),
  138|      0|            startRadiusPercent: 0.0,
  139|      0|            endOffsetPercent: CGPoint(x: 0.0, y: 0.0),
  140|      0|            endRadiusPercent: 1.0
  141|      0|        )
  142|      0|    }
  143|       |    
  144|       |    @objc public init(CGImage: CGImage, tiled: Bool)
  145|      0|    {
  146|      0|        _type = tiled ? .tiledImage : .image
  147|      0|        _image = CGImage
  148|      0|    }
  149|       |    
  150|       |    @objc public convenience init(image: NSUIImage, tiled: Bool)
  151|      0|    {
  152|      0|        self.init(CGImage: image.cgImage!, tiled: tiled)
  153|      0|    }
  154|       |    
  155|       |    @objc public convenience init(CGImage: CGImage)
  156|      0|    {
  157|      0|        self.init(CGImage: CGImage, tiled: false)
  158|      0|    }
  159|       |    
  160|       |    @objc public convenience init(image: NSUIImage)
  161|      0|    {
  162|      0|        self.init(image: image, tiled: false)
  163|      0|    }
  164|       |    
  165|       |    @objc public init(CGLayer: CGLayer)
  166|      0|    {
  167|      0|        _type = .layer
  168|      0|        _layer = CGLayer
  169|      0|    }
  170|       |    
  171|       |    // MARK: Constructors
  172|       |    
  173|       |    @objc open class func fillWithCGColor(_ CGColor: CGColor) -> Fill
  174|      0|    {
  175|      0|        return Fill(CGColor: CGColor)
  176|      0|    }
  177|       |    
  178|       |    @objc open class func fillWithColor(_ color: NSUIColor) -> Fill
  179|      0|    {
  180|      0|        return Fill(color: color)
  181|      0|    }
  182|       |    
  183|       |    @objc open class func fillWithLinearGradient(
  184|       |        _ linearGradient: CGGradient,
  185|       |        angle: CGFloat) -> Fill
  186|      0|    {
  187|      0|        return Fill(linearGradient: linearGradient, angle: angle)
  188|      0|    }
  189|       |    
  190|       |    @objc open class func fillWithRadialGradient(
  191|       |        _ radialGradient: CGGradient,
  192|       |        startOffsetPercent: CGPoint,
  193|       |        startRadiusPercent: CGFloat,
  194|       |        endOffsetPercent: CGPoint,
  195|       |        endRadiusPercent: CGFloat
  196|       |        ) -> Fill
  197|      0|    {
  198|      0|        return Fill(
  199|      0|            radialGradient: radialGradient,
  200|      0|            startOffsetPercent: startOffsetPercent,
  201|      0|            startRadiusPercent: startRadiusPercent,
  202|      0|            endOffsetPercent: endOffsetPercent,
  203|      0|            endRadiusPercent: endRadiusPercent
  204|      0|        )
  205|      0|    }
  206|       |    
  207|       |    @objc open class func fillWithRadialGradient(_ radialGradient: CGGradient) -> Fill
  208|      0|    {
  209|      0|        return Fill(radialGradient: radialGradient)
  210|      0|    }
  211|       |    
  212|       |    @objc open class func fillWithCGImage(_ CGImage: CGImage, tiled: Bool) -> Fill
  213|      0|    {
  214|      0|        return Fill(CGImage: CGImage, tiled: tiled)
  215|      0|    }
  216|       |    
  217|       |    @objc open class func fillWithImage(_ image: NSUIImage, tiled: Bool) -> Fill
  218|      0|    {
  219|      0|        return Fill(image: image, tiled: tiled)
  220|      0|    }
  221|       |    
  222|       |    @objc open class func fillWithCGImage(_ CGImage: CGImage) -> Fill
  223|      0|    {
  224|      0|        return Fill(CGImage: CGImage)
  225|      0|    }
  226|       |    
  227|       |    @objc open class func fillWithImage(_ image: NSUIImage) -> Fill
  228|      0|    {
  229|      0|        return Fill(image: image)
  230|      0|    }
  231|       |    
  232|       |    @objc open class func fillWithCGLayer(_ CGLayer: CGLayer) -> Fill
  233|      0|    {
  234|      0|        return Fill(CGLayer: CGLayer)
  235|      0|    }
  236|       |    
  237|       |    // MARK: Drawing code
  238|       |    
  239|       |    /// Draws the provided path in filled mode with the provided area
  240|       |    @objc open func fillPath(
  241|       |        context: CGContext,
  242|       |        rect: CGRect)
  243|      0|    {
  244|      0|        let fillType = _type
  245|      0|        if fillType == .empty
  246|      0|        {
  247|      0|            return
  248|      0|        }
  249|      0|        
  250|      0|        context.saveGState()
  251|      0|        
  252|      0|        switch fillType
  253|      0|        {
  254|      0|        case .color:
  255|      0|            
  256|      0|            context.setFillColor(_color!)
  257|      0|            context.fillPath()
  258|      0|            
  259|      0|        case .image:
  260|      0|            
  261|      0|            context.clip()
  262|      0|            context.draw(_image!, in: rect)
  263|      0|            
  264|      0|        case .tiledImage:
  265|      0|            
  266|      0|            context.clip()
  267|      0|            context.draw(_image!, in: rect, byTiling: true)
  268|      0|            
  269|      0|        case .layer:
  270|      0|            
  271|      0|            context.clip()
  272|      0|            context.draw(_layer!, in: rect)
  273|      0|            
  274|      0|        case .linearGradient:
  275|      0|            
  276|      0|            let radians = (360.0 - _gradientAngle).DEG2RAD
  277|      0|            let centerPoint = CGPoint(x: rect.midX, y: rect.midY)
  278|      0|            let xAngleDelta = cos(radians) * rect.width / 2.0
  279|      0|            let yAngleDelta = sin(radians) * rect.height / 2.0
  280|      0|            let startPoint = CGPoint(
  281|      0|                x: centerPoint.x - xAngleDelta,
  282|      0|                y: centerPoint.y - yAngleDelta
  283|      0|            )
  284|      0|            let endPoint = CGPoint(
  285|      0|                x: centerPoint.x + xAngleDelta,
  286|      0|                y: centerPoint.y + yAngleDelta
  287|      0|            )
  288|      0|            
  289|      0|            context.clip()
  290|      0|            context.drawLinearGradient(_gradient!,
  291|      0|                start: startPoint,
  292|      0|                end: endPoint,
  293|      0|                options: [.drawsAfterEndLocation, .drawsBeforeStartLocation]
  294|      0|            )
  295|      0|            
  296|      0|        case .radialGradient:
  297|      0|            
  298|      0|            let centerPoint = CGPoint(x: rect.midX, y: rect.midY)
  299|      0|            let radius = max(rect.width, rect.height) / 2.0
  300|      0|            
  301|      0|            context.clip()
  302|      0|            context.drawRadialGradient(_gradient!,
  303|      0|                startCenter: CGPoint(
  304|      0|                    x: centerPoint.x + rect.width * _gradientStartOffsetPercent.x,
  305|      0|                    y: centerPoint.y + rect.height * _gradientStartOffsetPercent.y
  306|      0|                ),
  307|      0|                startRadius: radius * _gradientStartRadiusPercent,
  308|      0|                endCenter: CGPoint(
  309|      0|                    x: centerPoint.x + rect.width * _gradientEndOffsetPercent.x,
  310|      0|                    y: centerPoint.y + rect.height * _gradientEndOffsetPercent.y
  311|      0|                ),
  312|      0|                endRadius: radius * _gradientEndRadiusPercent,
  313|      0|                options: [.drawsAfterEndLocation, .drawsBeforeStartLocation]
  314|      0|            )
  315|      0|            
  316|      0|        case .empty:
  317|      0|            break
  318|      0|        }
  319|      0|        
  320|      0|        context.restoreGState()
  321|      0|    }
  322|       |    
  323|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/Platform+Accessibility.swift:
    1|       |//
    2|       |//  Platform+Accessibility.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |
   14|       |#if os(iOS) || os(tvOS)
   15|       |#if canImport(UIKit)
   16|       |    import UIKit
   17|       |#endif
   18|       |
   19|       |internal func accessibilityPostLayoutChangedNotification(withElement element: Any? = nil)
   20|      0|{
   21|      0|    UIAccessibility.post(notification: UIAccessibility.Notification.layoutChanged, argument: element)
   22|      0|}
   23|       |
   24|       |internal func accessibilityPostScreenChangedNotification(withElement element: Any? = nil)
   25|      0|{
   26|      0|    UIAccessibility.post(notification: UIAccessibility.Notification.screenChanged, argument: element)
   27|      0|}
   28|       |
   29|       |/// A simple abstraction over UIAccessibilityElement and NSAccessibilityElement.
   30|       |open class NSUIAccessibilityElement: UIAccessibilityElement
   31|       |{
   32|       |    private weak var containerView: UIView?
   33|       |
   34|       |    final var isHeader: Bool = false
   35|       |    {
   36|       |        didSet
   37|      0|        {
   38|      0|            accessibilityTraits = isHeader ? UIAccessibilityTraits.header : UIAccessibilityTraits.none
   39|      0|        }
   40|       |    }
   41|       |
   42|       |    final var isSelected: Bool = false
   43|       |        {
   44|       |        didSet
   45|      0|        {
   46|      0|            accessibilityTraits = isSelected ? UIAccessibilityTraits.selected : UIAccessibilityTraits.none
   47|      0|        }
   48|       |    }
   49|       |
   50|       |    override public init(accessibilityContainer container: Any)
   51|      0|    {
   52|      0|        // We can force unwrap since all chart views are subclasses of UIView
   53|      0|        containerView = (container as! UIView)
   54|      0|        super.init(accessibilityContainer: container)
   55|      0|    }
   56|       |
   57|       |    override open var accessibilityFrame: CGRect
   58|       |    {
   59|       |        get
   60|      0|        {
   61|      0|            return super.accessibilityFrame
   62|      0|        }
   63|       |
   64|       |        set
   65|      0|        {
   66|      0|            guard let containerView = containerView else { return }
   67|      0|            super.accessibilityFrame = containerView.convert(newValue, to: UIScreen.main.coordinateSpace)
   68|      0|        }
   69|       |    }
   70|       |}
   71|       |
   72|       |extension NSUIView
   73|       |{
   74|       |    /// An array of accessibilityElements that is used to implement UIAccessibilityContainer internally.
   75|       |    /// Subclasses **MUST** override this with an array of such elements.
   76|       |    @objc open func accessibilityChildren() -> [Any]?
   77|      0|    {
   78|      0|        return nil
   79|      0|    }
   80|       |
   81|       |    public final override var isAccessibilityElement: Bool
   82|       |    {
   83|      0|        get { return false } // Return false here, so we can make individual elements accessible
   84|      0|        set { }
   85|       |    }
   86|       |
   87|       |    open override func accessibilityElementCount() -> Int
   88|      0|    {
   89|      0|        return accessibilityChildren()?.count ?? 0
   90|      0|    }
   91|       |
   92|       |    open override func accessibilityElement(at index: Int) -> Any?
   93|      0|    {
   94|      0|        return accessibilityChildren()?[index]
   95|      0|    }
   96|       |
   97|       |    open override func index(ofAccessibilityElement element: Any) -> Int
   98|      0|    {
   99|      0|        guard let axElement = element as? NSUIAccessibilityElement else { return NSNotFound }
  100|      0|        return (accessibilityChildren() as? [NSUIAccessibilityElement])?
  101|      0|            .firstIndex(of: axElement) ?? NSNotFound
  102|      0|    }
  103|       |}
  104|       |
  105|       |#endif
  106|       |
  107|       |#if os(OSX)
  108|       |
  109|       |#if canImport(AppKit)
  110|       |import AppKit
  111|       |#endif
  112|       |
  113|       |internal func accessibilityPostLayoutChangedNotification(withElement element: Any? = nil)
  114|       |{
  115|       |    guard let validElement = element else { return }
  116|       |    NSAccessibility.post(element: validElement, notification: .layoutChanged)
  117|       |}
  118|       |
  119|       |internal func accessibilityPostScreenChangedNotification(withElement element: Any? = nil)
  120|       |{
  121|       |    // Placeholder
  122|       |}
  123|       |
  124|       |/// A simple abstraction over UIAccessibilityElement and NSAccessibilityElement.
  125|       |open class NSUIAccessibilityElement: NSAccessibilityElement
  126|       |{
  127|       |    private weak var containerView: NSView?
  128|       |
  129|       |    final var isHeader: Bool = false
  130|       |    {
  131|       |        didSet
  132|       |        {
  133|       |            setAccessibilityRole(isHeader ? .staticText : .none)
  134|       |        }
  135|       |    }
  136|       |
  137|       |    final var isSelected: Bool = false
  138|       |    {
  139|       |        didSet
  140|       |        {
  141|       |            setAccessibilitySelected(isSelected)
  142|       |        }
  143|       |    }
  144|       |
  145|       |    open var accessibilityLabel: String
  146|       |    {
  147|       |        get
  148|       |        {
  149|       |            return accessibilityLabel() ?? ""
  150|       |        }
  151|       |
  152|       |        set
  153|       |        {
  154|       |            setAccessibilityLabel(newValue)
  155|       |        }
  156|       |    }
  157|       |
  158|       |    open var accessibilityFrame: NSRect
  159|       |    {
  160|       |        get
  161|       |        {
  162|       |            return accessibilityFrame()
  163|       |        }
  164|       |
  165|       |        set
  166|       |        {
  167|       |            guard let containerView = containerView else { return }
  168|       |
  169|       |            let bounds = NSAccessibility.screenRect(fromView: containerView, rect: newValue)
  170|       |
  171|       |            // This works, but won't auto update if the window is resized or moved.
  172|       |            // setAccessibilityFrame(bounds)
  173|       |
  174|       |            // using FrameInParentSpace allows for automatic updating of frame when windows are moved and resized.
  175|       |            // However, there seems to be a bug right now where using it causes an offset in the frame.
  176|       |            // This is a slightly hacky workaround that calculates the offset and removes it from frame calculation.
  177|       |            setAccessibilityFrameInParentSpace(bounds)
  178|       |            let axFrame = accessibilityFrame()
  179|       |            let widthOffset = abs(axFrame.origin.x - bounds.origin.x)
  180|       |            let heightOffset = abs(axFrame.origin.y - bounds.origin.y)
  181|       |            let rect = NSRect(x: bounds.origin.x - widthOffset,
  182|       |                              y: bounds.origin.y - heightOffset,
  183|       |                              width: bounds.width,
  184|       |                              height: bounds.height)
  185|       |            setAccessibilityFrameInParentSpace(rect)
  186|       |        }
  187|       |    }
  188|       |
  189|       |    public init(accessibilityContainer container: Any)
  190|       |    {
  191|       |        // We can force unwrap since all chart views are subclasses of NSView
  192|       |        containerView = (container as! NSView)
  193|       |
  194|       |        super.init()
  195|       |
  196|       |        setAccessibilityParent(containerView)
  197|       |        setAccessibilityRole(.row)
  198|       |    }
  199|       |}
  200|       |
  201|       |/// - Note: setAccessibilityRole(.list) is called at init. See Platform.swift.
  202|       |extension NSUIView: NSAccessibilityGroup
  203|       |{
  204|       |    open override func accessibilityLabel() -> String?
  205|       |    {
  206|       |        return "Chart View"
  207|       |    }
  208|       |
  209|       |    open override func accessibilityRows() -> [Any]?
  210|       |    {
  211|       |        return accessibilityChildren()
  212|       |    }
  213|       |}
  214|       |
  215|       |#endif

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/Platform+Color.swift:
    1|       |//
    2|       |//  Platform+Color.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |#if canImport(UIKit)
   13|       |import UIKit
   14|       |
   15|       |public typealias NSUIColor = UIColor
   16|       |private func fetchLabelColor() -> UIColor
   17|      0|{
   18|      0|    if #available(iOS 13, tvOS 13, *)
   19|      0|    {
   20|      0|        return .label
   21|      0|    }
   22|      0|    else
   23|      0|    {
   24|      0|        return .black
   25|      0|    }
   26|      0|}
   27|       |private let labelColor: UIColor = fetchLabelColor()
   28|       |
   29|       |extension UIColor
   30|       |{
   31|      0|    static var labelOrBlack: UIColor { labelColor }
   32|       |}
   33|       |#endif
   34|       |
   35|       |#if canImport(AppKit) && !targetEnvironment(macCatalyst)
   36|       |
   37|       |import AppKit
   38|       |
   39|       |public typealias NSUIColor = NSColor
   40|       |private func fetchLabelColor() -> NSColor
   41|       |{
   42|       |    if #available(macOS 10.14, *)
   43|       |    {
   44|       |        return .labelColor
   45|       |    }
   46|       |    else
   47|       |    {
   48|       |        return .black
   49|       |    }
   50|       |}
   51|       |private let labelColor: NSColor = fetchLabelColor()
   52|       |
   53|       |extension NSColor
   54|       |{
   55|       |    static var labelOrBlack: NSColor { labelColor }
   56|       |}
   57|       |#endif

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/Platform+Gestures.swift:
    1|       |//
    2|       |//  Platform+Gestures.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |// MARK: - UIKit
   13|       |#if canImport(UIKit)
   14|       |import UIKit
   15|       |
   16|       |public typealias NSUIGestureRecognizer = UIGestureRecognizer
   17|       |public typealias NSUIGestureRecognizerState = UIGestureRecognizer.State
   18|       |public typealias NSUIGestureRecognizerDelegate = UIGestureRecognizerDelegate
   19|       |public typealias NSUITapGestureRecognizer = UITapGestureRecognizer
   20|       |public typealias NSUIPanGestureRecognizer = UIPanGestureRecognizer
   21|       |
   22|       |extension NSUITapGestureRecognizer
   23|       |{
   24|       |    @objc final func nsuiNumberOfTouches() -> Int
   25|      0|    {
   26|      0|        return numberOfTouches
   27|      0|    }
   28|       |
   29|       |    @objc final var nsuiNumberOfTapsRequired: Int
   30|       |        {
   31|       |        get
   32|      0|        {
   33|      0|            return self.numberOfTapsRequired
   34|      0|        }
   35|       |        set
   36|      0|        {
   37|      0|            self.numberOfTapsRequired = newValue
   38|      0|        }
   39|       |    }
   40|       |}
   41|       |
   42|       |extension NSUIPanGestureRecognizer
   43|       |{
   44|       |    @objc final func nsuiNumberOfTouches() -> Int
   45|      0|    {
   46|      0|        return numberOfTouches
   47|      0|    }
   48|       |
   49|       |    @objc final func nsuiLocationOfTouch(_ touch: Int, inView: UIView?) -> CGPoint
   50|      0|    {
   51|      0|        return super.location(ofTouch: touch, in: inView)
   52|      0|    }
   53|       |}
   54|       |
   55|       |#if !os(tvOS)
   56|       |public typealias NSUIPinchGestureRecognizer = UIPinchGestureRecognizer
   57|       |public typealias NSUIRotationGestureRecognizer = UIRotationGestureRecognizer
   58|       |
   59|       |extension NSUIRotationGestureRecognizer
   60|       |{
   61|       |    @objc final var nsuiRotation: CGFloat
   62|       |        {
   63|      0|        get { return rotation }
   64|      0|        set { rotation = newValue }
   65|       |    }
   66|       |}
   67|       |
   68|       |extension NSUIPinchGestureRecognizer
   69|       |{
   70|       |    @objc final var nsuiScale: CGFloat
   71|       |        {
   72|       |        get
   73|      0|        {
   74|      0|            return scale
   75|      0|        }
   76|       |        set
   77|      0|        {
   78|      0|            scale = newValue
   79|      0|        }
   80|       |    }
   81|       |
   82|       |    @objc final func nsuiLocationOfTouch(_ touch: Int, inView: UIView?) -> CGPoint
   83|      0|    {
   84|      0|        return super.location(ofTouch: touch, in: inView)
   85|      0|    }
   86|       |}
   87|       |#endif
   88|       |#endif
   89|       |
   90|       |// MARK: - AppKit
   91|       |#if canImport(AppKit) && !targetEnvironment(macCatalyst)
   92|       |import AppKit
   93|       |
   94|       |public typealias NSUIGestureRecognizer = NSGestureRecognizer
   95|       |public typealias NSUIGestureRecognizerState = NSGestureRecognizer.State
   96|       |public typealias NSUIGestureRecognizerDelegate = NSGestureRecognizerDelegate
   97|       |public typealias NSUITapGestureRecognizer = NSClickGestureRecognizer
   98|       |public typealias NSUIPanGestureRecognizer = NSPanGestureRecognizer
   99|       |public typealias NSUIPinchGestureRecognizer = NSMagnificationGestureRecognizer
  100|       |public typealias NSUIRotationGestureRecognizer = NSRotationGestureRecognizer
  101|       |
  102|       |/** The 'tap' gesture is mapped to clicks. */
  103|       |extension NSUITapGestureRecognizer
  104|       |{
  105|       |    final func nsuiNumberOfTouches() -> Int
  106|       |    {
  107|       |        return 1
  108|       |    }
  109|       |
  110|       |    final var nsuiNumberOfTapsRequired: Int
  111|       |        {
  112|       |        get
  113|       |        {
  114|       |            return self.numberOfClicksRequired
  115|       |        }
  116|       |        set
  117|       |        {
  118|       |            self.numberOfClicksRequired = newValue
  119|       |        }
  120|       |    }
  121|       |}
  122|       |
  123|       |extension NSUIPanGestureRecognizer
  124|       |{
  125|       |    final func nsuiNumberOfTouches() -> Int
  126|       |    {
  127|       |        return 1
  128|       |    }
  129|       |
  130|       |    /// FIXME: Currently there are no more than 1 touch in OSX gestures, and not way to create custom touch gestures.
  131|       |    final func nsuiLocationOfTouch(_ touch: Int, inView: NSView?) -> NSPoint
  132|       |    {
  133|       |        return super.location(in: inView)
  134|       |    }
  135|       |}
  136|       |
  137|       |extension NSUIRotationGestureRecognizer
  138|       |{
  139|       |    /// FIXME: Currently there are no velocities in OSX gestures, and not way to create custom touch gestures.
  140|       |    final var velocity: CGFloat
  141|       |    {
  142|       |        return 0.1
  143|       |    }
  144|       |
  145|       |    final var nsuiRotation: CGFloat
  146|       |        {
  147|       |        get { return -rotation }
  148|       |        set { rotation = -newValue }
  149|       |    }
  150|       |}
  151|       |
  152|       |extension NSUIPinchGestureRecognizer
  153|       |{
  154|       |    final var nsuiScale: CGFloat
  155|       |        {
  156|       |        get
  157|       |        {
  158|       |            return magnification + 1.0
  159|       |        }
  160|       |        set
  161|       |        {
  162|       |            magnification = newValue - 1.0
  163|       |        }
  164|       |    }
  165|       |
  166|       |    /// FIXME: Currently there are no more than 1 touch in OSX gestures, and not way to create custom touch gestures.
  167|       |    final func nsuiLocationOfTouch(_ touch: Int, inView view: NSView?) -> NSPoint
  168|       |    {
  169|       |        return super.location(in: view)
  170|       |    }
  171|       |}
  172|       |#endif

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/Platform+Graphics.swift:
    1|       |//
    2|       |//  Platform+Graphics.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |enum Orientation
   13|       |{
   14|       |    case portrait, landscape
   15|       |}
   16|       |
   17|       |extension CGSize
   18|       |{
   19|      0|    var orientation: Orientation { return width > height ? .landscape : .portrait }
   20|       |}
   21|       |
   22|       |extension CGRect
   23|       |{
   24|      0|    var orientation: Orientation { size.orientation }
   25|       |}
   26|       |
   27|       |// MARK: - UIKit
   28|       |#if canImport(UIKit)
   29|       |import UIKit
   30|       |
   31|       |func NSUIGraphicsGetCurrentContext() -> CGContext?
   32|      0|{
   33|      0|    return UIGraphicsGetCurrentContext()
   34|      0|}
   35|       |
   36|       |func NSUIGraphicsGetImageFromCurrentImageContext() -> NSUIImage!
   37|      0|{
   38|      0|    return UIGraphicsGetImageFromCurrentImageContext()
   39|      0|}
   40|       |
   41|       |func NSUIGraphicsPushContext(_ context: CGContext)
   42|      0|{
   43|      0|    UIGraphicsPushContext(context)
   44|      0|}
   45|       |
   46|       |func NSUIGraphicsPopContext()
   47|      0|{
   48|      0|    UIGraphicsPopContext()
   49|      0|}
   50|       |
   51|       |func NSUIGraphicsEndImageContext()
   52|      0|{
   53|      0|    UIGraphicsEndImageContext()
   54|      0|}
   55|       |
   56|       |func NSUIImagePNGRepresentation(_ image: NSUIImage) -> Data?
   57|      0|{
   58|      0|    return image.pngData()
   59|      0|}
   60|       |
   61|       |func NSUIImageJPEGRepresentation(_ image: NSUIImage, _ quality: CGFloat = 0.8) -> Data?
   62|      0|{
   63|      0|    return image.jpegData(compressionQuality: quality)
   64|      0|}
   65|       |
   66|       |func NSUIGraphicsBeginImageContextWithOptions(_ size: CGSize, _ opaque: Bool, _ scale: CGFloat)
   67|      0|{
   68|      0|    UIGraphicsBeginImageContextWithOptions(size, opaque, scale)
   69|      0|}
   70|       |#endif
   71|       |
   72|       |// MARK: - AppKit
   73|       |#if canImport(AppKit) && !targetEnvironment(macCatalyst)
   74|       |import AppKit
   75|       |
   76|       |func NSUIGraphicsGetCurrentContext() -> CGContext?
   77|       |{
   78|       |    return NSGraphicsContext.current?.cgContext
   79|       |}
   80|       |
   81|       |func NSUIGraphicsPushContext(_ context: CGContext)
   82|       |{
   83|       |    let cx = NSGraphicsContext(cgContext: context, flipped: true)
   84|       |    NSGraphicsContext.saveGraphicsState()
   85|       |    NSGraphicsContext.current = cx
   86|       |}
   87|       |
   88|       |func NSUIGraphicsPopContext()
   89|       |{
   90|       |    NSGraphicsContext.restoreGraphicsState()
   91|       |}
   92|       |
   93|       |func NSUIImagePNGRepresentation(_ image: NSUIImage) -> Data?
   94|       |{
   95|       |    image.lockFocus()
   96|       |    let rep = NSBitmapImageRep(focusedViewRect: NSMakeRect(0, 0, image.size.width, image.size.height))
   97|       |    image.unlockFocus()
   98|       |    return rep?.representation(using: .png, properties: [:])
   99|       |}
  100|       |
  101|       |func NSUIImageJPEGRepresentation(_ image: NSUIImage, _ quality: CGFloat = 0.9) -> Data?
  102|       |{
  103|       |    image.lockFocus()
  104|       |    let rep = NSBitmapImageRep(focusedViewRect: NSMakeRect(0, 0, image.size.width, image.size.height))
  105|       |    image.unlockFocus()
  106|       |    return rep?.representation(using: .jpeg, properties: [NSBitmapImageRep.PropertyKey.compressionFactor: quality])
  107|       |}
  108|       |
  109|       |private var imageContextStack: [CGFloat] = []
  110|       |
  111|       |func NSUIGraphicsBeginImageContextWithOptions(_ size: CGSize, _ opaque: Bool, _ scale: CGFloat)
  112|       |{
  113|       |    var scale = scale
  114|       |    if scale == 0.0
  115|       |    {
  116|       |        scale = NSScreen.main?.backingScaleFactor ?? 1.0
  117|       |    }
  118|       |
  119|       |    let width = Int(size.width * scale)
  120|       |    let height = Int(size.height * scale)
  121|       |
  122|       |    if width > 0 && height > 0
  123|       |    {
  124|       |        imageContextStack.append(scale)
  125|       |
  126|       |        let colorSpace = CGColorSpaceCreateDeviceRGB()
  127|       |
  128|       |        guard let ctx = CGContext(data: nil, width: width, height: height, bitsPerComponent: 8, bytesPerRow: 4*width, space: colorSpace, bitmapInfo: (opaque ?  CGImageAlphaInfo.noneSkipFirst.rawValue : CGImageAlphaInfo.premultipliedFirst.rawValue))
  129|       |            else { return }
  130|       |
  131|       |        ctx.concatenate(CGAffineTransform(a: 1, b: 0, c: 0, d: -1, tx: 0, ty: CGFloat(height)))
  132|       |        ctx.scaleBy(x: scale, y: scale)
  133|       |        NSUIGraphicsPushContext(ctx)
  134|       |    }
  135|       |}
  136|       |
  137|       |func NSUIGraphicsGetImageFromCurrentImageContext() -> NSUIImage?
  138|       |{
  139|       |    if !imageContextStack.isEmpty
  140|       |    {
  141|       |        guard let ctx = NSUIGraphicsGetCurrentContext()
  142|       |            else { return nil }
  143|       |
  144|       |        let scale = imageContextStack.last!
  145|       |        if let theCGImage = ctx.makeImage()
  146|       |        {
  147|       |            let size = CGSize(width: CGFloat(ctx.width) / scale, height: CGFloat(ctx.height) / scale)
  148|       |            let image = NSImage(cgImage: theCGImage, size: size)
  149|       |            return image
  150|       |        }
  151|       |    }
  152|       |    return nil
  153|       |}
  154|       |
  155|       |func NSUIGraphicsEndImageContext()
  156|       |{
  157|       |    if imageContextStack.last != nil
  158|       |    {
  159|       |        imageContextStack.removeLast()
  160|       |        NSUIGraphicsPopContext()
  161|       |    }
  162|       |}
  163|       |#endif

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/Platform+Touch Handling.swift:
    1|       |//
    2|       |//  Platform+Touch Handling.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |#if canImport(UIKit)
   13|       |import UIKit
   14|       |
   15|       |public typealias NSUIEvent = UIEvent
   16|       |public typealias NSUITouch = UITouch
   17|       |
   18|       |@objc
   19|       |extension NSUIView {
   20|       |    public final override func touchesBegan(_ touches: Set<NSUITouch>, with event: NSUIEvent?)
   21|      0|    {
   22|      0|        self.nsuiTouchesBegan(touches, withEvent: event)
   23|      0|    }
   24|       |
   25|       |    public final override func touchesMoved(_ touches: Set<NSUITouch>, with event: NSUIEvent?)
   26|      0|    {
   27|      0|        self.nsuiTouchesMoved(touches, withEvent: event)
   28|      0|    }
   29|       |
   30|       |    public final override func touchesEnded(_ touches: Set<NSUITouch>, with event: NSUIEvent?)
   31|      0|    {
   32|      0|        self.nsuiTouchesEnded(touches, withEvent: event)
   33|      0|    }
   34|       |
   35|       |    public final override func touchesCancelled(_ touches: Set<NSUITouch>, with event: NSUIEvent?)
   36|      0|    {
   37|      0|        self.nsuiTouchesCancelled(touches, withEvent: event)
   38|      0|    }
   39|       |
   40|       |    open func nsuiTouchesBegan(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
   41|      0|    {
   42|      0|        super.touchesBegan(touches, with: event!)
   43|      0|    }
   44|       |
   45|       |    open func nsuiTouchesMoved(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
   46|      0|    {
   47|      0|        super.touchesMoved(touches, with: event!)
   48|      0|    }
   49|       |
   50|       |    open func nsuiTouchesEnded(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
   51|      0|    {
   52|      0|        super.touchesEnded(touches, with: event!)
   53|      0|    }
   54|       |
   55|       |    open func nsuiTouchesCancelled(_ touches: Set<NSUITouch>?, withEvent event: NSUIEvent?)
   56|      0|    {
   57|      0|        super.touchesCancelled(touches!, with: event!)
   58|      0|    }
   59|       |}
   60|       |
   61|       |extension UIView
   62|       |{
   63|       |    @objc final var nsuiGestureRecognizers: [NSUIGestureRecognizer]?
   64|      0|    {
   65|      0|        return self.gestureRecognizers
   66|      0|    }
   67|       |}
   68|       |#endif
   69|       |
   70|       |
   71|       |#if canImport(AppKit) && !targetEnvironment(macCatalyst)
   72|       |import AppKit
   73|       |
   74|       |public typealias NSUIEvent = NSEvent
   75|       |public typealias NSUITouch = NSTouch
   76|       |
   77|       |@objc
   78|       |extension NSUIView
   79|       |{
   80|       |    public final override func touchesBegan(with event: NSEvent)
   81|       |    {
   82|       |        self.nsuiTouchesBegan(event.touches(matching: .any, in: self), withEvent: event)
   83|       |    }
   84|       |
   85|       |    public final override func touchesEnded(with event: NSEvent)
   86|       |    {
   87|       |        self.nsuiTouchesEnded(event.touches(matching: .any, in: self), withEvent: event)
   88|       |    }
   89|       |
   90|       |    public final override func touchesMoved(with event: NSEvent)
   91|       |    {
   92|       |        self.nsuiTouchesMoved(event.touches(matching: .any, in: self), withEvent: event)
   93|       |    }
   94|       |
   95|       |    open override func touchesCancelled(with event: NSEvent)
   96|       |    {
   97|       |        self.nsuiTouchesCancelled(event.touches(matching: .any, in: self), withEvent: event)
   98|       |    }
   99|       |
  100|       |    open func nsuiTouchesBegan(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
  101|       |    {
  102|       |        super.touchesBegan(with: event!)
  103|       |    }
  104|       |
  105|       |    open func nsuiTouchesMoved(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
  106|       |    {
  107|       |        super.touchesMoved(with: event!)
  108|       |    }
  109|       |
  110|       |    open func nsuiTouchesEnded(_ touches: Set<NSUITouch>, withEvent event: NSUIEvent?)
  111|       |    {
  112|       |        super.touchesEnded(with: event!)
  113|       |    }
  114|       |
  115|       |    open func nsuiTouchesCancelled(_ touches: Set<NSUITouch>?, withEvent event: NSUIEvent?)
  116|       |    {
  117|       |        super.touchesCancelled(with: event!)
  118|       |    }
  119|       |}
  120|       |
  121|       |extension NSTouch
  122|       |{
  123|       |    /** Touch locations on OS X are relative to the trackpad, whereas on iOS they are actually *on* the view. */
  124|       |    func locationInView(view: NSView) -> NSPoint
  125|       |    {
  126|       |        let n = self.normalizedPosition
  127|       |        let b = view.bounds
  128|       |        return NSPoint(
  129|       |            x: b.origin.x + b.size.width * n.x,
  130|       |            y: b.origin.y + b.size.height * n.y
  131|       |        )
  132|       |    }
  133|       |}
  134|       |#endif

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/Platform.swift:
    1|       |import Foundation
    2|       |
    3|       |/** This file provides a thin abstraction layer atop of UIKit (iOS, tvOS) and Cocoa (OS X). The two APIs are very much 
    4|       | alike, and for the chart library's usage of the APIs it is often sufficient to typealias one to the other. The NSUI*
    5|       | types are aliased to either their UI* implementation (on iOS) or their NS* implementation (on OS X). */
    6|       |#if os(iOS) || os(tvOS)
    7|       |#if canImport(UIKit)
    8|       |    import UIKit
    9|       |#endif
   10|       |
   11|       |public typealias NSUIFont = UIFont
   12|       |public typealias NSUIImage = UIImage
   13|       |public typealias NSUIScrollView = UIScrollView
   14|       |public typealias NSUIScreen = UIScreen
   15|       |public typealias NSUIDisplayLink = CADisplayLink
   16|       |
   17|       |open class NSUIView: UIView
   18|       |{
   19|       |    @objc var nsuiLayer: CALayer?
   20|      0|    {
   21|      0|        return self.layer
   22|      0|    }
   23|       |}
   24|       |
   25|       |extension UIScrollView
   26|       |{
   27|       |    @objc var nsuiIsScrollEnabled: Bool
   28|       |        {
   29|      0|        get { return isScrollEnabled }
   30|      0|        set { isScrollEnabled = newValue }
   31|       |    }
   32|       |}
   33|       |
   34|       |extension UIScreen
   35|       |{
   36|       |    @objc final var nsuiScale: CGFloat
   37|      0|    {
   38|      0|        return self.scale
   39|      0|    }
   40|       |}
   41|       |
   42|       |#endif
   43|       |
   44|       |#if os(OSX)
   45|       |import Cocoa
   46|       |import Quartz
   47|       |
   48|       |public typealias NSUIFont = NSFont
   49|       |public typealias NSUIImage = NSImage
   50|       |public typealias NSUIScrollView = NSScrollView
   51|       |public typealias NSUIScreen = NSScreen
   52|       |
   53|       |/** On OS X there is no CADisplayLink. Use a 60 fps timer to render the animations. */
   54|       |public class NSUIDisplayLink
   55|       |{
   56|       |    private var timer: Timer?
   57|       |    private var displayLink: CVDisplayLink?
   58|       |    private var _timestamp: CFTimeInterval = 0.0
   59|       |
   60|       |    private weak var _target: AnyObject?
   61|       |    private var _selector: Selector
   62|       |
   63|       |    public var timestamp: CFTimeInterval
   64|       |    {
   65|       |        return _timestamp
   66|       |    }
   67|       |
   68|       |		init(target: Any, selector: Selector)
   69|       |    {
   70|       |        _target = target as AnyObject
   71|       |        _selector = selector
   72|       |
   73|       |        if CVDisplayLinkCreateWithActiveCGDisplays(&displayLink) == kCVReturnSuccess
   74|       |        {
   75|       |
   76|       |            CVDisplayLinkSetOutputCallback(displayLink!, { (displayLink, inNow, inOutputTime, flagsIn, flagsOut, userData) -> CVReturn in
   77|       |
   78|       |                let _self = unsafeBitCast(userData, to: NSUIDisplayLink.self)
   79|       |                    
   80|       |                _self._timestamp = CFAbsoluteTimeGetCurrent()
   81|       |                _self._target?.performSelector(onMainThread: _self._selector, with: _self, waitUntilDone: false)
   82|       |                    
   83|       |                return kCVReturnSuccess
   84|       |                }, Unmanaged.passUnretained(self).toOpaque())
   85|       |        }
   86|       |        else
   87|       |        {
   88|       |            timer = Timer(timeInterval: 1.0 / 60.0, target: target, selector: selector, userInfo: nil, repeats: true)
   89|       |        }
   90|       |		}
   91|       |
   92|       |    deinit
   93|       |    {
   94|       |        stop()
   95|       |    }
   96|       |
   97|       |    open func add(to runloop: RunLoop, forMode mode: RunLoop.Mode)
   98|       |    {
   99|       |        if displayLink != nil
  100|       |        {
  101|       |            CVDisplayLinkStart(displayLink!)
  102|       |        }
  103|       |        else if timer != nil
  104|       |        {
  105|       |            runloop.add(timer!, forMode: mode)
  106|       |        }
  107|       |    }
  108|       |
  109|       |    open func remove(from: RunLoop, forMode: RunLoop.Mode)
  110|       |    {
  111|       |        stop()
  112|       |    }
  113|       |
  114|       |    private func stop()
  115|       |    {
  116|       |        if displayLink != nil
  117|       |        {
  118|       |            CVDisplayLinkStop(displayLink!)
  119|       |        }
  120|       |        if timer != nil
  121|       |        {
  122|       |            timer?.invalidate()
  123|       |        }
  124|       |    }
  125|       |}
  126|       |
  127|       |extension NSView
  128|       |{
  129|       |    final var nsuiGestureRecognizers: [NSGestureRecognizer]?
  130|       |    {
  131|       |        return self.gestureRecognizers
  132|       |    }
  133|       |}
  134|       |
  135|       |extension NSScrollView
  136|       |{
  137|       |    var nsuiIsScrollEnabled: Bool
  138|       |    {
  139|       |        get { return scrollEnabled }
  140|       |        set { scrollEnabled = newValue }
  141|       |    }
  142|       |}
  143|       |
  144|       |open class NSUIView: NSView
  145|       |{
  146|       |    /// A private constant to set the accessibility role during initialization.
  147|       |    /// It ensures parity with the iOS element ordering as well as numbered counts of chart components.
  148|       |    /// (See Platform+Accessibility for details)
  149|       |    private let role: NSAccessibility.Role = .list
  150|       |
  151|       |    public override init(frame frameRect: NSRect)
  152|       |    {
  153|       |        super.init(frame: frameRect)
  154|       |        setAccessibilityRole(role)
  155|       |    }
  156|       |
  157|       |    required public init?(coder decoder: NSCoder)
  158|       |    {
  159|       |        super.init(coder: decoder)
  160|       |        setAccessibilityRole(role)
  161|       |    }
  162|       |
  163|       |    public final override var isFlipped: Bool
  164|       |    {
  165|       |        return true
  166|       |    }
  167|       |
  168|       |    func setNeedsDisplay()
  169|       |    {
  170|       |        self.setNeedsDisplay(self.bounds)
  171|       |    }
  172|       |
  173|       |
  174|       |    open var backgroundColor: NSUIColor?
  175|       |        {
  176|       |        get
  177|       |        {
  178|       |            return self.layer?.backgroundColor == nil
  179|       |                ? nil
  180|       |                : NSColor(cgColor: self.layer!.backgroundColor!)
  181|       |        }
  182|       |        set
  183|       |        {
  184|       |            self.wantsLayer = true
  185|       |            self.layer?.backgroundColor = newValue == nil ? nil : newValue!.cgColor
  186|       |        }
  187|       |    }
  188|       |
  189|       |    final var nsuiLayer: CALayer?
  190|       |    {
  191|       |        return self.layer
  192|       |    }
  193|       |}
  194|       |
  195|       |extension NSFont
  196|       |{
  197|       |    var lineHeight: CGFloat
  198|       |    {
  199|       |        // Not sure if this is right, but it looks okay
  200|       |        return self.boundingRectForFont.size.height
  201|       |    }
  202|       |}
  203|       |
  204|       |extension NSScreen
  205|       |{
  206|       |    final var nsuiScale: CGFloat
  207|       |    {
  208|       |        return self.backingScaleFactor
  209|       |    }
  210|       |}
  211|       |
  212|       |extension NSImage
  213|       |{
  214|       |    var cgImage: CGImage?
  215|       |    {
  216|       |        return self.cgImage(forProposedRect: nil, context: nil, hints: nil)
  217|       |    }
  218|       |}
  219|       |
  220|       |extension NSScrollView
  221|       |{
  222|       |    /// NOTE: Unable to disable scrolling in macOS
  223|       |    var scrollEnabled: Bool
  224|       |    {
  225|       |        get
  226|       |        {
  227|       |            return true
  228|       |        }
  229|       |        set
  230|       |        {
  231|       |        }
  232|       |    }
  233|       |}
  234|       |
  235|       |#endif
  236|       |
  237|       |extension NSUIScreen
  238|       |{
  239|      0|    class var nsuiMain: NSUIScreen? { .main }
  240|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/Transformer.swift:
    1|       |//
    2|       |//  Transformer.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// Transformer class that contains all matrices and is responsible for transforming values into pixels on the screen and backwards.
   16|       |@objc(ChartTransformer)
   17|       |open class Transformer: NSObject
   18|       |{
   19|       |    /// matrix to map the values to the screen pixels
   20|      0|    internal var _matrixValueToPx = CGAffineTransform.identity
   21|       |
   22|       |    /// matrix for handling the different offsets of the chart
   23|      0|    internal var _matrixOffset = CGAffineTransform.identity
   24|       |
   25|       |    internal var _viewPortHandler: ViewPortHandler
   26|       |
   27|       |    @objc public init(viewPortHandler: ViewPortHandler)
   28|      0|    {
   29|      0|        _viewPortHandler = viewPortHandler
   30|      0|    }
   31|       |
   32|       |    /// Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
   33|       |    @objc open func prepareMatrixValuePx(chartXMin: Double, deltaX: CGFloat, deltaY: CGFloat, chartYMin: Double)
   34|      0|    {
   35|      0|        var scaleX = (_viewPortHandler.contentWidth / deltaX)
   36|      0|        var scaleY = (_viewPortHandler.contentHeight / deltaY)
   37|      0|        
   38|      0|        if CGFloat.infinity == scaleX
   39|      0|        {
   40|      0|            scaleX = 0.0
   41|      0|        }
   42|      0|        if CGFloat.infinity == scaleY
   43|      0|        {
   44|      0|            scaleY = 0.0
   45|      0|        }
   46|      0|
   47|      0|        // setup all matrices
   48|      0|        _matrixValueToPx = CGAffineTransform.identity
   49|      0|        _matrixValueToPx = _matrixValueToPx.scaledBy(x: scaleX, y: -scaleY)
   50|      0|        _matrixValueToPx = _matrixValueToPx.translatedBy(x: CGFloat(-chartXMin), y: CGFloat(-chartYMin))
   51|      0|    }
   52|       |
   53|       |    /// Prepares the matrix that contains all offsets.
   54|       |    @objc open func prepareMatrixOffset(inverted: Bool)
   55|      0|    {
   56|      0|        if !inverted
   57|      0|        {
   58|      0|            _matrixOffset = CGAffineTransform(translationX: _viewPortHandler.offsetLeft, y: _viewPortHandler.chartHeight - _viewPortHandler.offsetBottom)
   59|      0|        }
   60|      0|        else
   61|      0|        {
   62|      0|            _matrixOffset = CGAffineTransform(scaleX: 1.0, y: -1.0)
   63|      0|            _matrixOffset = _matrixOffset.translatedBy(x: _viewPortHandler.offsetLeft, y: -_viewPortHandler.offsetTop)
   64|      0|        }
   65|      0|    }
   66|       |
   67|       |    /// Transform an array of points with all matrices.
   68|       |    // VERY IMPORTANT: Keep matrix order "value-touch-offset" when transforming.
   69|       |    open func pointValuesToPixel(_ points: inout [CGPoint])
   70|      0|    {
   71|      0|        let trans = valueToPixelMatrix
   72|      0|        points = points.map { $0.applying(trans) }
   73|      0|    }
   74|       |    
   75|       |    open func pointValueToPixel(_ point: inout CGPoint)
   76|      0|    {
   77|      0|        point = point.applying(valueToPixelMatrix)
   78|      0|    }
   79|       |    
   80|       |    @objc open func pixelForValues(x: Double, y: Double) -> CGPoint
   81|      0|    {
   82|      0|        return CGPoint(x: x, y: y).applying(valueToPixelMatrix)
   83|      0|    }
   84|       |    
   85|       |    /// Transform a rectangle with all matrices.
   86|       |    open func rectValueToPixel(_ r: inout CGRect)
   87|      0|    {
   88|      0|        r = r.applying(valueToPixelMatrix)
   89|      0|    }
   90|       |    
   91|       |    /// Transform a rectangle with all matrices with potential animation phases.
   92|       |    open func rectValueToPixel(_ r: inout CGRect, phaseY: Double)
   93|      0|    {
   94|      0|        // multiply the height of the rect with the phase
   95|      0|        var bottom = r.origin.y + r.size.height
   96|      0|        bottom *= CGFloat(phaseY)
   97|      0|        let top = r.origin.y * CGFloat(phaseY)
   98|      0|        r.size.height = bottom - top
   99|      0|        r.origin.y = top
  100|      0|
  101|      0|        r = r.applying(valueToPixelMatrix)
  102|      0|    }
  103|       |    
  104|       |    /// Transform a rectangle with all matrices.
  105|       |    open func rectValueToPixelHorizontal(_ r: inout CGRect)
  106|      0|    {
  107|      0|        r = r.applying(valueToPixelMatrix)
  108|      0|    }
  109|       |    
  110|       |    /// Transform a rectangle with all matrices with potential animation phases.
  111|       |    open func rectValueToPixelHorizontal(_ r: inout CGRect, phaseY: Double)
  112|      0|    {
  113|      0|        // multiply the height of the rect with the phase
  114|      0|        let left = r.origin.x * CGFloat(phaseY)
  115|      0|        let right = (r.origin.x + r.size.width) * CGFloat(phaseY)
  116|      0|        r.size.width = right - left
  117|      0|        r.origin.x = left
  118|      0|        
  119|      0|        r = r.applying(valueToPixelMatrix)
  120|      0|    }
  121|       |
  122|       |    /// transforms multiple rects with all matrices
  123|       |    open func rectValuesToPixel(_ rects: inout [CGRect])
  124|      0|    {
  125|      0|        let trans = valueToPixelMatrix
  126|      0|        rects = rects.map { $0.applying(trans) }
  127|      0|    }
  128|       |    
  129|       |    /// Transforms the given array of touch points (pixels) into values on the chart.
  130|       |    open func pixelsToValues(_ pixels: inout [CGPoint])
  131|      0|    {
  132|      0|        let trans = pixelToValueMatrix
  133|      0|        pixels = pixels.map { $0.applying(trans) }
  134|      0|    }
  135|       |    
  136|       |    /// Transforms the given touch point (pixels) into a value on the chart.
  137|       |    open func pixelToValues(_ pixel: inout CGPoint)
  138|      0|    {
  139|      0|        pixel = pixel.applying(pixelToValueMatrix)
  140|      0|    }
  141|       |    
  142|       |    /// - Returns: The x and y values in the chart at the given touch point
  143|       |    /// (encapsulated in a CGPoint). This method transforms pixel coordinates to
  144|       |    /// coordinates / values in the chart.
  145|       |    @objc open func valueForTouchPoint(_ point: CGPoint) -> CGPoint
  146|      0|    {
  147|      0|        return point.applying(pixelToValueMatrix)
  148|      0|    }
  149|       |    
  150|       |    /// - Returns: The x and y values in the chart at the given touch point
  151|       |    /// (x/y). This method transforms pixel coordinates to
  152|       |    /// coordinates / values in the chart.
  153|       |    @objc open func valueForTouchPoint(x: CGFloat, y: CGFloat) -> CGPoint
  154|      0|    {
  155|      0|        return CGPoint(x: x, y: y).applying(pixelToValueMatrix)
  156|      0|    }
  157|       |    
  158|       |    @objc open var valueToPixelMatrix: CGAffineTransform
  159|      0|    {
  160|      0|        return
  161|      0|            _matrixValueToPx.concatenating(_viewPortHandler.touchMatrix
  162|      0|                ).concatenating(_matrixOffset
  163|      0|        )
  164|      0|    }
  165|       |    
  166|       |    @objc open var pixelToValueMatrix: CGAffineTransform
  167|      0|    {
  168|      0|        return valueToPixelMatrix.inverted()
  169|      0|    }
  170|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/TransformerHorizontalBarChart.swift:
    1|       |//
    2|       |//  TransformerHorizontalBarChart.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |@objc(ChartTransformerHorizontalBarChart)
   16|       |open class TransformerHorizontalBarChart: Transformer
   17|       |{
   18|       |    /// Prepares the matrix that contains all offsets.
   19|       |    open override func prepareMatrixOffset(inverted: Bool)
   20|      0|    {
   21|      0|        if !inverted
   22|      0|        {
   23|      0|            _matrixOffset = CGAffineTransform(translationX: _viewPortHandler.offsetLeft, y: _viewPortHandler.chartHeight - _viewPortHandler.offsetBottom)
   24|      0|        }
   25|      0|        else
   26|      0|        {
   27|      0|            _matrixOffset = CGAffineTransform(scaleX: -1.0, y: 1.0)
   28|      0|            _matrixOffset = _matrixOffset.translatedBy(x: -(_viewPortHandler.chartWidth - _viewPortHandler.offsetRight),
   29|      0|                y: _viewPortHandler.chartHeight - _viewPortHandler.offsetBottom)
   30|      0|        }
   31|      0|    }
   32|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/Pods/Charts/Source/Charts/Utils/ViewPortHandler.swift:
    1|       |//
    2|       |//  ViewPortHandler.swift
    3|       |//  Charts
    4|       |//
    5|       |//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
    6|       |//  A port of MPAndroidChart for iOS
    7|       |//  Licensed under Apache License 2.0
    8|       |//
    9|       |//  https://github.com/danielgindi/Charts
   10|       |//
   11|       |
   12|       |import Foundation
   13|       |import CoreGraphics
   14|       |
   15|       |/// Class that contains information about the charts current viewport settings, including offsets, scale & translation levels, ...
   16|       |@objc(ChartViewPortHandler)
   17|       |open class ViewPortHandler: NSObject
   18|       |{
   19|       |    /// matrix used for touch events
   20|      0|    private var _touchMatrix = CGAffineTransform.identity
   21|       |    
   22|       |    /// this rectangle defines the area in which graph values can be drawn
   23|      0|    private var _contentRect = CGRect()
   24|       |    
   25|      0|    private var _chartWidth = CGFloat(0.0)
   26|      0|    private var _chartHeight = CGFloat(0.0)
   27|       |    
   28|       |    /// minimum scale value on the y-axis
   29|      0|    private var _minScaleY = CGFloat(1.0)
   30|       |    
   31|       |    /// maximum scale value on the y-axis
   32|      0|    private var _maxScaleY = CGFloat.greatestFiniteMagnitude
   33|       |    
   34|       |    /// minimum scale value on the x-axis
   35|      0|    private var _minScaleX = CGFloat(1.0)
   36|       |    
   37|       |    /// maximum scale value on the x-axis
   38|      0|    private var _maxScaleX = CGFloat.greatestFiniteMagnitude
   39|       |    
   40|       |    /// contains the current scale factor of the x-axis
   41|      0|    private var _scaleX = CGFloat(1.0)
   42|       |    
   43|       |    /// contains the current scale factor of the y-axis
   44|      0|    private var _scaleY = CGFloat(1.0)
   45|       |    
   46|       |    /// current translation (drag distance) on the x-axis
   47|      0|    private var _transX = CGFloat(0.0)
   48|       |    
   49|       |    /// current translation (drag distance) on the y-axis
   50|      0|    private var _transY = CGFloat(0.0)
   51|       |    
   52|       |    /// offset that allows the chart to be dragged over its bounds on the x-axis
   53|      0|    private var _transOffsetX = CGFloat(0.0)
   54|       |    
   55|       |    /// offset that allows the chart to be dragged over its bounds on the x-axis
   56|      0|    private var _transOffsetY = CGFloat(0.0)
   57|       |    
   58|       |    /// Constructor - don't forget calling setChartDimens(...)
   59|       |    @objc public init(width: CGFloat, height: CGFloat)
   60|      0|    {
   61|      0|        super.init()
   62|      0|        
   63|      0|        setChartDimens(width: width, height: height)
   64|      0|    }
   65|       |    
   66|       |    @objc open func setChartDimens(width: CGFloat, height: CGFloat)
   67|      0|    {
   68|      0|        let offsetLeft = self.offsetLeft
   69|      0|        let offsetTop = self.offsetTop
   70|      0|        let offsetRight = self.offsetRight
   71|      0|        let offsetBottom = self.offsetBottom
   72|      0|        
   73|      0|        _chartHeight = height
   74|      0|        _chartWidth = width
   75|      0|        
   76|      0|        restrainViewPort(offsetLeft: offsetLeft, offsetTop: offsetTop, offsetRight: offsetRight, offsetBottom: offsetBottom)
   77|      0|    }
   78|       |    
   79|       |    @objc open var hasChartDimens: Bool
   80|      0|    {
   81|      0|        if _chartHeight > 0.0 && _chartWidth > 0.0
   82|      0|        {
   83|      0|            return true
   84|      0|        }
   85|      0|        else
   86|      0|        {
   87|      0|            return false
   88|      0|        }
   89|      0|    }
   90|       |
   91|       |    @objc open func restrainViewPort(offsetLeft: CGFloat, offsetTop: CGFloat, offsetRight: CGFloat, offsetBottom: CGFloat)
   92|      0|    {
   93|      0|        _contentRect.origin.x = offsetLeft
   94|      0|        _contentRect.origin.y = offsetTop
   95|      0|        _contentRect.size.width = _chartWidth - offsetLeft - offsetRight
   96|      0|        _contentRect.size.height = _chartHeight - offsetBottom - offsetTop
   97|      0|    }
   98|       |    
   99|       |    @objc open var offsetLeft: CGFloat
  100|      0|    {
  101|      0|        return _contentRect.origin.x
  102|      0|    }
  103|       |    
  104|       |    @objc open var offsetRight: CGFloat
  105|      0|    {
  106|      0|        return _chartWidth - _contentRect.size.width - _contentRect.origin.x
  107|      0|    }
  108|       |    
  109|       |    @objc open var offsetTop: CGFloat
  110|      0|    {
  111|      0|        return _contentRect.origin.y
  112|      0|    }
  113|       |    
  114|       |    @objc open var offsetBottom: CGFloat
  115|      0|    {
  116|      0|        return _chartHeight - _contentRect.size.height - _contentRect.origin.y
  117|      0|    }
  118|       |    
  119|       |    @objc open var contentTop: CGFloat
  120|      0|    {
  121|      0|        return _contentRect.origin.y
  122|      0|    }
  123|       |    
  124|       |    @objc open var contentLeft: CGFloat
  125|      0|    {
  126|      0|        return _contentRect.origin.x
  127|      0|    }
  128|       |    
  129|       |    @objc open var contentRight: CGFloat
  130|      0|    {
  131|      0|        return _contentRect.origin.x + _contentRect.size.width
  132|      0|    }
  133|       |    
  134|       |    @objc open var contentBottom: CGFloat
  135|      0|    {
  136|      0|        return _contentRect.origin.y + _contentRect.size.height
  137|      0|    }
  138|       |    
  139|       |    @objc open var contentWidth: CGFloat
  140|      0|    {
  141|      0|        return _contentRect.size.width
  142|      0|    }
  143|       |    
  144|       |    @objc open var contentHeight: CGFloat
  145|      0|    {
  146|      0|        return _contentRect.size.height
  147|      0|    }
  148|       |    
  149|       |    @objc open var contentRect: CGRect
  150|      0|    {
  151|      0|        return _contentRect
  152|      0|    }
  153|       |    
  154|       |    @objc open var contentCenter: CGPoint
  155|      0|    {
  156|      0|        return CGPoint(x: _contentRect.origin.x + _contentRect.size.width / 2.0, y: _contentRect.origin.y + _contentRect.size.height / 2.0)
  157|      0|    }
  158|       |    
  159|       |    @objc open var chartHeight: CGFloat
  160|      0|    { 
  161|      0|        return _chartHeight
  162|      0|    }
  163|       |    
  164|       |    @objc open var chartWidth: CGFloat
  165|      0|    { 
  166|      0|        return _chartWidth
  167|      0|    }
  168|       |
  169|       |    // MARK: - Scaling/Panning etc.
  170|       |    
  171|       |    /// Zooms by the specified zoom factors.
  172|       |    @objc open func zoom(scaleX: CGFloat, scaleY: CGFloat) -> CGAffineTransform
  173|      0|    {
  174|      0|        return _touchMatrix.scaledBy(x: scaleX, y: scaleY)
  175|      0|    }
  176|       |    
  177|       |    /// Zooms around the specified center
  178|       |    @objc open func zoom(scaleX: CGFloat, scaleY: CGFloat, x: CGFloat, y: CGFloat) -> CGAffineTransform
  179|      0|    {
  180|      0|        var matrix = _touchMatrix.translatedBy(x: x, y: y)
  181|      0|        matrix = matrix.scaledBy(x: scaleX, y: scaleY)
  182|      0|        matrix = matrix.translatedBy(x: -x, y: -y)
  183|      0|        return matrix
  184|      0|    }
  185|       |    
  186|       |    /// Zooms in by 1.4, x and y are the coordinates (in pixels) of the zoom center.
  187|       |    @objc open func zoomIn(x: CGFloat, y: CGFloat) -> CGAffineTransform
  188|      0|    {
  189|      0|        return zoom(scaleX: 1.4, scaleY: 1.4, x: x, y: y)
  190|      0|    }
  191|       |    
  192|       |    /// Zooms out by 0.7, x and y are the coordinates (in pixels) of the zoom center.
  193|       |    @objc open func zoomOut(x: CGFloat, y: CGFloat) -> CGAffineTransform
  194|      0|    {
  195|      0|        return zoom(scaleX: 0.7, scaleY: 0.7, x: x, y: y)
  196|      0|    }
  197|       |    
  198|       |    /// Zooms out to original size.
  199|       |    @objc open func resetZoom() -> CGAffineTransform
  200|      0|    {
  201|      0|        return zoom(scaleX: 1.0, scaleY: 1.0, x: 0.0, y: 0.0)
  202|      0|    }
  203|       |    
  204|       |    /// Sets the scale factor to the specified values.
  205|       |    @objc open func setZoom(scaleX: CGFloat, scaleY: CGFloat) -> CGAffineTransform
  206|      0|    {
  207|      0|        var matrix = _touchMatrix
  208|      0|        matrix.a = scaleX
  209|      0|        matrix.d = scaleY
  210|      0|        return matrix
  211|      0|    }
  212|       |    
  213|       |    /// Sets the scale factor to the specified values. x and y is pivot.
  214|       |    @objc open func setZoom(scaleX: CGFloat, scaleY: CGFloat, x: CGFloat, y: CGFloat) -> CGAffineTransform
  215|      0|    {
  216|      0|        var matrix = _touchMatrix
  217|      0|        matrix.a = 1.0
  218|      0|        matrix.d = 1.0
  219|      0|        matrix = matrix.translatedBy(x: x, y: y)
  220|      0|        matrix = matrix.scaledBy(x: scaleX, y: scaleY)
  221|      0|        matrix = matrix.translatedBy(x: -x, y: -y)
  222|      0|        return matrix
  223|      0|    }
  224|       |    
  225|       |    /// Resets all zooming and dragging and makes the chart fit exactly it's bounds.
  226|       |    @objc open func fitScreen() -> CGAffineTransform
  227|      0|    {
  228|      0|        _minScaleX = 1.0
  229|      0|        _minScaleY = 1.0
  230|      0|
  231|      0|        return CGAffineTransform.identity
  232|      0|    }
  233|       |    
  234|       |    /// Translates to the specified point.
  235|       |    @objc open func translate(pt: CGPoint) -> CGAffineTransform
  236|      0|    {
  237|      0|        let translateX = pt.x - offsetLeft
  238|      0|        let translateY = pt.y - offsetTop
  239|      0|        
  240|      0|        let matrix = _touchMatrix.concatenating(CGAffineTransform(translationX: -translateX, y: -translateY))
  241|      0|        
  242|      0|        return matrix
  243|      0|    }
  244|       |    
  245|       |    /// Centers the viewport around the specified position (x-index and y-value) in the chart.
  246|       |    /// Centering the viewport outside the bounds of the chart is not possible.
  247|       |    /// Makes most sense in combination with the setScaleMinima(...) method.
  248|       |    @objc open func centerViewPort(pt: CGPoint, chart: ChartViewBase)
  249|      0|    {
  250|      0|        let translateX = pt.x - offsetLeft
  251|      0|        let translateY = pt.y - offsetTop
  252|      0|        
  253|      0|        let matrix = _touchMatrix.concatenating(CGAffineTransform(translationX: -translateX, y: -translateY))
  254|      0|        refresh(newMatrix: matrix, chart: chart, invalidate: true)
  255|      0|    }
  256|       |    
  257|       |    /// call this method to refresh the graph with a given matrix
  258|       |    @objc @discardableResult open func refresh(newMatrix: CGAffineTransform, chart: ChartViewBase, invalidate: Bool) -> CGAffineTransform
  259|      0|    {
  260|      0|        _touchMatrix = newMatrix
  261|      0|        
  262|      0|        // make sure scale and translation are within their bounds
  263|      0|        limitTransAndScale(matrix: &_touchMatrix, content: _contentRect)
  264|      0|        
  265|      0|        chart.setNeedsDisplay()
  266|      0|        
  267|      0|        return _touchMatrix
  268|      0|    }
  269|       |    
  270|       |    /// limits the maximum scale and X translation of the given matrix
  271|       |    private func limitTransAndScale(matrix: inout CGAffineTransform, content: CGRect?)
  272|      0|    {
  273|      0|        // min scale-x is 1
  274|      0|        _scaleX = min(max(_minScaleX, matrix.a), _maxScaleX)
  275|      0|        
  276|      0|        // min scale-y is 1
  277|      0|        _scaleY = min(max(_minScaleY,  matrix.d), _maxScaleY)
  278|      0|        
  279|      0|        
  280|      0|        var width: CGFloat = 0.0
  281|      0|        var height: CGFloat = 0.0
  282|      0|        
  283|      0|        if content != nil
  284|      0|        {
  285|      0|            width = content!.width
  286|      0|            height = content!.height
  287|      0|        }
  288|      0|        
  289|      0|        let maxTransX = -width * (_scaleX - 1.0)
  290|      0|        _transX = min(max(matrix.tx, maxTransX - _transOffsetX), _transOffsetX)
  291|      0|        
  292|      0|        let maxTransY = height * (_scaleY - 1.0)
  293|      0|        _transY = max(min(matrix.ty, maxTransY + _transOffsetY), -_transOffsetY)
  294|      0|        
  295|      0|        matrix.tx = _transX
  296|      0|        matrix.a = _scaleX
  297|      0|        matrix.ty = _transY
  298|      0|        matrix.d = _scaleY
  299|      0|    }
  300|       |    
  301|       |    /// Sets the minimum scale factor for the x-axis
  302|       |    @objc open func setMinimumScaleX(_ xScale: CGFloat)
  303|      0|    {
  304|      0|        var newValue = xScale
  305|      0|        
  306|      0|        if newValue < 1.0
  307|      0|        {
  308|      0|            newValue = 1.0
  309|      0|        }
  310|      0|        
  311|      0|        _minScaleX = newValue
  312|      0|        
  313|      0|        limitTransAndScale(matrix: &_touchMatrix, content: _contentRect)
  314|      0|    }
  315|       |    
  316|       |    /// Sets the maximum scale factor for the x-axis
  317|       |    @objc open func setMaximumScaleX(_ xScale: CGFloat)
  318|      0|    {
  319|      0|        var newValue = xScale
  320|      0|        
  321|      0|        if newValue == 0.0
  322|      0|        {
  323|      0|            newValue = CGFloat.greatestFiniteMagnitude
  324|      0|        }
  325|      0|        
  326|      0|        _maxScaleX = newValue
  327|      0|        
  328|      0|        limitTransAndScale(matrix: &_touchMatrix, content: _contentRect)
  329|      0|    }
  330|       |    
  331|       |    /// Sets the minimum and maximum scale factors for the x-axis
  332|       |    @objc open func setMinMaxScaleX(minScaleX: CGFloat, maxScaleX: CGFloat)
  333|      0|    {
  334|      0|        var newMin = minScaleX
  335|      0|        var newMax = maxScaleX
  336|      0|        
  337|      0|        if newMin < 1.0
  338|      0|        {
  339|      0|            newMin = 1.0
  340|      0|        }
  341|      0|        if newMax == 0.0
  342|      0|        {
  343|      0|            newMax = CGFloat.greatestFiniteMagnitude
  344|      0|        }
  345|      0|        
  346|      0|        _minScaleX = newMin
  347|      0|        _maxScaleX = maxScaleX
  348|      0|        
  349|      0|        limitTransAndScale(matrix: &_touchMatrix, content: _contentRect)
  350|      0|    }
  351|       |    
  352|       |    /// Sets the minimum scale factor for the y-axis
  353|       |    @objc open func setMinimumScaleY(_ yScale: CGFloat)
  354|      0|    {
  355|      0|        var newValue = yScale
  356|      0|        
  357|      0|        if newValue < 1.0
  358|      0|        {
  359|      0|            newValue = 1.0
  360|      0|        }
  361|      0|        
  362|      0|        _minScaleY = newValue
  363|      0|        
  364|      0|        limitTransAndScale(matrix: &_touchMatrix, content: _contentRect)
  365|      0|    }
  366|       |    
  367|       |    /// Sets the maximum scale factor for the y-axis
  368|       |    @objc open func setMaximumScaleY(_ yScale: CGFloat)
  369|      0|    {
  370|      0|        var newValue = yScale
  371|      0|        
  372|      0|        if newValue == 0.0
  373|      0|        {
  374|      0|            newValue = CGFloat.greatestFiniteMagnitude
  375|      0|        }
  376|      0|        
  377|      0|        _maxScaleY = newValue
  378|      0|        
  379|      0|        limitTransAndScale(matrix: &_touchMatrix, content: _contentRect)
  380|      0|    }
  381|       |    
  382|       |    @objc open func setMinMaxScaleY(minScaleY: CGFloat, maxScaleY: CGFloat)
  383|      0|    {
  384|      0|        var minScaleY = minScaleY, maxScaleY = maxScaleY
  385|      0|        
  386|      0|        if minScaleY < 1.0
  387|      0|        {
  388|      0|            minScaleY = 1.0
  389|      0|        }
  390|      0|        
  391|      0|        if maxScaleY == 0.0
  392|      0|        {
  393|      0|            maxScaleY = CGFloat.greatestFiniteMagnitude
  394|      0|        }
  395|      0|        
  396|      0|        _minScaleY = minScaleY
  397|      0|        _maxScaleY = maxScaleY
  398|      0|        
  399|      0|        limitTransAndScale(matrix: &_touchMatrix, content: _contentRect)
  400|      0|    }
  401|       |
  402|       |    @objc open var touchMatrix: CGAffineTransform
  403|      0|    {
  404|      0|        return _touchMatrix
  405|      0|    }
  406|       |    
  407|       |    // MARK: - Boundaries Check
  408|       |    
  409|       |    @objc open func isInBoundsX(_ x: CGFloat) -> Bool
  410|      0|    {
  411|      0|        return isInBoundsLeft(x) && isInBoundsRight(x)
  412|      0|    }
  413|       |    
  414|       |    @objc open func isInBoundsY(_ y: CGFloat) -> Bool
  415|      0|    {
  416|      0|        return isInBoundsTop(y) && isInBoundsBottom(y)
  417|      0|    }
  418|       |    
  419|       |    /**
  420|       |     A method to check whether coordinate lies within the viewport.
  421|       |     
  422|       |     - Parameters:
  423|       |         - point: a coordinate.
  424|       |     */
  425|       |    @objc open func isInBounds(point: CGPoint) -> Bool
  426|      0|    {
  427|      0|        return isInBounds(x: point.x, y: point.y)
  428|      0|    }
  429|       |    
  430|       |    @objc open func isInBounds(x: CGFloat, y: CGFloat) -> Bool
  431|      0|    {
  432|      0|        return isInBoundsX(x) && isInBoundsY(y)
  433|      0|    }
  434|       |    
  435|       |    @objc open func isInBoundsLeft(_ x: CGFloat) -> Bool
  436|      0|    {
  437|      0|        return _contentRect.origin.x <= x + 1.0
  438|      0|    }
  439|       |    
  440|       |    @objc open func isInBoundsRight(_ x: CGFloat) -> Bool
  441|      0|    {
  442|      0|        let x = floor(x * 100.0) / 100.0
  443|      0|        return (_contentRect.origin.x + _contentRect.size.width) >= x - 1.0
  444|      0|    }
  445|       |    
  446|       |    @objc open func isInBoundsTop(_ y: CGFloat) -> Bool
  447|      0|    {
  448|      0|        return _contentRect.origin.y <= y
  449|      0|    }
  450|       |    
  451|       |    @objc open func isInBoundsBottom(_ y: CGFloat) -> Bool
  452|      0|    {
  453|      0|        let normalizedY = floor(y * 100.0) / 100.0
  454|      0|        return (_contentRect.origin.y + _contentRect.size.height) >= normalizedY
  455|      0|    }
  456|       |    
  457|       |    /**
  458|       |     A method to check whether a line between two coordinates intersects with the view port  by using a linear function.
  459|       |     
  460|       |        Linear function (calculus): `y = ax + b`
  461|       |            
  462|       |        Note: this method will not check for collision with the right edge of the view port, as we assume lines run from left
  463|       |        to right (e.g. `startPoint < endPoint`).
  464|       |     
  465|       |     - Parameters:
  466|       |        - startPoint: the start coordinate of the line.
  467|       |        - endPoint: the end coordinate of the line.
  468|       |     */
  469|       |    @objc open func isIntersectingLine(from startPoint: CGPoint, to endPoint: CGPoint) -> Bool
  470|      0|    {
  471|      0|        // If start- and/or endpoint fall within the viewport, bail out early.
  472|      0|        if isInBounds(point: startPoint) || isInBounds(point: endPoint) { return true }
  473|      0|        // check if x in bound when it's a vertical line
  474|      0|        if startPoint.x == endPoint.x { return isInBoundsX(startPoint.x) }
  475|      0|        
  476|      0|        // Calculate the slope (`a`) of the line (e.g. `a = (y2 - y1) / (x2 - x1)`).
  477|      0|        let a = (endPoint.y - startPoint.y) / (endPoint.x - startPoint.x)
  478|      0|        // Calculate the y-correction (`b`) of the line (e.g. `b = y1 - (a * x1)`).
  479|      0|        let b = startPoint.y - (a * startPoint.x)
  480|      0|        
  481|      0|        // Check for colission with the left edge of the view port (e.g. `y = (a * minX) + b`).
  482|      0|        // if a is 0, it's a horizontal line; checking b here is still valid, as b is `point.y` all the time
  483|      0|        if isInBoundsY((a * contentRect.minX) + b) { return true }
  484|      0|
  485|      0|        // Skip unnecessary check for collision with the right edge of the view port
  486|      0|        // (e.g. `y = (a * maxX) + b`), as such a line will either begin inside the view port,
  487|      0|        // or intersect the left, top or bottom edges of the view port. Leaving this logic here for clarity's sake:
  488|      0|        // if isInBoundsY((a * contentRect.maxX) + b) { return true }
  489|      0|        
  490|      0|        // While slope `a` can theoretically never be `0`, we should protect against division by zero.
  491|      0|        guard a != 0 else { return false }
  492|      0|        
  493|      0|        // Check for collision with the bottom edge of the view port (e.g. `x = (maxY - b) / a`).
  494|      0|        if isInBoundsX((contentRect.maxY - b) / a) { return true }
  495|      0|        
  496|      0|        // Check for collision with the top edge of the view port (e.g. `x = (minY - b) / a`).
  497|      0|        if isInBoundsX((contentRect.minY - b) / a) { return true }
  498|      0|
  499|      0|        // This line does not intersect the view port.
  500|      0|        return false
  501|      0|    }
  502|       |    
  503|       |    /// The current x-scale factor
  504|       |    @objc open var scaleX: CGFloat
  505|      0|    {
  506|      0|        return _scaleX
  507|      0|    }
  508|       |    
  509|       |    /// The current y-scale factor
  510|       |    @objc open var scaleY: CGFloat
  511|      0|    {
  512|      0|        return _scaleY
  513|      0|    }
  514|       |    
  515|       |    /// The minimum x-scale factor
  516|       |    @objc open var minScaleX: CGFloat
  517|      0|    {
  518|      0|        return _minScaleX
  519|      0|    }
  520|       |    
  521|       |    /// The minimum y-scale factor
  522|       |    @objc open var minScaleY: CGFloat
  523|      0|    {
  524|      0|        return _minScaleY
  525|      0|    }
  526|       |    
  527|       |    /// The minimum x-scale factor
  528|       |    @objc open var maxScaleX: CGFloat
  529|      0|    {
  530|      0|        return _maxScaleX
  531|      0|    }
  532|       |    
  533|       |    /// The minimum y-scale factor
  534|       |    @objc open var maxScaleY: CGFloat
  535|      0|    {
  536|      0|        return _maxScaleY
  537|      0|    }
  538|       |    
  539|       |    /// The translation (drag / pan) distance on the x-axis
  540|       |    @objc open var transX: CGFloat
  541|      0|    {
  542|      0|        return _transX
  543|      0|    }
  544|       |    
  545|       |    /// The translation (drag / pan) distance on the y-axis
  546|       |    @objc open var transY: CGFloat
  547|      0|    {
  548|      0|        return _transY
  549|      0|    }
  550|       |    
  551|       |    /// if the chart is fully zoomed out, return true
  552|       |    @objc open var isFullyZoomedOut: Bool
  553|      0|    {
  554|      0|        return isFullyZoomedOutX && isFullyZoomedOutY
  555|      0|    }
  556|       |    
  557|       |    /// `true` if the chart is fully zoomed out on it's y-axis (vertical).
  558|       |    @objc open var isFullyZoomedOutY: Bool
  559|      0|    {
  560|      0|        return !(_scaleY > _minScaleY || _minScaleY > 1.0)
  561|      0|    }
  562|       |    
  563|       |    /// `true` if the chart is fully zoomed out on it's x-axis (horizontal).
  564|       |    @objc open var isFullyZoomedOutX: Bool
  565|      0|    {
  566|      0|        return !(_scaleX > _minScaleX || _minScaleX > 1.0)
  567|      0|    }
  568|       |    
  569|       |    /// Set an offset in pixels that allows the user to drag the chart over it's bounds on the x-axis.
  570|       |    @objc open func setDragOffsetX(_ offset: CGFloat)
  571|      0|    {
  572|      0|        _transOffsetX = offset
  573|      0|    }
  574|       |    
  575|       |    /// Set an offset in pixels that allows the user to drag the chart over it's bounds on the y-axis.
  576|       |    @objc open func setDragOffsetY(_ offset: CGFloat)
  577|      0|    {
  578|      0|        _transOffsetY = offset
  579|      0|    }
  580|       |    
  581|       |    /// `true` if both drag offsets (x and y) are zero or smaller.
  582|       |    @objc open var hasNoDragOffset: Bool
  583|      0|    {
  584|      0|        return _transOffsetX <= 0.0 && _transOffsetY <= 0.0
  585|      0|    }
  586|       |    
  587|       |    /// `true` if the chart is not yet fully zoomed out on the x-axis
  588|       |    @objc open var canZoomOutMoreX: Bool
  589|      0|    {
  590|      0|        return _scaleX > _minScaleX
  591|      0|    }
  592|       |    
  593|       |    /// `true` if the chart is not yet fully zoomed in on the x-axis
  594|       |    @objc open var canZoomInMoreX: Bool
  595|      0|    {
  596|      0|        return _scaleX < _maxScaleX
  597|      0|    }
  598|       |    
  599|       |    /// `true` if the chart is not yet fully zoomed out on the y-axis
  600|       |    @objc open var canZoomOutMoreY: Bool
  601|      0|    {
  602|      0|        return _scaleY > _minScaleY
  603|      0|    }
  604|       |    
  605|       |    /// `true` if the chart is not yet fully zoomed in on the y-axis
  606|       |    @objc open var canZoomInMoreY: Bool
  607|      0|    {
  608|      0|        return _scaleY < _maxScaleY
  609|      0|    }
  610|       |}

