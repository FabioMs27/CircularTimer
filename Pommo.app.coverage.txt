/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/AppDelegate/AppDelegate.swift:
    1|       |//
    2|       |//  AppDelegate.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 27/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import CoreData
   11|       |
   12|       |@UIApplicationMain
   13|       |class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate {
   14|       |    
   15|      0|    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
   16|      0|        // Override point for customization after application launch.
   17|      0|//        AppNotificationBO.shared.requestAuthorazition()
   18|      0|        UNUserNotificationCenter.current().delegate = self
   19|      0|        return true
   20|      0|    }
   21|       |    
   22|      0|    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
   23|      0|        //Handle the notification
   24|      0|        completionHandler(
   25|      0|            [UNNotificationPresentationOptions.alert,
   26|      0|             UNNotificationPresentationOptions.sound,
   27|      0|             UNNotificationPresentationOptions.badge])
   28|      0|    }
   29|       |    
   30|       |    // MARK: UISceneSession Lifecycle
   31|       |    
   32|      0|    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
   33|      0|        // Called when a new scene session is being created.
   34|      0|        // Use this method to select a configuration to create the new scene with.
   35|      0|        
   36|      0|        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
   37|      0|    }
   38|       |    
   39|      0|    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
   40|      0|        // Called when the user discards a scene session.
   41|      0|        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
   42|      0|        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
   43|      0|    }
   44|       |}
   45|       |
   46|       |

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/AppDelegate/SceneDelegate.swift:
    1|       |//
    2|       |//  SceneDelegate.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 27/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class SceneDelegate: UIResponder, UIWindowSceneDelegate {
   12|       |
   13|       |    var window: UIWindow?
   14|       |    
   15|       |    var timer: TimeTrackerBO?
   16|       |    
   17|       |    var ringView: AnimatedRingView?
   18|       |    
   19|       |    var timeRecover: TimeRecoverBO?
   20|       |
   21|      0|    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
   22|      0|        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
   23|      0|        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
   24|      0|        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
   25|      0|
   26|      0|        guard let _ = (scene as? UIWindowScene) else { return }
   27|      0|    }
   28|       |
   29|      0|    func sceneDidDisconnect(_ scene: UIScene) {
   30|      0|        // Called as the scene is being released by the system.
   31|      0|        // This occurs shortly after the scene enters the background, or when its session is discarded.
   32|      0|        // Release any resources associated with this scene that can be re-created the next time the scene connects.
   33|      0|        // The scene may re-connect later, as its session was not neccessarily discarded (see `application:didDiscardSceneSessions` instead).
   34|      0|
   35|      0|    }
   36|       |
   37|      0|    func sceneDidBecomeActive(_ scene: UIScene) {
   38|      0|        // Called when the scene has moved from an inactive state to an active state.
   39|      0|        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
   40|      0|
   41|      0|    }
   42|       |
   43|      0|    func sceneWillResignActive(_ scene: UIScene) {
   44|      0|        // Called when the scene will move from an active state to an inactive state.
   45|      0|        // This may occur due to temporary interruptions (ex. an incoming phone call).
   46|      0|        
   47|      0|    }
   48|       |
   49|      0|    func sceneWillEnterForeground(_ scene: UIScene) {
   50|      0|        // Called as the scene transitions from the background to the foreground.
   51|      0|        // Use this method to undo the changes made on entering the background.
   52|      0|        
   53|      0|        AppNotificationBO.shared.resetBagde()
   54|      0|
   55|      0|        guard let timeRecover = self.timeRecover else {
   56|      0|            return
   57|      0|        }
   58|      0|        
   59|      0|        timeRecover.returnFromBackground()
   60|      0|        
   61|      0|        
   62|      0|        guard let view = self.ringView else{return}
   63|      0|        guard let t = timer else{return}
   64|      0|        if !view.isRunning{return}
   65|      0|        
   66|      0|        let startValue = view.calculateStartingPoint(With: CGFloat(t.countDown), And: 1)
   67|      0|        let startAngle = view.calculateStartingPoint(With: CGFloat(t.countDown), And: (2 * CGFloat.pi))
   68|      0|        view.animateRing(From: startValue, FromAngle: startAngle, To: 1, Duration: CFTimeInterval(t.countDown))
   69|      0|    }
   70|       |
   71|      0|    func sceneDidEnterBackground(_ scene: UIScene) {
   72|      0|        // Called as the scene transitions from the foreground to the background.
   73|      0|        // Use this method to save data, release shared resources, and store enough scene-specific state information
   74|      0|        // to restore the scene back to its current state.
   75|      0|
   76|      0|        // Save changes in the application's managed object context when the application transitions to the background.
   77|      0|        
   78|      0|        CDManager.shared.saveContext()
   79|      0|
   80|      0|        guard let timeRecover = self.timeRecover else {
   81|      0|            return
   82|      0|        }
   83|      0|        
   84|      0|        guard let t = timer else {return}
   85|      0|        if t.timer.isValid{
   86|      0|//            AppNotificationBO.shared.sendNotification(type: .didLoseFocus)
   87|      0|            AppNotificationBO.shared.registerBgTask(timeRecover: timeRecover)
   88|      0|            timeRecover.enterbackground()
   89|      0|        }
   90|      0|    }
   91|       |    
   92|       |}
   93|       |

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/BO/AppNotificationBO.swift:
    1|       |//
    2|       |//  NotificationBO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 04/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import NotificationCenter
   10|       |import UserNotifications
   11|       |import Foundation
   12|       |
   13|       |enum NotificationType: String {
   14|       |    case didFinishFocus, didFinishBreak, didLoseFocus, comeBackToTheApp
   15|       |}
   16|       |
   17|       |enum ActionNotification: String {
   18|       |    case beginBreak, beginFocus
   19|       |}
   20|       |
   21|      0|class AppNotificationBO: NSObject {
   22|       |    
   23|       |    //MARK:- Singleton setup
   24|       |    static let shared = AppNotificationBO()
   25|      0|    
   26|      0|    private override init() {
   27|      0|        super.init()
   28|      0|        UNUserNotificationCenter.current().delegate = self
   29|      0|//        configureCategory()
   30|      0|    }
   31|       |    
   32|       |    //MARK:- Attributes
   33|      0|    private var badgeNumber: Int {
   34|       |        get {
   35|       |            UIApplication.shared.applicationIconBadgeNumber
   36|      0|        }
   37|      0|        set {
   38|      0|            UIApplication.shared.applicationIconBadgeNumber = newValue
   39|      0|        }
   40|      0|    }
   41|      0|    
   42|      0|    let notificationCenter = UNUserNotificationCenter.current()
   43|      0|    
   44|      0|    var bgTask = UIBackgroundTaskIdentifier.invalid
   45|       |    
   46|      0|    func sendNotification(type: NotificationType, delay: TimeInterval = 2) {
   47|      0|        var localizedTitle: String?
   48|      0|        var localizedBody: String?
   49|      0|        switch type {
   50|      0|        case .didLoseFocus:
   51|      0|            localizedTitle = NSLocalizedString("Lost Focus Notification", comment: "")
   52|      0|            localizedBody = NSLocalizedString("Lost Focus Body", comment: "")
   53|      0|        case .didFinishFocus:
   54|      0|            localizedTitle = NSLocalizedString("End Focus Notification", comment: "")
   55|      0|            localizedBody = NSLocalizedString("End Focus Body", comment: "")
   56|      0|        case .didFinishBreak:
   57|      0|            localizedTitle = NSLocalizedString("Break Notification", comment: "")
   58|      0|            localizedBody = NSLocalizedString("Break Body", comment: "")
   59|      0|        case .comeBackToTheApp:
   60|      0|            localizedTitle = NSLocalizedString("Long Time Notification", comment: "")
   61|      0|            localizedBody = NSLocalizedString("Long Time Body", comment: "")
   62|      0|            
   63|      0|        }
   64|      0|        if let title = localizedBody,
   65|      0|            let body = localizedTitle{
   66|      0|            sendNotification(title: title, subtitle: "", body: body, category: type, delay: delay)
   67|      0|        }
   68|      0|    }
   69|       |    
   70|      0|    func resetBagde() {
   71|      0|        DispatchQueue.main.async {
   72|      0|            self.badgeNumber = 0
   73|      0|        }
   74|      0|    }
   75|      0|    
   76|      0|}
   77|      0|
   78|      0|extension AppNotificationBO {
   79|      0|
   80|      0|    func requestAuthorazition() {
   81|      0|        let options: UNAuthorizationOptions = [.alert, .sound, .badge]
   82|      0|        
   83|      0|        notificationCenter.requestAuthorization(options: options) { (didAllow, error) in
   84|      0|            if !didAllow {
   85|      0|                print("User has declined notifications")
   86|      0|            }
   87|      0|        }
   88|      0|    }
   89|      0|    
   90|      0|    private func checkAuthorization(completion: @escaping (Bool) -> Void) {
   91|      0|        notificationCenter.getNotificationSettings { settings in
   92|       |            guard settings.authorizationStatus == .authorized else {
   93|      0|                print("Notifications Denied")
   94|      0|                completion(false)
   95|      0|                return
   96|      0|            }
   97|      0|            completion(true)
   98|       |        }
   99|      0|    }
  100|      0|    
  101|      0|    private func sendNotification(title: String, subtitle: String, body: String, category: NotificationType? = .none, delay: TimeInterval? = 0, repeats: Bool? = false) {
  102|      0|        
  103|      0|        checkAuthorization() { allow in
  104|      0|            guard allow else { return }
  105|      0|            
  106|      0|            let notificationContent = UNMutableNotificationContent()
  107|      0|            notificationContent.title = title
  108|      0|            notificationContent.subtitle = subtitle
  109|       |            notificationContent.body = body
  110|       |            notificationContent.sound = UNNotificationSound.default
  111|      0|            print(notificationContent.categoryIdentifier)
  112|       |            notificationContent.categoryIdentifier = category!.rawValue
  113|      0|
  114|      0|            DispatchQueue.main.async {
  115|      0|                notificationContent.badge = NSNumber(value: self.badgeNumber + 1)
  116|      0|            }
  117|      0|            
  118|      0|            //            let t = UNCalendarNotificationTrigger(dateMatching: DateComponents, repeats: false) // Agendar notificação para a próxima hora == dateMatching
  119|      0|            let trigger = UNTimeIntervalNotificationTrigger(timeInterval: delay!, repeats: repeats!)
  120|      0|            let request = UNNotificationRequest(identifier: UUID().uuidString, content: notificationContent, trigger: trigger)
  121|      0|            
  122|      0|            self.notificationCenter.add(request)
  123|      0|        }
  124|      0|    }
  125|      0|
  126|      0|    private func configureCategory() {
  127|      0|        // Define Actions
  128|      0|        let beginFocus = UNNotificationAction(identifier: ActionNotification.beginFocus.rawValue, title: "Iniciar foco", options: [])
  129|       |        let beginBreak = UNNotificationAction(identifier: ActionNotification.beginBreak.rawValue, title: "Iniciar pausa", options: [])
  130|      0|
  131|      0|        // Define Category
  132|      0|        let focusCategory = UNNotificationCategory(identifier: NotificationType.didFinishBreak.rawValue, actions: [beginFocus], intentIdentifiers: [], options: [])
  133|      0|        let breakCategory = UNNotificationCategory(identifier: NotificationType.didFinishFocus.rawValue, actions: [beginBreak], intentIdentifiers: [], options: [])
  134|       |
  135|       |        // Register Category
  136|       |        UNUserNotificationCenter.current().setNotificationCategories([focusCategory, breakCategory])
  137|       |    }
  138|       |
  139|       |}
  140|       |
  141|       |extension AppNotificationBO: UNUserNotificationCenterDelegate {
  142|       |    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
  143|       |        completionHandler([.alert, .badge, .badge])
  144|       |    }
  145|       |
  146|       |    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
  147|       |        
  148|       |        switch response.actionIdentifier {
  149|       |        case ActionNotification.beginBreak.rawValue:
  150|       |//            vc.startTimer()
  151|       |            print("Break tapped")
  152|       |        case ActionNotification.beginFocus.rawValue:
  153|       |            print("Focus tapped")
  154|       |        default:
  155|       |            print("Other Action")
  156|       |        }
  157|       |
  158|       |        completionHandler()
  159|       |    }
  160|       |}
  161|       |
  162|       |extension AppNotificationBO {
  163|       |    //MARK:- Background task
  164|       |    
  165|       |    func registerBgTask(timeRecover: TimeRecoverBO) {
  166|       |        bgTask = UIApplication.shared.beginBackgroundTask {
  167|       |            let brightness = UIScreen.main.brightness
  168|       |            if brightness > 0 {
  169|       |                if timeRecover.timer.state == .focus {
  170|       |                    self.sendNotification(type: .didLoseFocus)
  171|       |                }
  172|       |                timeRecover.backgroundStatus = .homeScreen
  173|       |            } else {
  174|       |                timeRecover.backgroundStatus = .lockScreen
  175|       |            }
  176|       |            
  177|       |            self.removeBgTask()
  178|       |        }
  179|       |    }
  180|       |    
  181|       |    func removeBgTask() {
  182|       |        UIApplication.shared.endBackgroundTask(self.bgTask)
  183|       |        self.bgTask = .invalid
  184|       |    }
  185|       |    
  186|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/BO/DataChartBO.swift:
    1|       |//
    2|       |//  DataChartBO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Caio Azevedo on 08/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Charts
   11|       |
   12|       |class DataChartBO {
   13|       |    var timeProjects: [Int]
   14|       |    var totalTime: Int
   15|       |    var projects: [Project]
   16|      0|    var projectColors = [NSUIColor]()
   17|       |    var isHidden: Bool
   18|       |    
   19|      0|    init() {
   20|      0|        timeProjects = []
   21|      0|        totalTime = 0
   22|      0|        projectColors = []
   23|      0|        projects = []
   24|      0|        isHidden = true
   25|      0|    }
   26|       |    
   27|       |    /// Description:  Load the projects to insert data into the chart
   28|       |    /// - Returns: Data to insert into the Chart View
   29|      0|    func loadChartData(completion: @escaping (PieChartData) ->  ()){
   30|      0|        /// Get Projects from database
   31|      0|        ProjectBO().retrieve { (results) in
   32|      0|            switch results {
   33|      0|            case .success(let projects):
   34|      0|                self.projects = projects
   35|      0|            case .failure(let error):
   36|      0|                print(error.localizedDescription)
   37|      0|            }
   38|      0|            
   39|      0|            getTimeStatistics(projects: self.projects)
   40|      0|            
   41|      0|            let projectsPercentage = calculateProjectsPercentage()
   42|      0|            let entries = createDataEntries(projectsPercentage: projectsPercentage)
   43|      0|            
   44|      0|            let data = insertChartData(entries: entries)
   45|      0|            
   46|      0|            completion(data)
   47|      0|        }
   48|      0|    }
   49|       |    
   50|       |    /// Description: Get time statistics like total time and time for each project
   51|       |    /// - Parameter projects: The projects to get the time statistics
   52|      0|    func getTimeStatistics(projects: [Project]){
   53|      0|        for proj in projects {
   54|      0|            let time = proj.time
   55|      0|            
   56|      0|            /// If has time value show charts
   57|      0|            if time > 0 {
   58|      0|                isHidden = false
   59|      0|            }
   60|      0|            
   61|      0|            self.projectColors.append(proj.color as NSUIColor)
   62|      0|            self.timeProjects.append(time)
   63|      0|            self.totalTime += time
   64|      0|        }
   65|      0|    }
   66|       |    
   67|       |    /// Description: Calculates the percentage of each project in relation to its time
   68|       |    /// - Returns: Returns an array of project percentage
   69|      0|    func calculateProjectsPercentage() -> [Double] {
   70|      0|        var projectsPercentage = [Double]()
   71|      0|        
   72|      0|        for time in timeProjects {
   73|      0|            let timePercentage = Double(time * 100) / Double(self.totalTime)
   74|      0|            projectsPercentage.append(timePercentage)
   75|      0|        }
   76|      0|        
   77|      0|        return projectsPercentage
   78|      0|    }
   79|       |    
   80|       |    /// Description: Create data entries to insert into the Chart
   81|       |    /// - Parameter projectsPercentage: Get each projects percentage
   82|       |    /// - Returns:Returns a array of the created Data Entry
   83|      0|    func createDataEntries(projectsPercentage: [Double]) -> [PieChartDataEntry]{
   84|      0|        var entries = [PieChartDataEntry]()
   85|      0|        for projPercentage in projectsPercentage{
   86|      0|            let entry = PieChartDataEntry(value: projPercentage)
   87|      0|            entry.label = "%"
   88|      0|            entries.append(entry)
   89|      0|        }
   90|      0|        
   91|      0|        return entries
   92|      0|    }
   93|       |    
   94|       |    /// Description: Insert the data into the Chart with the color of each project
   95|       |    /// - Parameter entries: Get the eentries with the project time percentage
   96|      0|    func insertChartData(entries: [PieChartDataEntry]) -> PieChartData{
   97|      0|        let dataSet  = PieChartDataSet(entries: entries)
   98|      0|        dataSet.colors = self.projectColors
   99|      0|        dataSet.valueLineColor = UIColor(red: 0.20, green: 0.20, blue: 0.20, alpha: 1.00)
  100|      0|        dataSet.label = ""
  101|      0|        
  102|      0|        let data = PieChartData(dataSet: dataSet)
  103|      0|        data.setValueTextColor(UIColor(red: 0.20, green: 0.20, blue: 0.20, alpha: 1.00) as NSUIColor)
  104|      0|        
  105|      0|        return data
  106|      0|    }
  107|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/BO/ProjectBO.swift:
    1|       |//
    2|       |//  ProjectBO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 28/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |/// Project business object
   12|       |class ProjectBO {
   13|       |    /// Project data access object
   14|      0|    private var projectDAO = ProjectDAO()
   15|       |    
   16|       |    /// Create an object of type Project with DAO
   17|       |    /// - Parameters:
   18|       |    ///   - name: Name of project
   19|       |    ///   - color: Color of project
   20|       |    /// - Returns: Boolean if the project was saved
   21|      0|    func create(name: String, color: UIColor, completion: (Result<Bool, ValidationError>) -> Void) {
   22|      0|        guard name.count > 0  else {
   23|      0|            completion(.failure(.tooShort("Project")))
   24|      0|            return
   25|      0|        }
   26|      0|                
   27|      0|        let project = Project(id: UUID(), name: name, color: color, time: 0)
   28|      0|        projectDAO.create(project: project, completion: { result in
   29|      0|            switch result {
   30|      0|                case .success(_):
   31|      0|                    completion(.success(true))
   32|      0|                case .failure(let error):
   33|      0|                    completion(.failure(error))
   34|      0|                }
   35|      0|        })
   36|      0|    }
   37|       |    
   38|       |    /// Performs the search for projects at DAO
   39|       |    /// - Returns: List of projects
   40|      0|    func retrieve(completion: (Result<[Project], ValidationError>) -> Void){
   41|      0|        projectDAO.retrieve(completion: { result in
   42|      0|            switch result {
   43|      0|                
   44|      0|            case .success(let projects):
   45|      0|                completion(.success(projects))
   46|      0|            case .failure(let error):
   47|      0|                completion(.failure(error))
   48|      0|            }
   49|      0|        })
   50|      0|    }
   51|       |    
   52|       |    /// Updates a project in the database with DAO
   53|       |    /// - Parameter project: Project to update
   54|       |    /// - Returns: Boolean if the project was updated
   55|      0|    func update(project: Project, completion: (Result<Void, ValidationError>) -> Void) {
   56|      0|        
   57|      0|        guard project.name.count > 0  else {
   58|      0|            completion(.failure(.tooShort("Project")))
   59|      0|            return
   60|      0|        }
   61|      0|        
   62|      0|        projectDAO.update(project: project, completion: { result in
   63|      0|            switch result {
   64|      0|
   65|      0|            case .success():
   66|      0|                completion(.success(()))
   67|      0|            case .failure(let error):
   68|      0|                completion(.failure(error))
   69|      0|            }
   70|      0|        })
   71|      0|        
   72|      0|    }
   73|       |    
   74|       |    /// Updates a project in the database with DAO
   75|       |    /// - Parameter uuid: UUID that identifies the project
   76|       |    /// - Returns: Boolean if the project was deleted
   77|      0|    func delete(uuid: UUID, completion: (Result<Void, ValidationError>) -> Void) {
   78|      0|        projectDAO.delete(uuid: uuid, completion: { result in
   79|      0|            switch result {
   80|      0|                
   81|      0|            case .success():
   82|      0|                completion(.success(()))
   83|      0|            case .failure(let error):
   84|      0|                completion(.failure(error))
   85|      0|            }
   86|      0|        })
   87|      0|    }
   88|       |    
   89|      0|    func addTask(description: String, projectCD: ProjectCD, completion: (Result<Void, ValidationError>) -> Void){
   90|      0|        
   91|      0|        let taskBO = TaskBO()
   92|      0|        taskBO.create(description: description, completion: { resultTask in
   93|      0|            switch resultTask {
   94|      0|                
   95|      0|            case .success(let taskCD):
   96|      0|                projectDAO.addTask(taskCD: taskCD, projectCD: projectCD, completion: { result in
   97|      0|                    completion(result)
   98|      0|                })
   99|      0|            case .failure(let error):
  100|      0|                completion(.failure(error))
  101|      0|            }
  102|      0|        })
  103|      0|        
  104|      0|//        projectDAO.addTask(taskCD: taskCD, projectCD: projectCD, completion: { result in
  105|      0|//            
  106|      0|//            switch result {
  107|      0|//                
  108|      0|//            case .success():
  109|      0|//                completion(.success(()))
  110|      0|//            case .failure(let error):
  111|      0|//                completion(.failure(error))
  112|      0|//            }
  113|      0|//        })
  114|      0|    }
  115|       |    
  116|      0|    func fetch(id: UUID, completion: (Result<Project, ValidationError>) -> Void){
  117|      0|        projectDAO.fetch(id: id, completion: { result in
  118|      0|            switch result {
  119|      0|                
  120|      0|            case .success(let project):
  121|      0|                completion(.success(project))
  122|      0|            case .failure(let error):
  123|      0|                completion(.failure(error))
  124|      0|            }
  125|      0|        })
  126|      0|    }
  127|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/BO/TaskBO.swift:
    1|       |//
    2|       |//  TaskBO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Carlos Fontes on 30/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class TaskBO {
   12|       |    
   13|       |    //MARK:- Atributes
   14|      0|    private var taskDAO = TaskDAO()
   15|       |    
   16|       |    //MARK:- Functions
   17|       |    
   18|       |    /// Create a task of type Task with DAO
   19|       |    /// - Parameter description: Description of task
   20|       |    /// - Returns: Boolean if the task was saved
   21|      0|    func create(description: String, completion: (Result<TaskCD, ValidationError>) -> Void){
   22|      0|        let task = Task(id: UUID(), description: description, state: false, createdAt: Date())
   23|      0|        
   24|      0|        taskDAO.createTask(task: task, completion: { result in
   25|      0|            switch result {
   26|      0|                
   27|      0|            case .success(let taskCD):
   28|      0|                completion(.success(taskCD))
   29|      0|            case .failure(let error):
   30|      0|                completion(.failure(error))
   31|      0|            }
   32|      0|        })
   33|      0|    }
   34|       |    
   35|       |    /// Retrieves a list of tasks
   36|       |    /// - Returns: List of tasks
   37|      0|    func retrieve(id: UUID, completion: (Result<[Task], ValidationError>) -> Void){
   38|      0|        taskDAO.retrieve(id: id, completion: { result in
   39|      0|            switch result {
   40|      0|                
   41|      0|            case .success(let tasks):
   42|      0|                completion(.success(tasks))
   43|      0|            case .failure(let error):
   44|      0|                completion(.failure(error))
   45|      0|            }
   46|      0|        })
   47|      0|    }
   48|       |    
   49|       |    /// Updates a task in database with DAO
   50|       |    /// - Parameter task: Task to update
   51|       |    /// - Returns: Boolean if the project was updated
   52|      0|    func update(task: Task, completion: (Result<Void, ValidationError>) -> Void) {
   53|      0|        taskDAO.updateTask(task: task, completion: { result in
   54|      0|            switch result {
   55|      0|                
   56|      0|            case .success():
   57|      0|                completion(.success(()))
   58|      0|            case .failure(let error):
   59|      0|                completion(.failure(error))
   60|      0|            }
   61|      0|        })
   62|      0|    }
   63|       |    
   64|       |    /// Delete a task in database with DAO
   65|       |    /// - Parameter uuid: UUID that identifies task
   66|       |    /// - Returns: Boolean if the task was deleted
   67|      0|    func delete(uuid: UUID, completion: (Result<Void, ValidationError>) -> Void){
   68|      0|        taskDAO.deleteTask(uuid: uuid, completion: { result in
   69|      0|            switch result {
   70|      0|                
   71|      0|            case .success():
   72|      0|                completion(.success(()))
   73|      0|            case .failure(let error):
   74|      0|                completion(.failure(error))
   75|      0|            }
   76|      0|        })
   77|      0|    }
   78|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/BO/TimeTrackerBO.swift:
    1|       |//
    2|       |//  TimeTrakcerBO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Fábio Maciel de Sousa on 29/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |enum TimeTrackerState: String{
   12|       |    case focus
   13|       |    case pause
   14|       |}
   15|       |
   16|       |///Class created for handling the count down
   17|       |class TimeTrackerBO{
   18|       |    
   19|       |    //MARK:Atributes
   20|      0|    var timer = Timer()
   21|      0|    private var statisticBO = StatisticBO()
   22|      0|    private var projectBO = ProjectBO()
   23|      0|    var projectUuid = UUID()
   24|       |    var configTime: Int {
   25|      0|        get{
   26|      0|            if UserDefaults.standard.integer(forKey: "default") == 0{
   27|      0|                return 25
   28|      0|            }
   29|      0|            return UserDefaults.standard.integer(forKey: "default")
   30|      0|        }
   31|      0|        set{
   32|      0|            UserDefaults.standard.set(newValue, forKey: "default")
   33|      0|        }
   34|       |    }
   35|       |    var hasEnded = false
   36|       |    var timeInterval : TimeInterval = 1 //seconds at a time
   37|       |    
   38|       |    var qtdLostFocus = 0
   39|       |    var focusTime = 0
   40|       |    var lostFocusTime = 0
   41|       |    var restTime = 0
   42|       |    ///Ends when value gets to zero
   43|       |    var countDown = 0{
   44|      0|        willSet{
   45|      0|            if newValue <= 0{
   46|      0|                hasEnded = true
   47|      0|            }
   48|      0|        }
   49|       |    }
   50|       |    
   51|       |    //MARK:Properties
   52|       |    ///Converted minutes to seconds
   53|       |    ///If the state is pause, it calculates the pause time
   54|      0|    var convertedTimeValue: Int{
   55|      0|        if state == .pause{
   56|      0|            let seconds = (configTime / 5) * 60
   57|      0|            return seconds <= 0 ? 1 : seconds
   58|      0|        }
   59|      0|        return configTime * 60
   60|      0|    }
   61|       |    //MARK:States
   62|       |    ///State according to view
   63|      0|    var state = TimeTrackerState.focus{
   64|      0|        didSet{
   65|      0|            self.focusTime = 0
   66|      0|            self.lostFocusTime = 0
   67|      0|            self.restTime = 0
   68|      0|            self.qtdLostFocus = 0
   69|      0|        }
   70|       |    }
   71|      0|    var changeCicle: TimeTrackerState{
   72|      0|        return state == .focus ? .pause : .focus
   73|      0|    }
   74|       |    //MARK: Methods
   75|       |    /**
   76|       |     Method for starting the count down from an initial value, and also handling view updates.
   77|       |     
   78|       |     If another countDown has already started, a new one won't start.The initial value must be greater than 0
   79|       |     
   80|       |     - Parameter minutes: the initial value in minutes which the countDown will start from.
   81|       |     - Parameter updateView: a closure called each time the timer is updated for handling view updates.
   82|       |     */
   83|      0|    func startTimer(updateView: @escaping (String, Bool) -> Void){
   84|      0|        countDown = convertedTimeValue
   85|      0|        hasEnded = false
   86|      0|        
   87|      0|        //Runs timer and updates each second
   88|      0|        timer = Timer.scheduledTimer(withTimeInterval: timeInterval, repeats: true, block: { (_) in
   89|      0|            self.countDown -= 1 //Decreases time
   90|      0|            var convertedTimeText = self.secondsToString(with: self.countDown)
   91|      0|            self.updateTrackedValues()
   92|      0|            
   93|      0|            if self.hasEnded{ //It changes state, cancels timer and updates view with default value
   94|      0|                self.timer.invalidate()
   95|      0|                self.updateStatistics()
   96|      0|                let defaultTimeText = self.secondsToString(with: self.convertedTimeValue)
   97|      0|                convertedTimeText = defaultTimeText
   98|      0|            }
   99|      0|            
  100|      0|            updateView(convertedTimeText,self.hasEnded)
  101|      0|        })
  102|      0|    }
  103|       |    
  104|       |    /**
  105|       |     Method for updating the tracked values which will be stored in the Data Base
  106|       |     */
  107|      0|    func updateTrackedValues(){
  108|      0|        if state == .focus{
  109|      0|            self.focusTime += 1
  110|      0|        }else if state == .pause{
  111|      0|            self.restTime += 1
  112|      0|        }
  113|      0|    }
  114|       |    
  115|       |    /**
  116|       |     Method for stopping the count down.
  117|       |     
  118|       |     if the count down was running it pop up a message to the user.
  119|       |     */
  120|      0|    func stopTimer(updateView: @escaping () -> Void){
  121|      0|        timer.invalidate()
  122|      0|        updateView()
  123|      0|        state = .focus
  124|      0|    }
  125|       |    
  126|       |    /**
  127|       |     Method for converting seconds to the formatted string to be displayed on the view
  128|       |     - Parameter seconds: the current unformatted second from the count down
  129|       |     - Returns: formatted string of the current time in minutes and seconds
  130|       |     */
  131|      0|    func secondsToString(with seconds: Int) -> String{
  132|      0|        if seconds < 0 {return ""} //TODO: send error
  133|      0|        var min = (seconds / 60)
  134|      0|        let hour = (min / 60) % 60
  135|      0|        min %= 60
  136|      0|        let sec = seconds % 60
  137|      0|        return String(format:"%02i:%02i:%02i",hour, min, sec)
  138|      0|    }
  139|       |    
  140|       |    /**
  141|       |     Method for converting strings to seconds
  142|       |     - Parameter text: the text from the label in the view
  143|       |     - Returns: the amount of seconds for the count down
  144|       |     */
  145|      0|    func stringToSeconds(from text: String) -> Int{
  146|      0|        if text.contains("-") { return 0}
  147|      0|        if !text.contains(":") { return 0}
  148|      0|        let numbers = text.split(separator: ":")
  149|      0|        if numbers.count != 3 { return 0}
  150|      0|        guard let hour = Int(numbers[0]) else {return 0}
  151|      0|        guard var min = Int(numbers[1]) else {return 0}
  152|      0|        min += hour * 60
  153|      0|        let sec = min * 60
  154|      0|        return sec
  155|      0|    }
  156|       |    
  157|       |    ///Method for updating statistics based on timer atributes
  158|      0|    func updateStatistics() {
  159|      0|        //create statistics based on Timer
  160|      0|        var statistic = Statistic(id: UUID(), focusTime: focusTime, lostFocusTime: lostFocusTime, restTime: restTime, qtdLostFocus: qtdLostFocus, year: 0, month: 0)
  161|      0|        //update Project
  162|      0|        if updateProject(statistic: statistic){
  163|      0|            print("Project Updated")
  164|      0|        }
  165|      0|        //Retrieve statistic from Data Base
  166|      0|        statisticBO.retrieveStatistic { (result) in
  167|      0|            
  168|      0|            switch result {
  169|      0|            case .success(let statistics):
  170|      0|                guard let dbStatistics = statistics else {return}
  171|      0|                //get current date
  172|      0|                let components = getDate()
  173|      0|                guard let year = components.year,
  174|      0|                    let month = components.month else {return}
  175|      0|                //Filter statistic from current month
  176|      0|                let dbStatisticFilter = (dbStatistics.filter{$0.month == month && $0.year == year})
  177|      0|                //Check if current month has statistic and add Timer statistics to it
  178|      0|                guard let dbStatistic = dbStatisticFilter.first else {return}
  179|      0|                statistic += dbStatistic
  180|      0|            case .failure(let error):
  181|      0|                print(error.localizedDescription)
  182|      0|            }
  183|      0|        }
  184|      0|        statisticBO.updateStatistic(statistics: statistic) { (result) in
  185|      0|            switch result {
  186|      0|            case .success(_): break
  187|      0|            case .failure(let error):
  188|      0|                print(error.localizedDescription)
  189|      0|            }
  190|      0|        }
  191|      0|    }
  192|       |    
  193|       |    /**
  194|       |     Method for updating project according to statistics
  195|       |     - Parameter statistic: Statistic created with values from time tracker to be added to the total project time
  196|       |     - Returns: Boolean value according to the sucess in updating the current project
  197|       |     */
  198|      0|    func updateProject(statistic: Statistic) -> Bool{
  199|      0|        var success = true
  200|      0|        var project: Project?
  201|      0|        projectBO.retrieve { (result) in
  202|      0|            switch result {
  203|      0|            case .success(let projects):
  204|      0|                let filteredProject = projects.filter{$0.id == projectUuid}
  205|      0|                guard var dbProject = filteredProject.first else {return}
  206|      0|                dbProject += statistic
  207|      0|                project = dbProject
  208|      0|            case .failure(let error):
  209|      0|                print(error.localizedDescription)
  210|      0|                success = false
  211|      0|            }
  212|      0|        }
  213|      0|        guard let updatedProj = project else {return false}
  214|      0|        projectBO.update(project: updatedProj) { (result) in
  215|      0|            switch result {
  216|      0|            case .success(_): break
  217|      0|            case .failure(let error):
  218|      0|                print(error.localizedDescription)
  219|      0|                success = false
  220|      0|            }
  221|      0|        }
  222|      0|        return success
  223|      0|    }
  224|       |    
  225|       |    //TODO: put it in an Utils
  226|       |    /**
  227|       |     Method for getting the current date
  228|       |     - Returns: Value containing current Year and Month
  229|       |     */
  230|      0|    func getDate() -> DateComponents{
  231|      0|        let date = Date()
  232|      0|        let calendar = Calendar.current
  233|      0|        let components = calendar.dateComponents([.year, .month], from: date)
  234|      0|        return components
  235|      0|    }
  236|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/BO/TimerRecoverBO.swift:
    1|       |//
    2|       |//  TimerRecoverBO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Caio Azevedo on 05/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |enum BackgroundStatus {
   12|       |    case lockScreen
   13|       |    case homeScreen
   14|       |}
   15|       |
   16|       |class TimeRecoverBO {
   17|       |    var enterBackgroundInstant: Date?
   18|       |    var returnFromBackgroundInstant: Date!
   19|       |    
   20|       |    var backgroundStatus: BackgroundStatus?
   21|       |
   22|       |    var timer: TimeTrackerBO
   23|       |
   24|      0|    init(timer: TimeTrackerBO) {
   25|      0|        self.timer = timer
   26|      0|    }
   27|       |
   28|      0|    func enterbackground(){
   29|      0|        if timer.state == TimeTrackerState.focus {
   30|      0|            /// Save the moment that enterBackground
   31|      0|            self.enterBackgroundInstant = Date()
   32|      0|            
   33|      0|            print("EnterBackground Instant: \(enterBackgroundInstant!)")
   34|      0|            
   35|      0|        } else if timer.state == TimeTrackerState.pause {
   36|      0|            /// Local Notification with rest Time as delay
   37|      0|        }
   38|      0|    }
   39|       |
   40|      0|    func returnFromBackground(){
   41|      0|        guard let backgroundInstant = self.enterBackgroundInstant else { return }
   42|      0|        
   43|      0|        let timeInBackground = backgroundTimeRecover(backgroundInstant: backgroundInstant)
   44|      0|        
   45|      0|        /// Handle Timer State
   46|      0|        if timer.state == .focus{
   47|      0|            let changeCicle =  updateTimerAtributesWhenFocus(lostFocusTime: timeInBackground)
   48|      0|            
   49|      0|            if changeCicle {
   50|      0|                /// Reset timer
   51|      0|                timer.countDown = 0
   52|      0|            }
   53|      0|           
   54|      0|        } else if timer.state == .pause{
   55|      0|            let changeCicle = updateTimerAtributesWhenPause(restInBackgrund: timeInBackground)
   56|      0|            
   57|      0|            if changeCicle {
   58|      0|                // Reset timer
   59|      0|                timer.countDown = 0
   60|      0|            }
   61|      0|        }
   62|      0|    }
   63|       |
   64|       |    /// Description: Function to recover and update the timer or the esttistics
   65|      0|    func backgroundTimeRecover(backgroundInstant: Date) -> Int{
   66|      0|        self.returnFromBackgroundInstant = Date()
   67|      0|        
   68|      0|        /// Get the time the user has been out of the app
   69|      0|        let timeInBackground = Int(backgroundInstant.distance(to: self.returnFromBackgroundInstant))
   70|      0|        
   71|      0|        print("Came Back after : \(timeInBackground)")
   72|      0|        
   73|      0|        return timeInBackground
   74|      0|    }
   75|       |
   76|      0|    func updateTimerAtributesWhenFocus(lostFocusTime: Int) -> Bool{
   77|      0|        let currentTime = lostFocusTime + timer.lostFocusTime + timer.focusTime
   78|      0|        
   79|      0|        /// If the user has been out more than the time he configured, change cicle of Timer
   80|      0|        if currentTime < timer.configTime * 60 {
   81|      0|            /// Update lost focus time from timer with the value calculate when returns from background and the configured Time isnt over
   82|      0|            if self.backgroundStatus == BackgroundStatus.homeScreen {
   83|      0|                timer.lostFocusTime += (lostFocusTime)
   84|      0|                timer.qtdLostFocus += 1
   85|      0|            } else {
   86|      0|                timer.focusTime += lostFocusTime
   87|      0|            }
   88|      0|            
   89|      0|            timer.countDown -= lostFocusTime
   90|      0|            
   91|      0|            return false
   92|      0|        } else {
   93|      0|            if self.backgroundStatus == BackgroundStatus.homeScreen {
   94|      0|                /// Update Timer - Lost Focus Time
   95|      0|                timer.lostFocusTime = timer.configTime * 60 - timer.focusTime
   96|      0|                timer.qtdLostFocus += 1
   97|      0|            } else {
   98|      0|                timer.focusTime = timer.configTime * 60 - timer.lostFocusTime
   99|      0|            }
  100|      0|            timer.countDown = 0
  101|      0|            return true
  102|      0|        }
  103|      0|    }
  104|       |
  105|      0|    func updateTimerAtributesWhenPause(restInBackgrund: Int) -> Bool{
  106|      0|        let currentRestTime = restInBackgrund + timer.restTime
  107|      0|        
  108|      0|        /// If the user has been out more than the time he configured, change cicle of Timer
  109|      0|        if currentRestTime < timer.configTime * 60 {
  110|      0|            /// Update Atributes
  111|      0|            timer.restTime += restInBackgrund
  112|      0|            timer.countDown -= restInBackgrund
  113|      0|            
  114|      0|            return false
  115|      0|        } else {
  116|      0|            timer.restTime = timer.configTime * 60
  117|      0|            
  118|      0|            return true
  119|      0|        }
  120|      0|    }
  121|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Controller/Onboarding/Onboarding7ViewController.swift:
    1|       |//
    2|       |//  Onboarding7ViewController.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 19/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class Onboarding7ViewController: UIViewController {
   12|       |
   13|      0|    override func viewDidLoad() {
   14|      0|        super.viewDidLoad()
   15|      0|
   16|      0|        // Do any additional setup after loading the view.
   17|      0|    }
   18|       |    
   19|       |
   20|      0|    @IBAction func onClickStart(_ sender: Any) {
   21|      0|        UserDefaults.standard.set(true, forKey: "onboardingWasDisplayed")
   22|      0|        performSegue(withIdentifier: "projects", sender: self)
   23|       |        AppNotificationBO.shared.requestAuthorazition()
   24|       |    }
   25|       |    
   26|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Controller/Onboarding/OnboardingPagerViewController.swift:
    1|       |//
    2|       |//  Swipe.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 08/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class OnboardingPagerViewController: UIViewController {
   12|       |    
   13|      0|    let storyboardIDs = [ "Onboarding1",
   14|      0|                          "Onboarding2",
   15|      0|                          "Onboarding3",
   16|      0|                          "Onboarding4",
   17|      0|                          "Onboarding5",
   18|      0|                          "Onboarding6",
   19|      0|                          "Onboarding7", ]
   20|       |    
   21|      0|    lazy var vcs: [UIViewController] = {
   22|      0|        var vc = [UIViewController]()
   23|      0|        
   24|      0|        for i in 0..<storyboardIDs.count {
   25|      0|            let id = storyboardIDs[i]
   26|      0|            vc.append(UIStoryboard(name: id, bundle: nil).instantiateViewController(identifier: "vc"))
   27|      0|        }
   28|      0|        
   29|      0|        return vc
   30|      0|    }()
   31|       |    
   32|      0|    var initialContentOffset = CGPoint()
   33|       |    var scrollView: UIScrollView!
   34|       |    
   35|      0|    var pgControl = UIPageControl()
   36|       |    var currentPage = 0 {
   37|      0|        didSet {
   38|      0|            pgControl.currentPage = currentPage
   39|      0|        }
   40|       |    }
   41|       |    var widthPage: CGFloat = 0
   42|       |    
   43|      0|    override func viewDidLoad() {
   44|      0|        super.viewDidLoad()
   45|      0|        
   46|       |        setupHorizontalScrollView()
   47|      0|        
   48|      0|        setupPageControl()
   49|      0|        
   50|      0|        setupTapGesture()
   51|      0|    }
   52|      0|    
   53|      0|    override func viewWillAppear(_ animated: Bool) {
   54|      0|        self.navigationController?.setNavigationBarHidden(true, animated: true)
   55|      0|    }
   56|       |    
   57|      0|    private func setupTapGesture() {
   58|      0|        let tap = UITapGestureRecognizer(target: self, action: #selector(handleTap))
   59|      0|        scrollView.addGestureRecognizer(tap)
   60|      0|    }
   61|       |    
   62|      0|    @objc private func handleTap() {
   63|      0|        let currentOffset = self.scrollView.contentOffset
   64|      0|        let newOffset = CGPoint(x: currentOffset.x + self.widthPage, y: currentOffset.y)
   65|      0|        
   66|      0|        guard newOffset.x <= widthPage * CGFloat(vcs.count) - 1 else {
   67|      0|            if let lastOnboarding = vcs.last as? Onboarding7ViewController {
   68|      0|                lastOnboarding.onClickStart(self)
   69|      0|            }
   70|      0|            return
   71|      0|        }
   72|       |        
   73|      0|        UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseInOut, animations: {
   74|      0|            self.scrollView.contentOffset = newOffset
   75|      0|        }, completion: nil)
   76|      0|    }
   77|      0|    
   78|      0|    func setupPageControl() {
   79|      0|        pgControl.pageIndicatorTintColor = .lightGray
   80|      0|        pgControl.currentPageIndicatorTintColor = .white
   81|      0|        pgControl.numberOfPages = vcs.count
   82|      0|        pgControl.removeFromSuperview()
   83|      0|        view.addSubview(pgControl)
   84|       |
   85|      0|        pgControl.translatesAutoresizingMaskIntoConstraints = false
   86|      0|        pgControl.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: 10).isActive = true
   87|      0|        pgControl.centerXAnchor.constraint(equalTo: view.safeAreaLayoutGuide.centerXAnchor).isActive = true
   88|      0|    }
   89|      0|    
   90|      0|    func setupHorizontalScrollView() {
   91|      0|        
   92|      0|        let cWidth = self.view.bounds.width
   93|      0|        let cHeight = self.view.bounds.height
   94|      0|        let countVC = CGFloat(vcs.count)
   95|      0|        
   96|      0|        widthPage = cWidth
   97|      0|        
   98|      0|        scrollView = UIScrollView()
   99|      0|        scrollView.isPagingEnabled = true
  100|      0|        scrollView.showsHorizontalScrollIndicator = false
  101|      0|        scrollView.bounces = false
  102|      0|        scrollView.delegate = self
  103|      0|        scrollView.backgroundColor = .clear
  104|      0|        
  105|      0|        self.scrollView!.frame = CGRect(x: self.view.bounds.origin.x, y: self.view.bounds.origin.y, width: cWidth, height: cHeight)
  106|      0|        self.view.addSubview(scrollView)
  107|      0|        
  108|      0|        let scrollWidth: CGFloat  = countVC * cWidth
  109|      0|        let scrollHeight: CGFloat  = cHeight
  110|      0|        self.scrollView!.contentSize = CGSize(width: scrollWidth, height: scrollHeight)
  111|      0|        
  112|      0|        for i in 0..<self.vcs.count {
  113|      0|            
  114|      0|            vcs[i].view.frame = CGRect(x: CGFloat(i) * cWidth, y: 0, width: cWidth, height: cHeight)
  115|      0|
  116|      0|            self.scrollView!.addSubview(vcs[i].view)
  117|      0|            
  118|      0|            if(i == self.vcs.count - 1){
  119|      0|                vcs[i].didMove(toParent: self)
  120|      0|            }
  121|       |            
  122|       |        }
  123|       |        
  124|       |        self.scrollView!.delegate = self;
  125|      0|    }
  126|      0|}
  127|      0|
  128|       |// MARK: UIScrollView Delegate
  129|      0|extension OnboardingPagerViewController: UIScrollViewDelegate {
  130|      0|    func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
  131|      0|        self.initialContentOffset = scrollView.contentOffset
  132|      0|    }
  133|      0|    
  134|      0|    func scrollViewDidScroll(_ scrollView: UIScrollView) {
  135|      0|        let xOffset = scrollView.contentOffset.x
  136|      0|        let width = view.bounds.width
  137|      0|            
  138|      0|        for i in 0..<vcs.count {
  139|      0|            if xOffset == width * CGFloat(i) {
  140|       |                currentPage = i
  141|       |                break
  142|       |            }
  143|       |        }
  144|       |    }
  145|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Controller/ProjectViewController.swift:
    1|       |//
    2|       |//  ProjectViewController.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 29/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class ProjectViewController: UIViewController {
   12|       |    @IBOutlet weak var collectionView: UICollectionView!
   13|       |    
   14|       |    @IBOutlet weak var focusedTimeLabel: UILabel!
   15|       |    @IBOutlet weak var distractionTimeLabel: UILabel!
   16|       |    @IBOutlet weak var breakTimeLabel: UILabel!
   17|       |    @IBOutlet weak var backgroundImage: UIImageView!
   18|       |    @IBOutlet weak var navigationBar: UINavigationItem!
   19|       |    
   20|      0|    let collectionLayout = CollectionViewFlowLayout()
   21|       |    
   22|       |    var selectedProjectId: Int?
   23|      0|    var projectBO = ProjectBO()
   24|      0|    var projects: [Project] = []
   25|       |    
   26|      0|    override func viewDidLoad() {
   27|      0|        super.viewDidLoad()
   28|      0|        
   29|      0|        createStatistics()
   30|      0|        
   31|      0|        collectionView.collectionViewLayout = collectionLayout
   32|      0|        
   33|      0|        self.navigationController?.navigationBar.shadowImage = UIImage()
   34|      0|        self.navigationController?.navigationBar.setBackgroundImage(UIImage(), for: .default)
   35|      0|    }
   36|      0|    
   37|      0|    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
   38|       |        UIApplication.shared.sendAction(#selector(UIApplication.resignFirstResponder), to: nil, from: nil, for: nil)
   39|      0|        view.endEditing(true)
   40|      0|    }
   41|      0|    
   42|      0|    override func viewWillAppear(_ animated: Bool) {
   43|       |        super.viewWillAppear(true)
   44|      0|        getCurrentStatistics()
   45|      0|        
   46|      0|        reloadList()
   47|      0|    }
   48|       |    
   49|      0|    @IBAction func addProjectButtonAction(_ sender: Any) {
   50|      0|        goToNewProjectViewController()
   51|      0|    }
   52|      0|    
   53|      0|    @IBAction func showStatistics(_ sender: Any) {
   54|      0|        performSegue(withIdentifier: "statistics", sender: nil)
   55|      0|    }
   56|       |    
   57|      0|    /// Go to NewProjectViewController
   58|      0|    private func goToNewProjectViewController() {
   59|      0|        if let newProjectVC = UIStoryboard.loadView(from: .NewProject, identifier: .NewProjectID) as? NewProjectViewController {
   60|       |            newProjectVC.modalTransitionStyle = .crossDissolve
   61|      0|            newProjectVC.modalPresentationStyle = .overCurrentContext
   62|      0|            newProjectVC.delegate = self
   63|      0|            
   64|       |            if let selectedProjectId = selectedProjectId {
   65|       |                newProjectVC.project = projects[selectedProjectId]
   66|      0|                self.selectedProjectId = nil
   67|      0|            }
   68|      0|            
   69|      0|            self.present(newProjectVC, animated: true)
   70|      0|        }
   71|      0|    }
   72|      0|    
   73|      0|    /// Description: Function to get Statistic Data per month and year to Show on Home screen
   74|      0|    private func getCurrentStatistics(){
   75|      0|        let currentDate = Date()
   76|       |        let month = Calendar.current.component(.month, from: currentDate)
   77|       |        let year = Calendar.current.component(.year, from: currentDate)
   78|      0|        
   79|      0|        StatisticBO().retrieveStatisticPerMonth(month: Int32(month), year: Int32(year)) { (results) in
   80|      0|            switch results {
   81|      0|            case .success(let statistic):
   82|      0|                
   83|      0|                self.focusedTimeLabel.text = convertTime(seconds: statistic?.focusTime ?? 0)
   84|      0|                self.distractionTimeLabel.text = convertTime(seconds: statistic?.lostFocusTime ?? 0)
   85|      0|                self.breakTimeLabel.text =  convertTime(seconds: statistic?.restTime ?? 0)
   86|      0|                
   87|      0|            case .failure(let error):
   88|      0|                print(error.localizedDescription)
   89|      0|            }
   90|      0|        }
   91|      0|    }
   92|       |    
   93|       |    /// Description:  Convert Time in seconds to show on label
   94|      0|    /// - Parameter seconds: time in seconds to convert
   95|      0|    /// - Returns: returns the time to present. Example:  01h30
   96|      0|    func convertTime(seconds: Int) -> String {
   97|      0|        let min = (seconds / 60) % 60
   98|      0|        let hour = seconds / 3600
   99|      0|        return String(format:"%2ih%02i", hour, min)
  100|      0|    }
  101|      0|    
  102|      0|    func createStatistics(){
  103|      0|        //get date
  104|      0|        let date = Date()
  105|      0|        let formatter = DateFormatter()
  106|      0|        formatter.dateFormat = "MM.yyyy"
  107|      0|        let key = formatter.string(from: date)
  108|      0|        
  109|      0|        var startedNewMonth: Bool {
  110|      0|            get {
  111|      0|                return UserDefaults.standard.bool(forKey: key)
  112|       |            }
  113|       |            set {
  114|       |                UserDefaults.standard.set(newValue, forKey: key)
  115|       |            }
  116|      0|        }
  117|      0|        //Check if the date regard a new month
  118|      0|        if startedNewMonth {return}
  119|      0|        
  120|      0|        //Convert it to int
  121|       |        let calendar = Calendar.current
  122|      0|        let components = calendar.dateComponents([.year, .month], from: date)
  123|      0|        
  124|      0|        guard let year = components.year,
  125|      0|            let month = components.month else {return}
  126|      0|        //implement it in statistics
  127|      0|        let statisticsBO = StatisticBO()
  128|      0|        statisticsBO.createStatistic(id: UUID(), focusTime: 0, lostFocusTime: 0, restTime: 0, qtdLostFocus: 0, year: year, month: month) { (result) in
  129|      0|            switch result {
  130|      0|                
  131|      0|            case .success(_): break
  132|      0|            case .failure(let error):
  133|      0|                print(error.localizedDescription)
  134|      0|            }
  135|      0|        }
  136|      0|        //set the month to checked
  137|      0|        startedNewMonth = true
  138|      0|    }
  139|      0|    
  140|      0|    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
  141|      0|        if segue.identifier == "GoToTimer" {
  142|      0|            if let timerViewController = segue.destination as? TimerViewController {
  143|      0|                guard let index = selectedProjectId else {return}
  144|      0|                //pass projects id to timer
  145|      0|                timerViewController.timeTracker.projectUuid = projects[index].id
  146|      0|                timerViewController.id = projects[index].id
  147|      0|                
  148|      0|                selectedProjectId = nil
  149|      0|            }
  150|      0|        }
  151|      0|    }
  152|      0|    
  153|      0|    /// Description: Function to ensure that the user really wants to delete a project
  154|      0|    /// - Parameters:
  155|      0|    ///   - proj: The project thst the user wants to delete
  156|      0|    ///   - indexPath: The array reference index from projects
  157|      0|    func deleteProject(proj: Project, indexPath: IndexPath){
  158|      0|        let titleLocalized = NSLocalizedString("Delete Project", comment: "")
  159|       |        let messageLocalized = NSLocalizedString("Delete Message", comment: "")
  160|      0|        let alert = UIAlertController(title: titleLocalized, message: messageLocalized, preferredStyle: .alert)
  161|      0|        
  162|      0|        let yesLocalized = NSLocalizedString("Yes", comment: "")
  163|      0|        let alertActionOK = UIAlertAction(title: yesLocalized, style: .default){ (action) in
  164|      0|            self.projectBO.delete(uuid: proj.id) { (result) in
  165|      0|                switch result {
  166|      0|                case .success():
  167|      0|                    
  168|      0|                    /// Add delete animation 
  169|      0|                    UIView.animate(withDuration: 0.5, animations: {
  170|      0|                        self.collectionView.cellForItem(at: indexPath)?.alpha = 0.0
  171|      0|                    }, completion: { (_) in
  172|       |                        self.projects.remove(at: indexPath.row)
  173|       |                        self.collectionView.reloadData()
  174|       |                    })
  175|       |                    break
  176|       |                case .failure(let error):
  177|      0|                    print(error.localizedDescription)
  178|      0|                    break
  179|      0|                }
  180|      0|            }
  181|      0|        }
  182|      0|        
  183|      0|        let cancelLocalized = NSLocalizedString("Cancel", comment: "")
  184|      0|        let alertActionCancel = UIAlertAction(title: cancelLocalized, style: .cancel, handler: nil)
  185|      0|        
  186|      0|        alert.addAction(alertActionCancel)
  187|      0|        alert.addAction(alertActionOK)
  188|      0|        
  189|      0|        self.present(alert, animated: true)
  190|      0|    }
  191|      0|}
  192|      0|
  193|      0|extension ProjectViewController: ReloadProjectListDelegate {
  194|      0|    func reloadList() {
  195|      0|        projectBO.retrieve(completion: { result in
  196|      0|            switch result {
  197|      0|            case .success(let projects):
  198|      0|                self.projects = projects
  199|      0|                
  200|      0|                collectionView.reloadData()
  201|      0|            case .failure(let error):
  202|      0|                print(error.localizedDescription)
  203|      0|            }
  204|      0|        })
  205|      0|    }
  206|      0|}
  207|      0|
  208|      0|extension ProjectViewController: UICollectionViewDelegate {
  209|      0|    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
  210|      0|        self.selectedProjectId = indexPath.row
  211|       |        performSegue(withIdentifier: "GoToTimer", sender: self)
  212|       |    }
  213|       |    
  214|      0|    
  215|      0|    /// Menu configuration
  216|      0|    func collectionView(_ collectionView: UICollectionView, contextMenuConfigurationForItemAt indexPath: IndexPath, point: CGPoint) -> UIContextMenuConfiguration? {
  217|      0|        let proj = self.projects[indexPath.row]
  218|      0|        
  219|      0|        let editLocalized = NSLocalizedString("Edit", comment: "")
  220|      0|        let edit = UIAction(title: editLocalized, image: UIImage(systemName: "square.and.pencil"), handler: { (edit) in
  221|      0|            self.selectedProjectId = indexPath.item
  222|      0|            self.goToNewProjectViewController()
  223|      0|        })
  224|      0|        
  225|      0|        let deleteLocalized = NSLocalizedString("Delete", comment: "")
  226|      0|        let delete = UIAction(title: deleteLocalized, image: UIImage(systemName: "trash"), attributes: .destructive ,handler: { (delete) in
  227|       |            
  228|       |            self.deleteProject(proj: proj, indexPath: indexPath)
  229|       |        })
  230|      0|        let actionsLocalized = NSLocalizedString("Actions", comment: "")
  231|      0|        return UIContextMenuConfiguration(identifier: nil,
  232|      0|                                          previewProvider: nil) { _ in
  233|      0|                                            UIMenu(title: actionsLocalized, children: [edit, delete])
  234|       |        }
  235|       |    }
  236|       |}
  237|      0|
  238|      0|
  239|      0|extension ProjectViewController: UICollectionViewDataSource {
  240|      0|    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
  241|      0|        /// When projects is empty show background Image
  242|      0|        if projects.count == 0 {
  243|      0|            UIView.animate(withDuration: 0.5) {
  244|      0|                self.backgroundImage.isHidden = false
  245|      0|                self.collectionView.isHidden = true
  246|      0|            }
  247|      0|        } else {
  248|      0|            UIView.animate(withDuration: 0.5) {
  249|      0|                self.backgroundImage.isHidden = true
  250|      0|                self.collectionView.isHidden = false
  251|      0|            }
  252|      0|        }
  253|      0|        
  254|      0|        //        return ProjectDAO.list.count
  255|      0|        return projects.count
  256|      0|    }
  257|       |    
  258|       |    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
  259|       |        guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath) as? ProjectCollectionViewCell else {
  260|       |            return ProjectCollectionViewCell()
  261|      0|        }
  262|      0|        
  263|      0|        cell.projectNameLabel.text = projects[indexPath.row].name
  264|      0|        cell.backgroundColor = projects[indexPath.row].color
  265|      0|        
  266|      0|        return cell
  267|      0|    }
  268|      0|}
  269|      0|
  270|      0|extension ProjectViewController: UICollectionViewDelegateFlowLayout {
  271|      0|    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {
  272|      0|        return UIEdgeInsets(top: 0, left: 2, bottom: 0, right: 2)
  273|      0|    }
  274|      0|    
  275|      0|    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
  276|      0|        let collectionViewWidth = collectionView.bounds.width
  277|      0|        return CGSize(width: collectionViewWidth * 0.47, height: collectionViewWidth * 0.47)
  278|       |    }
  279|      0|    
  280|      0|    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
  281|      0|        return 0
  282|      0|    }
  283|      0|    
  284|      0|    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
  285|      0|        return 14
  286|      0|    }
  287|      0|}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Controller/Projects/NewProjectViewController.swift:
    1|       |//
    2|       |//  NewProjectViewController.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 29/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class NewProjectViewController: UIViewController{
   12|       |    
   13|       |    @IBOutlet weak var projectNameLabel: UITextField!
   14|       |    @IBOutlet weak var titleLabel: UILabel!
   15|       |    @IBOutlet var buttons: [UIButton]!
   16|       |    @IBOutlet var checks: [UIImageView]!
   17|       |    
   18|       |    var currentButtonIndex = 0
   19|       |    
   20|      0|    let projectBO = ProjectBO()
   21|       |    
   22|       |    var project: Project?
   23|      0|    var projectName = String()
   24|      0|    var projectColor = UIColor(red: 0.77, green: 0.87, blue: 0.96, alpha: 1.00)
   25|       |    
   26|       |    weak var delegate: ReloadProjectListDelegate?
   27|       |    
   28|      0|    override func viewDidLoad() {
   29|      0|        super.viewDidLoad()
   30|      0|//        self.dismissKeyboard()
   31|      0|
   32|      0|        
   33|      0|        projectNameLabel.delegate = self
   34|      0|        
   35|      0|        // uncheck all colors
   36|      0|        for check in checks {
   37|      0|            check.isHidden = true
   38|      0|        }
   39|      0|        
   40|      0|        // if projects is not null
   41|      0|        if let project = project {
   42|      0|            projectNameLabel.text = project.name
   43|      0|            projectColor = project.color
   44|      0|            titleLabel.text = NSLocalizedString("Edit project", comment: "")
   45|      0|            
   46|      0|            // show current project color
   47|      0|            if let button = buttons.filter({$0.backgroundColor?.description == project.color.description}).first,
   48|      0|                let index = buttons.firstIndex(of: button) {
   49|      0|                checks[index].isHidden = false
   50|      0|                currentButtonIndex = index
   51|      0|            }
   52|      0|            
   53|      0|        }
   54|      0|        else {
   55|      0|            titleLabel.text = NSLocalizedString("Add project", comment: "")
   56|      0|            projectColor = buttons[0].backgroundColor!
   57|      0|            checks[0].isHidden = false
   58|      0|        }
   59|      0|        
   60|      0|        UIApplication.shared.sendAction(#selector(UIApplication.resignFirstResponder), to: nil, from: nil, for: nil)
   61|      0|        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow), name: UIResponder.keyboardWillShowNotification, object: nil)
   62|      0|        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide), name: UIResponder.keyboardWillHideNotification, object: nil)
   63|      0|    }
   64|       |    
   65|      0|    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
   66|      0|        UIApplication.shared.sendAction(#selector(UIApplication.resignFirstResponder), to: nil, from: nil, for: nil)
   67|      0|        view.endEditing(true)
   68|      0|    }
   69|       |    
   70|      0|    @IBAction func onClickColor(_ sender: UIButton) {
   71|      0|        if let color = sender.backgroundColor {
   72|      0|            projectColor = color
   73|      0|        }
   74|      0|        
   75|      0|        if let index = buttons.firstIndex(of: sender) {
   76|      0|            checks[index].isHidden = false
   77|      0|            if currentButtonIndex != index {
   78|      0|                checks[currentButtonIndex].isHidden = true
   79|      0|            }
   80|      0|            currentButtonIndex = index
   81|      0|        }
   82|      0|        
   83|      0|    }
   84|       |    
   85|      0|    @IBAction func onClickSave(_ sender: Any) {
   86|      0|        saveProject()
   87|      0|    }
   88|       |    
   89|      0|    @IBAction func cancelButtonAction(_ sender: Any) {
   90|      0|        dismiss(animated: true)
   91|      0|    }
   92|       |    
   93|      0|    private func saveProject() {
   94|      0|        
   95|      0|        guard projectNameLabel.text != nil else { return }
   96|      0|        
   97|      0|        projectName = projectNameLabel.text!
   98|      0|        
   99|      0|        if project == nil {
  100|      0|            createProject()
  101|      0|        }
  102|      0|        else {
  103|      0|            updateProject()
  104|      0|        }
  105|      0|        
  106|      0|    }
  107|       |    
  108|      0|    private func createProject() {
  109|      0|        guard validateName() else { return }
  110|      0|        
  111|      0|        projectBO.create(name: projectName, color: projectColor, completion: { result in
  112|      0|            
  113|      0|            switch result {
  114|      0|                
  115|      0|            case .success(_):
  116|      0|                dismiss(animated: true)
  117|      0|                delegate?.reloadList()
  118|      0|            case .failure(let error):
  119|      0|                self.showAlert(title: "Error", message: error.localizedDescription)
  120|      0|            }
  121|      0|            
  122|      0|        })
  123|      0|    }
  124|       |    
  125|      0|    private func updateProject() {
  126|      0|        guard validateName() else { return }
  127|      0|        
  128|      0|        project?.name = projectName
  129|      0|        project?.color = projectColor
  130|      0|        
  131|      0|        projectBO.update(project: project!, completion: { result in
  132|      0|            switch result {
  133|      0|            case .success():
  134|      0|                dismiss(animated: true)
  135|      0|                delegate?.reloadList()
  136|      0|            case .failure(let error):
  137|      0|                self.showAlert(title: "Error", message: error.localizedDescription )
  138|      0|            }
  139|      0|        })
  140|      0|        
  141|      0|    }
  142|       |    
  143|      0|    private func validateName() -> Bool {
  144|      0|        guard projectName.count != projectName.compactMap({ $0 == " " ? $0 : nil }).count else {
  145|      0|            showAlert(title: "Nome do projeto não pode ser vazio!")
  146|      0|            return false
  147|      0|        }
  148|      0|        
  149|      0|        projectName = removeSpacesFromStartAndEnd(ofThe: projectName)
  150|      0|        
  151|      0|        projectNameLabel.resignFirstResponder()
  152|      0|        return true
  153|      0|    }
  154|       |    
  155|      0|    private func removeSpacesFromStartAndEnd(ofThe string: String) -> String {
  156|      0|        var s = string
  157|      0|        if s.first == " " {
  158|      0|            s.removeFirst()
  159|      0|            s = removeSpacesFromStartAndEnd(ofThe: s)
  160|      0|        }
  161|      0|        else if s.last == " " {
  162|      0|            s.removeLast()
  163|      0|            s = removeSpacesFromStartAndEnd(ofThe: s)
  164|      0|        }
  165|      0|        return s
  166|      0|    }
  167|       |    
  168|      0|    func showAlert(title: String, message: String? = nil) {
  169|      0|        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
  170|      0|        let action = UIAlertAction(title: "Ok", style: .default, handler: nil)
  171|      0|        alert.addAction(action)
  172|      0|        present(alert, animated: true)
  173|      0|    }
  174|       |    
  175|      0|    @objc func keyboardWillShow(notification: NSNotification) {
  176|      0|        if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue {
  177|      0|            if self.view.frame.origin.y == 0 {
  178|      0|                self.view.frame.origin.y -= keyboardSize.height / 2
  179|      0|            }
  180|      0|        }
  181|      0|    }
  182|       |    
  183|      0|    @objc func keyboardWillHide(notification: NSNotification) {
  184|      0|        if self.view.frame.origin.y != 0 {
  185|      0|            self.view.frame.origin.y = 0
  186|      0|        }
  187|      0|    }
  188|       |}
  189|       |
  190|       |extension NewProjectViewController: UITextFieldDelegate{
  191|      0|    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
  192|      0|        self.view.endEditing(true)
  193|      0|        return false
  194|      0|    }
  195|       |    
  196|      0|    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
  197|      0|        guard let text = textField.text else { return false }
  198|      0|        return text.count +  (string.count - range.length) <= 22
  199|      0|    }
  200|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Controller/StatisticsViewController.swift:
    1|       |//
    2|       |//  StatisticsViewController.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Caio Azevedo on 06/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Charts
   11|       |
   12|       |class StatisticsViewController: UIViewController {
   13|       |
   14|       |//MARK:- Atributes
   15|       |    @IBOutlet weak var tableView: UITableView!
   16|       |    @IBOutlet weak var circleChart: PieChartView!
   17|       |    @IBOutlet weak var labelMonth: UILabel!
   18|       |    @IBOutlet weak var totalFocusedLabel: UILabel!
   19|       |    @IBOutlet weak var totalDistractionsLabel: UILabel!
   20|       |    @IBOutlet weak var totalBreaksLabel: UILabel!
   21|       |    @IBOutlet weak var chartBackgroundImage: UIImageView!
   22|       |    @IBOutlet weak var noDataLabel: UILabel!
   23|      0|    @IBOutlet weak var tryRunLabel: UILabel!
   24|       |    
   25|       |    var dataChartBO = DataChartBO()
   26|      0|    var statistics: [Statistic]?
   27|      0|    
   28|      0|    var currentMonth = Int()
   29|      0|    var currentYear = Int()
   30|       |    var month = Int()
   31|       |    var year = Int()
   32|      0|    
   33|      0|//MARK:- Life Cicle Functions
   34|      0|    override func viewDidLoad() {
   35|      0|        super.viewDidLoad()
   36|      0|        tableView.dataSource = self
   37|      0|        tableView.delegate = self
   38|      0|        
   39|      0|        let currentDate = Date()
   40|      0|        self.currentMonth = Calendar.current.component(.month, from: currentDate)
   41|      0|        self.currentYear = Calendar.current.component(.year, from: currentDate)
   42|      0|        
   43|      0|        self.month = self.currentMonth
   44|      0|        self.year = self.currentYear
   45|      0|        
   46|      0|        let currentStatistic = self.filterByMonth(month: self.currentMonth, year: self.currentYear)
   47|      0|        
   48|      0|        self.showStatistics(statistic: currentStatistic)
   49|      0|        
   50|      0|        chartConfig()
   51|      0|        
   52|      0|        /// Load the pie chart with projects data
   53|      0|        dataChartBO.loadChartData { (chartData) in
   54|      0|            self.circleChart.data = chartData
   55|      0|            
   56|      0|            self.circleChart.isHidden = self.dataChartBO.isHidden
   57|      0|            self.chartBackgroundImage.isHidden = !self.circleChart.isHidden
   58|       |            self.noDataLabel.isHidden = !self.circleChart.isHidden
   59|       |            self.tryRunLabel.isHidden = !self.circleChart.isHidden
   60|       |        }
   61|       |    }
   62|      0|
   63|      0|//MARK:- Functions
   64|      0|    
   65|      0|    /// Description:  Chart appearance configuration
   66|      0|    func chartConfig(){
   67|      0|        circleChart.holeRadiusPercent = 0.7
   68|      0|        circleChart.transparentCircleColor = UIColor.clear
   69|      0|        circleChart.legend.enabled = false
   70|       |        circleChart.highlightPerTapEnabled = false
   71|      0|        circleChart.holeColor = UIColor.clear
   72|      0|        circleChart.entryLabelColor = UIColor(red: 0.20, green: 0.20, blue: 0.20, alpha: 1.00)
   73|      0|    }
   74|      0|    
   75|      0|    func convetTime(seconds: Int) -> String {
   76|      0|        print("Time -->> \(seconds)")
   77|       |        let min = (seconds / 60) % 60
   78|      0|        let hour = seconds / 3600
   79|      0|        return String(format:"%2ih%02i", hour, min)
   80|      0|    }
   81|      0|    
   82|      0|    func getStatistics(){
   83|      0|        StatisticBO().retrieveStatistic { (results) in
   84|      0|            switch results {
   85|      0|            case .success(let statisticsRetrieved):
   86|      0|                self.statistics = statisticsRetrieved
   87|      0|            case .failure(let error):
   88|       |                print(error.localizedDescription)
   89|      0|            }
   90|      0|        }
   91|      0|    }
   92|      0|    
   93|      0|    func filterByMonth(month: Int, year: Int) -> Statistic? {
   94|      0|        self.getStatistics()
   95|      0|        
   96|      0|        guard let statisticsArray = self.statistics else {
   97|      0|            return nil
   98|      0|        }
   99|      0|
  100|      0|        for statistic in statisticsArray {
  101|      0|            if statistic.month == month && statistic.year == year {
  102|      0|                return statistic
  103|      0|            }
  104|      0|        }
  105|      0|        
  106|      0|        self.month = self.currentMonth
  107|       |        self.year = self.currentYear
  108|      0|        
  109|      0|        return filterByMonth(month: self.currentMonth, year: self.currentYear)
  110|      0|    }
  111|      0|    
  112|      0|    func showStatistics(statistic: Statistic?) {
  113|      0|        self.labelMonth.text = self.getMonthString(monthNum: statistic?.month ?? self.currentMonth)
  114|      0|        
  115|       |        self.totalBreaksLabel.text = convetTime(seconds: statistic?.restTime ?? 0)
  116|      0|        self.totalFocusedLabel.text = convetTime(seconds: statistic?.focusTime ?? 0)
  117|      0|        self.totalDistractionsLabel.text = convetTime(seconds: statistic?.lostFocusTime ?? 0)
  118|      0|    }
  119|      0|    
  120|      0|    func dateValidation(month: Int, year: Int){
  121|      0|        if self.month > 12 {
  122|      0|            self.month = 1
  123|      0|            self.year += 1
  124|      0|        } else if self.month < 1 {
  125|       |            self.month = 12
  126|      0|            self.year -= 1
  127|      0|        }
  128|      0|    }
  129|      0|    
  130|      0|    @IBAction func advanceMonth(_ sender: Any) {
  131|      0|        self.month += 1
  132|      0|        
  133|      0|        dateValidation(month: self.month, year: self.year)
  134|      0|        
  135|      0|        let statistic = filterByMonth(month: self.month, year: self.year)
  136|       |        
  137|      0|        self.showStatistics(statistic: statistic)
  138|      0|        
  139|      0|    }
  140|      0|    
  141|      0|    @IBAction func backMonth(_ sender: Any) {
  142|      0|        self.month -= 1
  143|      0|        
  144|      0|        dateValidation(month: self.month, year: self.year)
  145|      0|        
  146|       |        let statistic = filterByMonth(month: self.month, year: self.year)
  147|      0|        
  148|      0|        self.showStatistics(statistic: statistic)
  149|      0|    }
  150|      0|    
  151|      0|    func getMonthString(monthNum: Int) -> String {
  152|      0|        switch monthNum {
  153|      0|            case 01:
  154|      0|                return NSLocalizedString("January", comment: "")
  155|      0|            case 02:
  156|      0|                return NSLocalizedString("February", comment: "")
  157|      0|            case 03:
  158|      0|                return NSLocalizedString("March", comment: "")
  159|      0|            case 04:
  160|      0|                return NSLocalizedString("April", comment: "")
  161|      0|            case 05:
  162|      0|                return NSLocalizedString("May", comment: "")
  163|      0|            case 06:
  164|      0|                return NSLocalizedString("June", comment: "")
  165|      0|            case 07:
  166|      0|                return NSLocalizedString("July", comment: "")
  167|      0|            case 08:
  168|      0|                return NSLocalizedString("August", comment: "")
  169|      0|            case 09:
  170|      0|                return NSLocalizedString("September", comment: "")
  171|      0|            case 10:
  172|      0|                return NSLocalizedString("October", comment: "")
  173|      0|            case 11:
  174|      0|                return NSLocalizedString("November", comment: "")
  175|      0|            case 12:
  176|      0|                return NSLocalizedString("December", comment: "")
  177|       |            default:
  178|       |                return "Month"
  179|       |        }
  180|       |    }
  181|      0|    
  182|      0|}
  183|      0|
  184|       |extension StatisticsViewController: UITableViewDataSource, UITableViewDelegate {
  185|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  186|      0|        return dataChartBO.projects.count
  187|      0|    }
  188|      0|    
  189|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  190|      0|        let cell = tableView.dequeueReusableCell(withIdentifier: "projectStatisticsCell") as! ProjectStatisticsCell
  191|      0|        cell.colorView.backgroundColor = dataChartBO.projectColors[indexPath.row] as UIColor
  192|      0|        cell.projectNameLabel.text = dataChartBO.projects[indexPath.row].name
  193|       |        cell.projectTimeLabel.text = convetTime(seconds: dataChartBO.timeProjects[indexPath.row])
  194|       |        
  195|       |        return cell
  196|       |    }
  197|       |    
  198|       |    
  199|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Controller/Timer/TimerPopUpViewController.swift:
    1|       |//
    2|       |//  TimerPopUpViewController.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Fábio Maciel de Sousa on 14/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |//Types of messages it should display
   11|       |enum PopUpMessages{
   12|       |    case focus
   13|       |    case pause
   14|       |    case givenUp
   15|       |}
   16|       |
   17|       |class TimerPopUpViewController: UIViewController {
   18|       |
   19|       |    //MARK: Atributes
   20|      0|    var popUpState = PopUpMessages.focus
   21|       |    //Dictionary
   22|      0|    var titleDict = [PopUpMessages:String]()
   23|      0|    var textDict = [PopUpMessages:String]()
   24|      0|    var imageDict = [PopUpMessages:UIImage?]()
   25|      0|    var buttonDict = [PopUpMessages:String]()
   26|       |    //ImageView
   27|       |    @IBOutlet weak var popUpImage: UIImageView!
   28|       |    //Labels
   29|       |    @IBOutlet weak var titleLabel: UILabel!
   30|       |    @IBOutlet weak var textLabel: UILabel!
   31|       |    @IBOutlet weak var button: UIButton!
   32|       |    @IBOutlet weak var cancelButton: UIButton!
   33|       |    //MARK: Methods
   34|      0|    override func viewDidLoad() {
   35|      0|        super.viewDidLoad()
   36|      0|        // Do any additional setup after loading the view.
   37|      0|        setupDictionary()
   38|      0|        setupPopUp()
   39|      0|        self.adaptAutoLayout()
   40|      0|        
   41|       |        updateNavigationController()
   42|       |    }
   43|      0|    
   44|      0|    private func updateNavigationController() {
   45|      0|        let storyboard = UIStoryboard(name: "Timer", bundle: nil)
   46|      0|        guard let vc = storyboard.instantiateViewController(withIdentifier: "vc") as? TimerViewController else { return }
   47|      0|        
   48|      0|        vc.enablePopViewController(true)
   49|      0|    }
   50|      0|    
   51|      0|    //Set up the texts for when timer ends
   52|      0|    func setupDictionary(){
   53|      0|        //focus
   54|      0|        titleDict[.focus] = NSLocalizedString("Focus title", comment: "")
   55|      0|        textDict[.focus] = NSLocalizedString("Focus text", comment: "")
   56|      0|        imageDict[.focus] = UIImage(named: "trophy")
   57|      0|        buttonDict[.focus] = NSLocalizedString("Break", comment: "")
   58|      0|        //pause
   59|      0|        titleDict[.pause] = NSLocalizedString("Break title", comment: "")
   60|       |        textDict[.pause] = NSLocalizedString("Break text", comment: "")
   61|      0|        imageDict[.pause] = UIImage(named: "break")
   62|      0|        buttonDict[.pause] = NSLocalizedString("Focus", comment: "")
   63|      0|        //give up
   64|      0|        titleDict[.givenUp] = NSLocalizedString("Give Up title", comment: "")
   65|      0|        textDict[.givenUp] = NSLocalizedString("Give Up text", comment: "")
   66|      0|        imageDict[.givenUp] = UIImage(named: "giveUp")
   67|      0|        buttonDict[.givenUp] = NSLocalizedString("Retry", comment: "")
   68|      0|    }
   69|      0|    //Set all labels and buttons
   70|      0|    func setupPopUp(){
   71|       |        guard let title = titleDict[popUpState] else {return}
   72|      0|        guard let text = textDict[popUpState] else {return}
   73|      0|        guard let image = imageDict[popUpState] else {return}
   74|      0|        guard let buttonText = buttonDict[popUpState] else {return}
   75|      0|        popUpImage.image = image
   76|      0|        titleLabel.text = title
   77|      0|        textLabel.text = text
   78|      0|        button.setTitle(buttonText, for: .normal)
   79|      0|    }
   80|      0|    //Go to next step Focus/Break
   81|      0|    @IBAction func goToNextStep(_ sender: Any) {
   82|      0|        guard let navigation = self.presentingViewController as? UINavigationController else{return}
   83|      0|        guard let pvc = navigation.topViewController as? TimerViewController else {return}
   84|      0|        if popUpState == .givenUp{
   85|       |            pvc.timeTracker.state = .focus
   86|      0|        }else{
   87|      0|            pvc.timeTracker.state = pvc.timeTracker.changeCicle
   88|      0|        }
   89|      0|        let time = pvc.timeTracker.secondsToString(with: pvc.timeTracker.convertedTimeValue)
   90|      0|        pvc.timerLabel.text = time
   91|      0|        pvc.startTimer(pvc.btnStart)
   92|      0|        dismiss(animated: true)
   93|      0|    }
   94|       |    //Cancel timer and go back to menu
   95|       |    @IBAction func Cancel(_ sender: Any) {
   96|       |//        guard let navigation = self.presentingViewController as? UINavigationController else{return}
   97|       |//        guard let pvc = navigation.topViewController as? TimerViewController else {return}
   98|       |//        self.dismiss(animated: true) {
   99|       |//            pvc.dismiss(animated: true)
  100|       |//        }
  101|       |        dismiss(animated: true)
  102|       |    }
  103|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Controller/Timer/TimerViewController.swift:
    1|       |//
    2|       |//  TimerViewController.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Fábio Maciel de Sousa on 29/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import GameplayKit
   11|       |import AudioUnit
   12|       |
   13|       |///Place holder ViewController
   14|       |class TimerViewController: UIViewController {
   15|       |    
   16|       |    //Atributes
   17|       |    
   18|       |    lazy var states = [
   19|       |        NormalState(),
   20|       |        SaveState(),
   21|       |        UpdateState()
   22|       |    ]
   23|       |    lazy var taskState = GKStateMachine(states: self.states)
   24|       |    
   25|      0|    let timeTracker = TimeTrackerBO()
   26|       |    var timeRecover: TimeRecoverBO?
   27|       |    var id: UUID?
   28|       |    var project: Project?
   29|      0|    let projectBO = ProjectBO()
   30|      0|    let taskBO = TaskBO()
   31|      0|    var tasks: [Task] = []
   32|       |    //Properties
   33|       |    ///the validation for the minimum value
   34|      0|    var minimumDecrement: Int{
   35|      0|        //TODO: switch 0 for a generic number
   36|      0|        if timeTracker.configTime - 5  < 5{
   37|      0|            shakeView(timerLabel)
   38|      0|            return 5
   39|      0|        }
   40|      0|        return timeTracker.configTime - 5
   41|      0|    }
   42|       |    ///the validation for the maximum value
   43|      0|    var maximumDecrement: Int{
   44|      0|        //TODO: switch 60 for a generic number
   45|      0|        if timeTracker.configTime + 5  > 480{
   46|      0|            shakeView(timerLabel)
   47|      0|            return 480
   48|      0|        }
   49|      0|        return timeTracker.configTime + 5
   50|      0|    }
   51|       |    
   52|       |    //Buttons, Labels
   53|       |    @IBOutlet weak var btnStart: UIButton!
   54|       |    @IBOutlet weak var tableView: UITableView!
   55|       |    @IBOutlet weak var timerLabel: UILabel!
   56|       |    @IBOutlet var timeConfigButtons: [UIButton]!
   57|       |    @IBOutlet weak var stateLabel: UILabel!
   58|       |    @IBOutlet weak var btnLabelTask: UIButton!
   59|       |    @IBOutlet weak var btnInscrease: UIButton!
   60|       |    @IBOutlet weak var btnDecrease: UIButton!
   61|       |    
   62|       |    //Ring View
   63|       |    @IBOutlet weak var projectColor: UIView!
   64|       |    @IBOutlet weak var ringView: AnimatedRingView!
   65|       |    
   66|      0|    override func viewDidLoad() {
   67|      0|        super.viewDidLoad()
   68|      0|        
   69|      0|        loadProject()
   70|      0|        loadTasks()
   71|      0|        
   72|      0|
   73|      0|        tableView.allowsSelection = false
   74|      0|        self.navigationController?.navigationBar.setBackgroundImage(UIImage(), for: .default)
   75|      0|        self.navigationController?.navigationBar.shadowImage = UIImage()
   76|      0|//        self.navigationController?.navigationBar.tintColor = UIColor(red: 0.35, green: 0.49, blue: 0.49, alpha: 1.00)
   77|      0|        self.btnLabelTask.contentHorizontalAlignment = UIControl.ContentHorizontalAlignment.left
   78|      0|        
   79|      0|        self.navigationItem.rightBarButtonItem = nil
   80|      0|        
   81|      0|        self.btnStart.layer.cornerRadius = 10.0
   82|      0|        self.btnStart.backgroundColor = UIColor(red: 0.35, green: 0.49, blue: 0.49, alpha: 1.00)
   83|      0|        self.tableView.separatorColor = .clear
   84|      0|        
   85|      0|        // Do any additional setup after loading the view.
   86|      0|        timerLabel.text = timeTracker.secondsToString(with: timeTracker.convertedTimeValue)
   87|      0|        
   88|      0|        timeTracker.state = .focus
   89|      0|        
   90|      0|        self.timeRecover = TimeRecoverBO(timer: timeTracker)
   91|      0|        
   92|      0|        /// Get Scene Deleegate
   93|      0|        let scene = UIApplication.shared.connectedScenes.first
   94|      0|        if let sd : SceneDelegate = (scene?.delegate as? SceneDelegate) {
   95|      0|            sd.timer = self.timeTracker
   96|      0|            sd.timeRecover = self.timeRecover
   97|      0|            sd.ringView = self.ringView
   98|      0|        }
   99|      0|        
  100|      0|        self.stateLabel.text = project?.name
  101|      0|        projectColor.backgroundColor = project?.color
  102|      0|        projectColor.layer.cornerRadius = 15.0
  103|      0|        
  104|      0|        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow), name: UIResponder.keyboardWillShowNotification, object: nil)
  105|      0|        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide), name: UIResponder.keyboardWillHideNotification, object: nil)
  106|      0|        
  107|      0|        self.taskState.enter(NormalState.self)
  108|      0|        
  109|       |        btnStart.addTarget(self, action: #selector(hapticFeedbackMedium), for: .touchUpInside)
  110|      0|        btnInscrease.addTarget(self, action: #selector(hapticFeedbackSelection), for: .touchUpInside)
  111|      0|        btnDecrease.addTarget(self, action: #selector(hapticFeedbackSelection), for: .touchUpInside)
  112|      0|    }
  113|      0|    
  114|       |    @objc private func hapticFeedbackSelection() {
  115|      0|        UISelectionFeedbackGenerator().selectionChanged()
  116|      0|    }
  117|      0|    
  118|      0|    @objc private func hapticFeedbackMedium() {
  119|      0|        UIImpactFeedbackGenerator(style: .medium).impactOccurred()
  120|      0|    }
  121|      0|    
  122|      0|    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
  123|      0|        UIApplication.shared.sendAction(#selector(UIApplication.resignFirstResponder), to: nil, from: nil, for: nil)
  124|      0|        view.endEditing(true)
  125|      0|    }
  126|      0|    
  127|       |    func loadProject(){
  128|      0|        guard let id = self.id else { return }
  129|      0|        projectBO.fetch(id: id, completion: { result in
  130|      0|            switch result {
  131|      0|            case .success(let project):
  132|      0|                self.project = project
  133|      0|                tableView.reloadData()
  134|      0|            case .failure(let error):
  135|      0|                print(error)
  136|      0|            }
  137|      0|        })
  138|      0|    }
  139|      0|    
  140|      0|    func loadTasks(){
  141|      0|        guard let id = self.id else { return }
  142|      0|        taskBO.retrieve(id: id, completion: { result in
  143|       |            
  144|       |            switch result {
  145|       |            case .success(let tasks):
  146|      0|                self.tasks = tasks.sorted(by: { task, task2 in
  147|      0|                    !task.state && task2.state
  148|      0|                })
  149|      0|                tableView.reloadData()
  150|      0|            case .failure(let error):
  151|      0|                print(error)
  152|      0|            }
  153|      0|        })
  154|      0|    }
  155|      0|    
  156|      0|    
  157|      0|    //MARK: START TIMER
  158|      0|    
  159|      0|    func startTimer() {
  160|      0|        startTimer(btnStart)
  161|      0|    }
  162|      0|    
  163|      0|    @IBAction func startTimer(_ sender: UIButton) {
  164|      0|        if timeTracker.timer.isValid { // If it's running it stops instead
  165|      0|            stopTimer(sender)
  166|      0|            return
  167|      0|        }
  168|      0|        var text = NSLocalizedString("Give Up", comment: "")
  169|      0|        sender.setTitle(text, for: .normal)
  170|      0|        //Disable screen block
  171|      0|        UIApplication.shared.isIdleTimerDisabled = true
  172|      0|        //Start timer
  173|      0|        timeTracker.startTimer {time, hasEnded in
  174|      0|            if hasEnded{ // Focus timer ended
  175|      0|                text = NSLocalizedString("Start", comment: "")
  176|      0|                sender.setTitle(text, for: .normal)
  177|      0|                self.setConfigurationButtons()
  178|      0|                self.ringView.removeAnimation()
  179|       |                let popUpState = self.timeTracker.state == .focus ? PopUpMessages.focus : .pause
  180|       |                self.presentPopUp(state: popUpState)
  181|      0|                UIApplication.shared.isIdleTimerDisabled = false
  182|      0|//                AudioServicesPlayAlertSound(SystemSoundID(kSystemSoundID_Vibrate))
  183|      0|                self.enablePopViewController(true)
  184|      0|            }
  185|      0|            self.timerLabel.text = time
  186|      0|        }
  187|      0|        //Animate progression ring
  188|      0|        ringView.animateRing(From: 0, FromAngle: 0, To: 1, Duration: CFTimeInterval(timeTracker.convertedTimeValue))
  189|      0|        ringView.totalTime = CGFloat(timeTracker.convertedTimeValue)
  190|      0|        //Enable or disable buttons
  191|      0|        setConfigurationButtons()
  192|      0|        //set notification
  193|      0|        let notificationType = timeTracker.state == .focus ? NotificationType.didFinishFocus : .didFinishBreak
  194|      0|        let delay = TimeInterval(timeTracker.convertedTimeValue)
  195|      0|        AppNotificationBO.shared.sendNotification(type: notificationType, delay: delay)
  196|      0|        //        self.navigationController?.navigationBar.topItem?.hidesBackButton = true
  197|      0|        enablePopViewController(false)
  198|       |    }
  199|       |    
  200|      0|    //MARK: STOP TIMER
  201|      0|    func stopTimer(_ sender: UIButton) {
  202|      0|        let text = NSLocalizedString("Start", comment: "")
  203|      0|        sender.setTitle(text, for: .normal)
  204|      0|        
  205|      0|        timeTracker.stopTimer(){
  206|      0|            //TODO: Message for when the user gives up
  207|      0|//            self.stateLabel.text = self.timeTracker.state.rawValue
  208|       |            self.timerLabel.text = self.timeTracker.secondsToString(with: self.timeTracker.convertedTimeValue)
  209|       |            self.ringView.removeAnimation()
  210|      0|        }
  211|      0|        setConfigurationButtons()
  212|      0|        presentPopUp(state: .givenUp)
  213|      0|        UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
  214|      0|        //        self.navigationController?.navigationBar.topItem?.hidesBackButton = false
  215|      0|        enablePopViewController(true)
  216|      0|        //Disable screen block
  217|      0|        UIApplication.shared.isIdleTimerDisabled = false
  218|      0|    }
  219|      0|    
  220|      0|    func enablePopViewController(_ enable: Bool) {
  221|       |        if enable {
  222|       |            navigationController?.navigationBar.isUserInteractionEnabled = true
  223|      0|            navigationController?.interactivePopGestureRecognizer?.isEnabled = true
  224|      0|            navigationController?.navigationBar.tintColor = UIColor(named: "Contrast")
  225|      0|        }
  226|      0|        else {
  227|       |            navigationController?.navigationBar.isUserInteractionEnabled = false
  228|       |            navigationController?.interactivePopGestureRecognizer?.isEnabled = false
  229|      0|            navigationController?.navigationBar.tintColor = UIColor { (traitCollection: UITraitCollection) -> UIColor in
  230|      0|                let userInterfaceStyle = traitCollection.userInterfaceStyle
  231|      0|                return userInterfaceStyle == .unspecified || userInterfaceStyle == .light ? .lightGray : .darkGray
  232|      0|            }
  233|       |        }
  234|       |    }
  235|      0|    
  236|      0|    ///Show Pop Up
  237|      0|    func presentPopUp(state: PopUpMessages){
  238|      0|        if let tpvc = UIStoryboard.loadView(from: .TimerPopUp, identifier: .TimerPopUpID) as? TimerPopUpViewController {
  239|      0|            tpvc.modalTransitionStyle = .crossDissolve
  240|      0|            tpvc.modalPresentationStyle = .overCurrentContext
  241|       |            tpvc.popUpState = state
  242|       |            hapticFeedback(state)
  243|      0|            self.present(tpvc, animated: true)
  244|      0|        }
  245|      0|    }
  246|      0|    
  247|      0|    private func hapticFeedback(_ state: PopUpMessages) {
  248|      0|        if state == .focus || state == .pause {
  249|      0|            UINotificationFeedbackGenerator().notificationOccurred(.success)
  250|      0|        }
  251|      0|        else if state == .givenUp {
  252|      0|            UINotificationFeedbackGenerator().notificationOccurred(.error)
  253|      0|        }
  254|      0|    }
  255|      0|    
  256|      0|    ///Shake view animation
  257|      0|    func shakeView(_ viewToShake: UIView) {
  258|      0|        let animation = CABasicAnimation(keyPath: "position")
  259|      0|        animation.duration = 0.07
  260|      0|        animation.repeatCount = 4
  261|      0|        animation.autoreverses = true
  262|      0|        animation.fromValue = NSValue(cgPoint: CGPoint(x: viewToShake.center.x - 10, y: viewToShake.center.y))
  263|      0|        animation.toValue = NSValue(cgPoint: CGPoint(x: viewToShake.center.x + 10, y: viewToShake.center.y))
  264|      0|        
  265|      0|        viewToShake.layer.add(animation, forKey: "position")
  266|      0|//        AudioServicesPlayAlertSound(SystemSoundID(kSystemSoundID_Vibrate))
  267|       |        UINotificationFeedbackGenerator().notificationOccurred(.error)
  268|       |    }
  269|      0|    
  270|      0|    ///Increment timer for the count down
  271|      0|    @IBAction func incrementTimer(_ sender: Any) {
  272|       |        timeTracker.configTime = maximumDecrement
  273|      0|        timerLabel.text = timeTracker.secondsToString(with: timeTracker.convertedTimeValue)
  274|      0|    }
  275|      0|    
  276|       |    ///Decrement timer for the count down
  277|      0|    @IBAction func decrementTimer(_ sender: Any) {
  278|      0|        timeTracker.configTime = minimumDecrement
  279|      0|        timerLabel.text = timeTracker.secondsToString(with: timeTracker.convertedTimeValue)
  280|      0|    }
  281|      0|    
  282|      0|    ///Method for disabling the buttons that are configuring the Timer
  283|      0|    func setConfigurationButtons(){
  284|       |        let value = timeTracker.state != .pause && !timeTracker.timer.isValid ? true : false
  285|      0|        for button in timeConfigButtons{
  286|      0|            button.isEnabled = value
  287|      0|        }
  288|      0|    }
  289|      0|    
  290|       |    
  291|       |    func addTasks(){
  292|       |        taskState.enter(SaveState.self)
  293|       |        DispatchQueue.main.async {
  294|      0|            let task = Task(id: UUID(), description: "", createdAt: Date())
  295|      0|            self.tasks.append(task)
  296|      0|            let indexPath = IndexPath(row: self.tasks.count-1, section: 0)
  297|       |            
  298|      0|            self.tableView.beginUpdates()
  299|      0|            self.tableView.insertRows(at: [indexPath], with: .none)
  300|      0|            self.tableView.endUpdates()
  301|      0|            
  302|      0|            self.tableView.layoutIfNeeded()
  303|      0|            
  304|      0|            
  305|      0|            self.tableView.scrollToRow(at: indexPath,
  306|      0|                                       at: UITableView.ScrollPosition.bottom,
  307|      0|                                       animated: true)
  308|      0|            if let cell = self.tableView.cellForRow(at: indexPath) as? TaskTableViewCell {
  309|      0|                cell.taskTextField.becomeFirstResponder()
  310|      0|                cell.taskTextField.text = ""
  311|      0|            }
  312|      0|            
  313|      0|        }
  314|      0|    }
  315|      0|    
  316|      0|    
  317|      0|    @IBAction func btnAddTask(_ sender: Any) {
  318|      0|        addTasks()
  319|      0|    }
  320|      0|    
  321|      0|    @IBAction func labelAddTask(_ sender: Any) {
  322|      0|        addTasks()
  323|      0|    }
  324|      0|    
  325|      0|    @objc func keyboardWillShow(notification: NSNotification) {
  326|      0|        if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue {
  327|      0|            if self.view.frame.origin.y == 0 {
  328|      0|                self.view.frame.origin.y -= keyboardSize.height
  329|      0|            }
  330|      0|        }
  331|       |    }
  332|       |    
  333|      0|    @objc func keyboardWillHide(notification: NSNotification) {
  334|      0|        if self.view.frame.origin.y != 0 {
  335|      0|            self.view.frame.origin.y = 0
  336|      0|        }
  337|      0|    }
  338|      0|}
  339|      0|
  340|      0|extension TimerViewController: UITableViewDelegate, UITableViewDataSource {
  341|      0|    
  342|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  343|      0|        return tasks.count
  344|      0|    }
  345|      0|    
  346|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  347|      0|        let cell = tableView.dequeueReusableCell(withIdentifier: "TaskCell", for: indexPath) as! TaskTableViewCell
  348|      0|        
  349|      0|        cell.taskTextField.delegate = self
  350|      0|        cell.taskTextField.tag = indexPath.row
  351|      0|        cell.btnCheck.tag = indexPath.row
  352|       |        cell.delegate = self
  353|       |        
  354|       |        cell.btnCheck.setImage(UIImage(named: "Oval Copy 2"), for: .normal)
  355|       |        
  356|       |        cell.btnCheck.isSelected = tasks[indexPath.row].state
  357|       |        cell.taskTextField.text = tasks[indexPath.row].description
  358|       |        
  359|      0|        if tasks[indexPath.row].state {
  360|      0|            cell.taskTextField.addStrikeThrough()
  361|      0|
  362|      0|            if self.traitCollection.userInterfaceStyle == .dark {
  363|      0|                cell.taskTextField.textColor = UIColor(red: 0.44, green: 0.44, blue: 0.44, alpha: 1.00)
  364|       |            } else {
  365|      0|                cell.taskTextField.textColor = UIColor(red: 0.20, green: 0.20, blue: 0.20, alpha: 1.00)
  366|      0|            }
  367|      0|        }else {
  368|      0|
  369|       |            cell.taskTextField.clearStrikeThrough()
  370|      0|            if self.traitCollection.userInterfaceStyle == .dark {
  371|      0|                cell.taskTextField.textColor = UIColor(red: 0.96, green: 0.96, blue: 0.94, alpha: 1.00)
  372|      0|            } else {
  373|      0|                cell.taskTextField.textColor = UIColor(red: 0.44, green: 0.44, blue: 0.44, alpha: 1.00)
  374|      0|            }
  375|      0|        }
  376|      0|        
  377|      0|        return cell
  378|      0|    }
  379|      0|    
  380|      0|
  381|      0|     func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
  382|      0|        let contextItem = UIContextualAction(style: .destructive, title: "Delete") {  (contextualAction, view, boolValue) in
  383|      0|            self.taskBO.delete(uuid: self.tasks[indexPath.row].id, completion: { result in
  384|      0|                switch result {
  385|      0|                    
  386|      0|                case .success():
  387|      0|                    print("sucess")
  388|      0|                case .failure(let error):
  389|      0|                    print(error.localizedDescription)
  390|      0|                }
  391|      0|            })
  392|      0|            self.tasks.remove(at: indexPath.row)
  393|      0|            self.tableView.deleteRows(at: [indexPath], with: .automatic)
  394|      0|        }
  395|      0|        contextItem.backgroundColor = UIColor(red: 0.82, green: 0.59, blue: 0.48, alpha: 1.00)
  396|      0|        let swipeActions = UISwipeActionsConfiguration(actions: [contextItem])
  397|      0|
  398|      0|        return swipeActions
  399|      0|    }
  400|      0|
  401|      0|    
  402|      0|}
  403|      0|
  404|      0|// Tex field
  405|      0|extension TimerViewController: UITextFieldDelegate {
  406|      0|    
  407|      0|    func textFieldDidBeginEditing(_ textField: UITextField) {
  408|       |        if let currentState = self.taskState.currentState, currentState is NormalState {
  409|       |            self.taskState.enter(UpdateState.self)
  410|       |        }
  411|       |    }
  412|      0|    
  413|      0|    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
  414|      0|        textField.resignFirstResponder()
  415|      0|        return true
  416|      0|    }
  417|      0|    
  418|      0|    public func textFieldDidEndEditing(_ textField: UITextField) {
  419|      0|        if let description = textField.text, description.count > 0 {
  420|      0|            switch self.taskState.currentState {
  421|      0|            case is SaveState:
  422|      0|                if let projectCD = project?.projectCD{
  423|      0|                    projectBO.addTask(description: description, projectCD: projectCD, completion: { result in
  424|      0|                        
  425|      0|                        switch result {
  426|       |                            
  427|       |                        case .success():
  428|       |                            loadTasks()
  429|       |                            taskState.enter(NormalState.self)
  430|       |                        case .failure(let error):
  431|       |                            print(error)
  432|       |                            taskState.enter(NormalState.self)
  433|       |                        }
  434|       |                    })
  435|       |                }
  436|       |            case is UpdateState:
  437|       |                var actuallyTask = tasks[textField.tag]
  438|       |                actuallyTask.description = description
  439|       |                
  440|       |                taskBO.update(task: actuallyTask, completion: {result in
  441|       |                    switch result {
  442|       |                        
  443|       |                    case .success():
  444|       |                        loadTasks()
  445|       |                        taskState.enter(NormalState.self)
  446|       |                    case .failure(let error):
  447|       |                        print(error.localizedDescription)
  448|       |                        taskState.enter(NormalState.self)
  449|       |                    }
  450|       |                })
  451|       |            default:
  452|       |                break;
  453|       |            }
  454|       |        }
  455|       |    }
  456|       |}
  457|       |
  458|       |
  459|       |extension TimerViewController: TaskBtnDelegate {
  460|       |    func changeBtnState(isSelected: Bool, index: Int) {
  461|       |        var task = self.tasks[index]
  462|       |        task.state = isSelected
  463|       |        
  464|       |        taskBO.update(task: task, completion: { result in
  465|       |            switch result {
  466|       |                
  467|       |            case .success():
  468|       |                loadTasks()
  469|       |            case .failure(let error):
  470|       |                print(error.localizedDescription)
  471|       |            }
  472|       |        })
  473|       |    }
  474|       |    
  475|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/DAO/CDManager.swift:
    1|       |//
    2|       |//  CDManager.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 27/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import CoreData
   10|       |
   11|       |class CDManager {
   12|       |    
   13|       |    // MARK:- Singleton
   14|       |    static var shared = CDManager()
   15|       |//    var viewContext: NSManagedObjectContext {
   16|      0|//        let viewContext = persistentContainer.viewContext
   17|       |//        viewContext.automaticallyMergesChangesFromParent = true
   18|       |//        return viewContext
   19|       |//    }
   20|      0|    
   21|      0|    private init() { }
   22|      0|    
   23|      0|    // MARK: - Core Data stack
   24|      0|
   25|      0|    lazy var persistentContainer: NSPersistentCloudKitContainer = {
   26|      0|        /*
   27|      0|         The persistent container for the application. This implementation
   28|      0|         creates and returns a container, having loaded the store for the
   29|      0|         application to it. This property is optional since there are legitimate
   30|      0|         error conditions that could cause the creation of the store to fail.
   31|      0|        */
   32|      0|        let container = NSPersistentCloudKitContainer(name: "MiniChallengeIV")
   33|      0|        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
   34|      0|            if let error = error as NSError? {
   35|      0|                // Replace this implementation with code to handle the error appropriately.
   36|      0|                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
   37|      0|                 
   38|      0|                /*
   39|      0|                 Typical reasons for an error here include:
   40|      0|                 * The parent directory does not exist, cannot be created, or disallows writing.
   41|      0|                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
   42|      0|                 * The device is out of space.
   43|      0|                 * The store could not be migrated to the current model version.
   44|      0|                 Check the error message to determine what the actual problem was.
   45|      0|                 */
   46|       |                fatalError("Unresolved error \(error), \(error.userInfo)")
   47|       |            }
   48|       |        })
   49|      0|        
   50|      0|        container.viewContext.automaticallyMergesChangesFromParent = true
   51|      0|        return container
   52|      0|    }()
   53|      0|
   54|      0|    // MARK: - Core Data Saving support
   55|      0|
   56|      0|    func saveContext () {
   57|      0|        let context = persistentContainer.viewContext
   58|      0|        if context.hasChanges {
   59|      0|            do {
   60|      0|                try context.save()
   61|      0|            } catch {
   62|       |                // Replace this implementation with code to handle the error appropriately.
   63|       |                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
   64|       |                let nserror = error as NSError
   65|       |                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
   66|       |            }
   67|       |        }
   68|       |    }
   69|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/DAO/ProjectDAO.swift:
    1|       |//
    2|       |//  ProjectDAO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 28/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import CoreData
   11|       |import UIKit
   12|       |
   13|       |class ProjectDAO {
   14|      0|    let context = CDManager.shared.persistentContainer.viewContext
   15|       |    
   16|       |    /// Create an object of type Project in CoreData
   17|       |    /// - Parameter project: An project
   18|       |    /// - Returns: Boolean if the project was created in the data base
   19|      0|    func create(project: Project, completion: (Result<Bool, ValidationError>)  -> Void){
   20|      0|        let projectCD = ProjectCD(context: self.context)
   21|      0|        projectCD.name = project.name
   22|      0|        projectCD.id = project.id
   23|      0|        projectCD.time = Int32(project.time)
   24|      0|        
   25|      0|        guard let color = project.color.toHex else {
   26|      0|            return completion(.failure(.errorToCreate("Project")))
   27|      0|        }
   28|      0|        
   29|      0|        projectCD.color = color
   30|      0|        
   31|      0|        do {
   32|      0|            try context.save()
   33|      0|            completion(.success(true))
   34|      0|        }catch{
   35|      0|            completion(.failure(.errorToCreate("Project")))
   36|      0|        }
   37|      0|    }
   38|       |    
   39|       |    /// Performs the search for projects at CoreData
   40|       |    /// - Returns: List of projects
   41|      0|    func retrieve(completion: (Result<[Project], ValidationError>) -> Void){
   42|      0|        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "ProjectCD")
   43|      0|        var projects: [Project] = []
   44|      0|        do {
   45|      0|            let fechedObjects = try context.fetch(fetchRequest)
   46|      0|            guard let projectsCD = fechedObjects as? [NSManagedObject] else {
   47|      0|                return completion(.failure(.errorToRetrieve("Project")))
   48|      0|            }
   49|      0|            
   50|      0|            for project in projectsCD {
   51|      0|                projects.append(convert(project: project))
   52|      0|            }
   53|      0|            completion(.success(projects))
   54|      0|        }catch {
   55|      0|            completion(.failure(.errorToRetrieve("Project")))
   56|      0|        }
   57|      0|    }
   58|       |    
   59|       |    /// Updates a project in the CoreData
   60|       |    /// - Parameter project: Project to update in the CoreData
   61|       |    /// - Returns: Boolean if the project was updated
   62|      0|    func update(project: Project, completion: (Result<Void, ValidationError>) -> Void){
   63|      0|        project.projectCD?.name = project.name
   64|      0|        project.projectCD?.time = Int32(project.time)
   65|      0|        
   66|      0|        guard let color = project.color.toHex else {
   67|      0|            return completion(.failure(.errorToUpdate("Project")))
   68|      0|        }
   69|      0|        
   70|      0|        project.projectCD?.color = color
   71|      0|        
   72|      0|        do {
   73|      0|            try context.save()
   74|      0|            completion(.success(()))
   75|      0|        }catch {
   76|      0|            completion(.failure(.errorToUpdate("Project")))
   77|      0|        }
   78|      0|
   79|      0|    }
   80|       |    
   81|       |    /// Updates a project in the CoreData
   82|       |    /// - Parameter uuid: UUID that identifies the project
   83|       |    /// - Returns: Boolean if the project was deleted
   84|      0|    func delete(uuid: UUID, completion: (Result<Void, ValidationError>) -> Void){
   85|      0|        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "ProjectCD")
   86|      0|        fetchRequest.predicate = NSPredicate(format: "id == %@", uuid.uuidString)
   87|      0|        
   88|      0|        do {
   89|      0|            let objects = try self.context.fetch(fetchRequest)
   90|      0|            
   91|      0|            guard let object = objects as? [NSManagedObject], objects.count > 0 else{
   92|      0|                return completion(.failure(.errorToDelete("Project")))
   93|      0|            }
   94|      0|            
   95|      0|            context.delete(object[0])
   96|      0|            
   97|      0|            try context.save()
   98|      0|            
   99|      0|            completion(.success(()))
  100|      0|        }catch{
  101|      0|            completion(.failure(.errorToDelete("Project")))
  102|      0|        }
  103|      0|
  104|      0|    }
  105|       |    
  106|      0|    func addTask(taskCD: TaskCD, projectCD: ProjectCD, completion: (Result<Void, ValidationError>) -> Void){
  107|      0|
  108|      0|        projectCD.addToTasks(taskCD)
  109|      0|        do {
  110|      0|            try context.save()
  111|      0|            completion(.success(()))
  112|      0|        }catch{
  113|      0|            completion(.failure(.errorToAdd("Task")))
  114|      0|        }
  115|      0|    }
  116|       |    
  117|      0|    func fetch(id: UUID, completion: (Result<Project, ValidationError>) -> Void ){
  118|      0|        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "ProjectCD")
  119|      0|        fetchRequest.predicate = NSPredicate(format: "id == %@", id.uuidString)
  120|      0|        
  121|      0|        do {
  122|      0|            let objects = try self.context.fetch(fetchRequest)
  123|      0|            
  124|      0|            guard let object = objects as? [NSManagedObject], objects.count > 0 else{
  125|      0|                return completion(.failure(.errorToFetch("Project")))
  126|      0|            }
  127|      0|            
  128|      0|            let project = convert(project: object[0])
  129|      0|            
  130|      0|            completion(.success(project))
  131|      0|        }catch{
  132|      0|            completion(.failure(.errorToFetch("Project")))
  133|      0|        }
  134|      0|    }
  135|       |    
  136|      0|    func convert(project: NSManagedObject) -> Project{
  137|      0|        let uuid = project.value(forKey: "id") as! UUID
  138|      0|        let name = project.value(forKey: "name") as! String
  139|      0|        let time = project.value(forKey: "time") as! Int64
  140|      0|        let color = project.value(forKey: "color") as! String
  141|      0|        let tasksCD = project.value(forKey: "tasks") as! NSSet
  142|      0|        
  143|      0|        var tasks: [Task] = []
  144|      0|        for task in tasksCD.allObjects{
  145|      0|            tasks.append(convertTask(task: task as! NSManagedObject))
  146|      0|        }
  147|      0|
  148|      0|        let project = Project(id: uuid, name: name, color: UIColor(hex: color)! , time: Int(time), projectCD: project as? ProjectCD, tasks: tasks)
  149|      0|        return project
  150|      0|    }
  151|       |    
  152|      0|    func convertTask(task: NSManagedObject) -> Task{
  153|      0|        let uuid = task.value(forKey: "id") as! UUID
  154|      0|        let description = task.value(forKey: "descriptionTask") as! String
  155|      0|        let state = task.value(forKey: "state") as! Bool
  156|      0|        let date = task.value(forKey: "createdAt") as! Date
  157|      0|
  158|      0|        
  159|      0|        let task = Task(id: uuid, description: description, state: state, taskCD: task as? TaskCD, createdAt: date)
  160|      0|        return task
  161|      0|    }
  162|       |    
  163|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/DAO/StatisticDAO.swift:
    1|       |//
    2|       |//  StatisticsDAO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Caio Azevedo on 28/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import CoreData
   11|       |
   12|       |class StatisticDAO {
   13|       |    
   14|      0|    let context = CDManager.shared.persistentContainer.viewContext
   15|       |    //var database
   16|       |    
   17|       |//MARK:- Initializer
   18|      0|    init() {}
   19|       |    
   20|       |//MARK:- Functions
   21|       |    ///Database communication
   22|       |    
   23|       |    /// Description: function conform and create statistics in the database
   24|       |    /// - Parameter statistics: the model of statistic to save
   25|      0|    func createStatistic(statistics: Statistic, completion: (Result<Bool, ValidationError>) -> Void){
   26|      0|        let statisticCD = StatisticCD(context: self.context)
   27|      0|        statisticCD.id = statistics.id
   28|      0|        statisticCD.focusTime = Int32(statistics.focusTime)
   29|      0|        statisticCD.lostFocusTime = Int32(statistics.lostFocusTime)
   30|      0|        statisticCD.qtdLostFocus = Int32(statistics.qtdLostFocus)
   31|      0|        statisticCD.restTime = Int32(statistics.restTime)
   32|      0|        statisticCD.year = Int32(statistics.year)
   33|      0|        statisticCD.month = Int32(statistics.month)
   34|      0|
   35|      0|        
   36|      0|        do {
   37|      0|            try context.save()
   38|      0|            completion(.success(true))
   39|      0|        }catch{
   40|      0|            completion(.failure(.errorToCreate("Statistic")))
   41|      0|        }
   42|      0|    }
   43|       |    
   44|       |    /// Description: function conform and update statistics in the database
   45|       |    /// - Parameter statistics: the model of statistic to update
   46|      0|    func updateStatistic(statistics: Statistic, completion: (Result<Void, ValidationError>) -> Void){
   47|      0|        guard let staticCD = statistics.statisticCD else {
   48|      0|            return completion(.failure(.errorToUpdate("Statistic")))
   49|      0|        }
   50|      0|        staticCD.focusTime = Int32(statistics.focusTime)
   51|      0|        staticCD.lostFocusTime = Int32(statistics.lostFocusTime)
   52|      0|        staticCD.qtdLostFocus = Int32(statistics.qtdLostFocus)
   53|      0|        staticCD.restTime = Int32(statistics.restTime)
   54|      0|        staticCD.year = Int32(statistics.year)
   55|      0|        staticCD.month = Int32(statistics.month)
   56|      0|        
   57|      0|        do {
   58|      0|            try context.save()
   59|      0|            completion(.success(()))
   60|      0|        }catch{
   61|      0|            completion(.failure(.errorToUpdate("Statistic")))
   62|      0|        }
   63|      0|    }
   64|       |    
   65|       |    /// Description: function fetch statistic to return
   66|      0|    func retrieveStatistic(completion: (Result<[Statistic]?, ValidationError>) -> Void){
   67|      0|        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "StatisticCD")
   68|      0|        var statistics: [Statistic] = []
   69|      0|        do {
   70|      0|            let fechedObjects = try context.fetch(fetchRequest)
   71|      0|            
   72|      0|            guard let statisticCD = fechedObjects as? [NSManagedObject] else {
   73|      0|                return completion(.failure(.errorToRetrieve("Statistic")))
   74|      0|            }
   75|      0|            
   76|      0|            for statistic in statisticCD {
   77|      0|                statistics.append(convert(statistic: statistic))
   78|      0|            }
   79|      0|            completion(.success(statistics))
   80|      0|            }catch {
   81|      0|                completion(.failure(.errorToRetrieve("Statistic")))
   82|      0|            }
   83|      0|    }
   84|       |    
   85|       |    /// Description: Function to retrieve the Statistics per month and year
   86|       |    /// - Parameters:
   87|       |    ///   - month: search month
   88|       |    ///   - year: search yaer
   89|       |    ///   - completion: return the Statistic or a validation Error
   90|      0|    func retrieveStatisticPerMonth(month: Int32, year: Int32, completion: (Result<Statistic?, ValidationError>) -> Void){
   91|      0|        /// Create predicates
   92|      0|        let predicateMonth = NSPredicate(format: "month == %@", String(month))
   93|      0|        let predicateYear = NSPredicate(format: "year == %@", String(year))
   94|      0|        let predicateArray = NSCompoundPredicate(type: .and, subpredicates: [predicateMonth, predicateYear])
   95|      0|        
   96|      0|        /// Create fetchRequest with predicate
   97|      0|        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "StatisticCD")
   98|      0|        fetchRequest.predicate = predicateArray
   99|      0|        do {
  100|      0|            let fechedObjects = try context.fetch(fetchRequest)
  101|      0|            
  102|      0|            guard let statisticCD = fechedObjects as? [NSManagedObject] else {
  103|      0|                return completion(.failure(.errorToRetrieve("Statistic")))
  104|      0|            }
  105|      0|            
  106|      0|            completion(.success(convert(statistic: statisticCD[0])))
  107|      0|            }catch {
  108|      0|                completion(.failure(.errorToRetrieve("Statistic")))
  109|      0|            }
  110|      0|    }
  111|       |    
  112|      0|    func convert(statistic: NSManagedObject) -> Statistic{
  113|      0|        let id = statistic.value(forKey: "id") as! UUID
  114|      0|        let focusTime = statistic.value(forKey: "focusTime") as! Int
  115|      0|        let lostFocusTime = statistic.value(forKey: "lostFocusTime") as! Int
  116|      0|        let qtdLostFocus = statistic.value(forKey: "qtdLostFocus") as! Int
  117|      0|        let restTime = statistic.value(forKey: "restTime") as! Int
  118|      0|        let year = statistic.value(forKey: "year") as! Int
  119|      0|        let month = statistic.value(forKey: "month") as! Int
  120|      0|
  121|      0|        
  122|      0|        let statistic = Statistic(id: id, focusTime: focusTime, lostFocusTime: lostFocusTime, restTime: restTime, qtdLostFocus: qtdLostFocus, year: year, month: month, statisticCD: statistic as? StatisticCD)
  123|      0|        return statistic
  124|      0|    }
  125|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/DAO/TaskDAO.swift:
    1|       |//
    2|       |//  TaskDAO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Carlos Fontes on 30/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import CoreData
   11|       |
   12|       |class TaskDAO {
   13|       |    
   14|      0|    let context = CDManager.shared.persistentContainer.viewContext
   15|       |
   16|       |    //MARK:- Functions
   17|       |    
   18|       |    /// Create a task on CoreData
   19|       |    /// - Parameter task: A object of type Task
   20|       |    /// - Returns: Boolean if the project was saved
   21|      0|    func createTask(task: Task, completion: (Result<TaskCD, ValidationError>) -> Void){
   22|      0|        
   23|      0|        let taskCD = TaskCD(context: self.context)
   24|      0|        taskCD.descriptionTask = task.description
   25|      0|        taskCD.id = task.id
   26|      0|        taskCD.state = false
   27|      0|        taskCD.createdAt = Date()
   28|      0|        
   29|      0|        do {
   30|      0|            try context.save()
   31|      0|            completion(.success(taskCD))
   32|      0|        }catch {
   33|      0|            completion(.failure(.errorToCreate("Task")))
   34|      0|        }
   35|      0|    }
   36|       |    
   37|       |    /// Retrieves a list of tasks
   38|       |    /// - Returns:  List of tasks
   39|      0|    func retrieve(id: UUID,completion: (Result<[Task], ValidationError>) -> Void){
   40|      0|        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "TaskCD")
   41|      0|        fetchRequest.predicate = NSPredicate(format: "owner.id == %@", id.uuidString)
   42|      0|        fetchRequest.sortDescriptors = [NSSortDescriptor(key: "createdAt", ascending: true)]
   43|      0|        
   44|      0|        var tasks: [Task] = []
   45|      0|        do {
   46|      0|            let fechedTasks = try context.fetch(fetchRequest)
   47|      0|            guard let tasksCD = fechedTasks as? [NSManagedObject] else {
   48|      0|                return completion(.failure(.errorToRetrieve("Task")))
   49|      0|            }
   50|      0|            
   51|      0|            for task in tasksCD {
   52|      0|                tasks.append(convert(task: task))
   53|      0|            }
   54|      0|            
   55|      0|
   56|      0|            completion(.success(tasks))
   57|      0|        }catch{
   58|      0|            completion(.failure(.errorToRetrieve("Task")))
   59|      0|        }
   60|      0|    }
   61|       |    
   62|       |    /// Updates a task in database with DAO
   63|       |    /// - Parameter task: Task to update
   64|       |    /// - Returns: Boolean if the project was updated
   65|      0|    func updateTask(task: Task, completion: (Result<Void, ValidationError>) -> Void){
   66|      0|        task.taskCD?.descriptionTask = task.description
   67|      0|        task.taskCD?.state = task.state
   68|      0|        do {
   69|      0|            try context.save()
   70|      0|            completion(.success(()))
   71|      0|        }catch {
   72|      0|            completion(.failure(.errorToUpdate("Task")))
   73|      0|        }
   74|      0|    }
   75|       |    
   76|       |    /// Delete a task in database with DAO
   77|       |    /// - Parameter uuid: UUID that identifies task
   78|       |    /// - Returns: Boolean if the task was deleted
   79|      0|    func deleteTask(uuid: UUID, completion: (Result<Void, ValidationError>) -> Void){
   80|      0|        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "TaskCD")
   81|      0|        fetchRequest.predicate = NSPredicate(format: "id == %@", uuid.uuidString)
   82|      0|        
   83|      0|        do {
   84|      0|            let objects = try self.context.fetch(fetchRequest)
   85|      0|            
   86|      0|            guard let object = objects as? [NSManagedObject], objects.count > 0 else{
   87|      0|                completion(.failure(.errorToDelete("Task")))
   88|      0|                return
   89|      0|            }
   90|      0|            
   91|      0|            context.delete(object[0])
   92|      0|            try context.save()
   93|      0|            
   94|      0|            completion(.success(()))
   95|      0|        }catch{
   96|      0|            completion(.failure(.errorToDelete("Task")))
   97|      0|        }
   98|      0|    }
   99|       |    
  100|      0|    func convert(task: NSManagedObject) -> Task{
  101|      0|        let uuid = task.value(forKey: "id") as! UUID
  102|      0|        let description = task.value(forKey: "descriptionTask") as! String
  103|      0|        let state = task.value(forKey: "state") as! Bool
  104|      0|        let date = task.value(forKey: "createdAt") as! Date
  105|      0|
  106|      0|        
  107|      0|        let task = Task(id: uuid, description: description, state: state, taskCD: task as? TaskCD, createdAt: date)
  108|      0|        return task
  109|      0|    }
  110|       |
  111|       |    
  112|       |   
  113|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/CGFloat.swift:
    1|       |//
    2|       |//  CGFloat.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Fábio Maciel de Sousa on 15/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |
   13|       |extension CGFloat {
   14|       |    //change height according to device's size
   15|      0|    public var scaledHeight: CGFloat {
   16|      0|        switch UIScreen.main.bounds.size.height {
   17|      0|        case 480://Iphone 4
   18|      0|            return (self*480)/896
   19|      0|        case 568://SE1
   20|      0|            return (self*568)/896
   21|      0|        case 667://SE2
   22|      0|            return (self*667)/896
   23|      0|        case 736://Iphone 8
   24|      0|            return (self*736)/896
   25|      0|        case 896://Iphone 11
   26|      0|            return self
   27|      0|        default:
   28|      0|            return self
   29|      0|        }
   30|      0|    }
   31|       |    //change width according to device's size
   32|      0|    public var scaledWidth: CGFloat {
   33|      0|        switch UIScreen.main.bounds.size.width {
   34|      0|        case 320://Iphone 4 / SE1
   35|      0|            return (self*320)/414
   36|      0|        case 375://SE2
   37|      0|            return (self*375)/414
   38|      0|        case 414://Iphone 8 / Iphone 11
   39|      0|            return self
   40|      0|        default:
   41|      0|            return self
   42|      0|        }
   43|      0|    }
   44|       |}
   45|       |
   46|       |extension UIView {
   47|       |    // return all subviews from a viewcontroller
   48|      0|    func subviewsRecursive() -> [UIView] {
   49|      0|        return subviews + subviews.flatMap { $0.subviewsRecursive() }
   50|      0|    }
   51|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/Device.swift:
    1|       |//
    2|       |//  Device.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 14/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |enum Model: String {
   12|       |    case
   13|       |    simulator          = "simulator/sandbox",
   14|       |    iPhone4            = "iPhone 4",
   15|       |    iPhone4S           = "iPhone 4S",
   16|       |    iPhone5            = "iPhone 5",
   17|       |    iPhone5S           = "iPhone 5S",
   18|       |    iPhone5C           = "iPhone 5C",
   19|       |    iPhone6            = "iPhone 6",
   20|       |    iPhone6plus        = "iPhone 6 Plus",
   21|       |    iPhone6S           = "iPhone 6S",
   22|       |    iPhone6Splus       = "iPhone 6S Plus",
   23|       |    iPhoneSE           = "iPhone SE",
   24|       |    iPhone7            = "iPhone 7",
   25|       |    iPhone7plus        = "iPhone 7 Plus",
   26|       |    iPhone8            = "iPhone 8",
   27|       |    iPhone8plus        = "iPhone 8 Plus",
   28|       |    iPhoneX            = "iPhone X",
   29|       |    iPhoneXS           = "iPhone XS",
   30|       |    iPhoneXSMax        = "iPhone XS Max",
   31|       |    iPhoneXR           = "iPhone XR",
   32|       |    iPhone11           = "iPhone 11",
   33|       |    iPhone11Pro        = "iPhone 11 Pro",
   34|       |    iPhone11ProMax     = "iPhone 11 Pro Max",
   35|       |    iPhoneSE2          = "iPhone SE 2",
   36|       |    unrecognized       = "?unrecognized?"
   37|       |}
   38|       |
   39|       |enum UIDeviceSize: Int {
   40|       |    case i3_5Inch
   41|       |    case i4Inch
   42|       |    case i4_7Inch
   43|       |    case i5_5Inch
   44|       |    case i5_8Inch
   45|       |    case i6_1Inch
   46|       |    case i6_5Inch
   47|       |    case unknown
   48|       |}
   49|       |
   50|       |struct Device {
   51|       |    // Based iPhone11
   52|       |    static let base: CGFloat = 414
   53|       |    
   54|      0|    static var ratio: CGFloat {
   55|      0|        UIScreen.main.bounds.width / base
   56|      0|    }
   57|       |    
   58|      0|    static var deviceSize: UIDeviceSize = {
   59|      0|        let w: Double = Double(UIScreen.main.bounds.width)
   60|      0|        let h: Double = Double(UIScreen.main.bounds.height)
   61|      0|        let screenHeight: Double = max(w, h)
   62|      0|        
   63|      0|        switch screenHeight {
   64|      0|        case 480:
   65|      0|            return .i3_5Inch
   66|      0|        case 568:
   67|      0|            return .i4Inch
   68|      0|        case 667:
   69|      0|            return UIScreen.main.scale == 3.0 ? .i5_5Inch : .i4_7Inch
   70|      0|        case 736:
   71|      0|            return .i5_5Inch
   72|      0|        case 812:
   73|      0|            return .i5_8Inch
   74|      0|        case 896:
   75|      0|            switch UIDevice().type {
   76|      0|            case .iPhoneXSMax:
   77|      0|                return .i6_5Inch
   78|      0|            case .iPhone11ProMax:
   79|      0|                return .i6_5Inch
   80|      0|            default:
   81|      0|                return .i6_1Inch
   82|      0|            }
   83|      0|        default:
   84|      0|            return .unknown
   85|      0|        }
   86|      0|        
   87|      0|    }()
   88|       |}
   89|       |
   90|       |extension UIDevice {
   91|      0|    var type: Model {
   92|      0|        var systemInfo = utsname()
   93|      0|        uname(&systemInfo)
   94|      0|        let modelCode = withUnsafePointer(to: &systemInfo.machine) {
   95|      0|            $0.withMemoryRebound(to: CChar.self, capacity: 1) {
   96|      0|                ptr in String.init(validatingUTF8: ptr)
   97|      0|                
   98|      0|            }
   99|      0|        }
  100|      0|        let modelMap : [ String : Model ] = [
  101|      0|            "i386"      : .simulator,
  102|      0|            "x86_64"    : .simulator,
  103|      0|            //iPhone
  104|      0|            "iPhone3,1" : .iPhone4,
  105|      0|            "iPhone3,2" : .iPhone4,
  106|      0|            "iPhone3,3" : .iPhone4,
  107|      0|            "iPhone4,1" : .iPhone4S,
  108|      0|            "iPhone5,1" : .iPhone5,
  109|      0|            "iPhone5,2" : .iPhone5,
  110|      0|            "iPhone5,3" : .iPhone5C,
  111|      0|            "iPhone5,4" : .iPhone5C,
  112|      0|            "iPhone6,1" : .iPhone5S,
  113|      0|            "iPhone6,2" : .iPhone5S,
  114|      0|            "iPhone7,1" : .iPhone6plus,
  115|      0|            "iPhone7,2" : .iPhone6,
  116|      0|            "iPhone8,1" : .iPhone6S,
  117|      0|            "iPhone8,2" : .iPhone6Splus,
  118|      0|            "iPhone8,4" : .iPhoneSE,
  119|      0|            "iPhone9,1" : .iPhone7,
  120|      0|            "iPhone9,3" : .iPhone7,
  121|      0|            "iPhone9,2" : .iPhone7plus,
  122|      0|            "iPhone9,4" : .iPhone7plus,
  123|      0|            "iPhone10,1" : .iPhone8,
  124|      0|            "iPhone10,4" : .iPhone8,
  125|      0|            "iPhone10,2" : .iPhone8plus,
  126|      0|            "iPhone10,5" : .iPhone8plus,
  127|      0|            "iPhone10,3" : .iPhoneX,
  128|      0|            "iPhone10,6" : .iPhoneX,
  129|      0|            "iPhone11,2" : .iPhoneXS,
  130|      0|            "iPhone11,4" : .iPhoneXSMax,
  131|      0|            "iPhone11,6" : .iPhoneXSMax,
  132|      0|            "iPhone11,8" : .iPhoneXR,
  133|      0|            "iPhone12,1" : .iPhone11,
  134|      0|            "iPhone12,3" : .iPhone11Pro,
  135|      0|            "iPhone12,5" : .iPhone11ProMax,
  136|      0|            "iPhone12,8" : .iPhoneSE2,
  137|      0|        ]
  138|      0|        
  139|      0|        if let model = modelMap[String.init(validatingUTF8: modelCode!)!] {
  140|      0|            if model == .simulator {
  141|      0|                if let simModelCode = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] {
  142|      0|                    if let simModel = modelMap[String.init(validatingUTF8: simModelCode)!] {
  143|      0|                        return simModel
  144|      0|                    }
  145|      0|                }
  146|      0|            }
  147|      0|            return model
  148|      0|        }
  149|      0|        return Model.unrecognized
  150|      0|    }
  151|       |}
  152|       |
  153|       |extension CGFloat {
  154|      0|  var adjusted: CGFloat {
  155|      0|    return self * Device.ratio
  156|      0|  }
  157|       |}
  158|       |
  159|       |extension Double {
  160|      0|  var adjusted: CGFloat {
  161|      0|    return CGFloat(self) * Device.ratio
  162|      0|  }
  163|       |}
  164|       |
  165|       |extension Int {
  166|      0|  var adjusted: CGFloat {
  167|      0|    return CGFloat(self) * Device.ratio
  168|      0|  }
  169|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/NSLayoutConstraint.swift:
    1|       |//
    2|       |//  NSLayoutConstraint.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 14/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |@IBDesignable
   12|       |extension NSLayoutConstraint {
   13|       |    
   14|       |    @IBInspectable
   15|       |    var iPhone4S: CGFloat {
   16|      0|        get { self.constant }
   17|      0|        set {
   18|      0|            if Device.deviceSize == .i3_5Inch {
   19|      0|                self.constant = newValue
   20|      0|            }
   21|      0|        }
   22|       |    }
   23|       |    
   24|       |    @IBInspectable
   25|       |    var iPhoneSE: CGFloat {
   26|      0|        get { self.constant }
   27|      0|        set {
   28|      0|            if Device.deviceSize == .i4Inch {
   29|      0|                self.constant = newValue
   30|      0|            }
   31|      0|        }
   32|       |    }
   33|       |    
   34|       |    @IBInspectable
   35|       |    var iPhone8: CGFloat {
   36|      0|        get { self.constant }
   37|      0|        set {
   38|      0|            if Device.deviceSize == .i4_7Inch {
   39|      0|                self.constant = newValue
   40|      0|            }
   41|      0|        }
   42|       |    }
   43|       |    
   44|       |    @IBInspectable
   45|       |    var iPhone8Plus: CGFloat {
   46|      0|        get { self.constant }
   47|      0|        set {
   48|      0|            if Device.deviceSize == .i5_5Inch {
   49|      0|                self.constant = newValue
   50|      0|            }
   51|      0|        }
   52|       |    }
   53|       |    
   54|       |    @IBInspectable
   55|       |    var iPhone11Pro: CGFloat {
   56|      0|        get { self.constant }
   57|      0|        set {
   58|      0|            if Device.deviceSize == .i5_8Inch {
   59|      0|                self.constant = newValue
   60|      0|            }
   61|      0|        }
   62|       |    }
   63|       |    
   64|       |//    @IBInspectable
   65|       |//    var iPhone11: CGFloat {
   66|       |//        get { self.constant }
   67|       |//        set {
   68|       |//            if Device.deviceSize == .i6_1Inch {
   69|       |//                self.constant = newValue
   70|       |//            }
   71|       |//        }
   72|       |//    }
   73|       |    
   74|       |    @IBInspectable
   75|       |    var iPhone11Max: CGFloat {
   76|      0|        get { self.constant }
   77|      0|        set {
   78|      0|            if Device.deviceSize == .i6_5Inch {
   79|      0|                self.constant = newValue
   80|      0|            }
   81|      0|        }
   82|       |    }
   83|       |    
   84|       |}
   85|       |
   86|       |@IBDesignable
   87|       |extension UIViewController{
   88|       |    @IBInspectable
   89|       |    var adapt: Bool {
   90|      0|        get { return false }
   91|      0|        set {
   92|      0|            if newValue{
   93|      0|                adaptAutoLayout()
   94|      0|            }
   95|      0|        }
   96|       |    }
   97|       |    
   98|       |    //Adapt auto layout according to device
   99|      0|    func adaptAutoLayout(){
  100|      0|        //Get all screen sizes
  101|      0|        let screenElements = self.view.subviewsRecursive()
  102|      0|        let constraints = screenElements.map{$0.constraints}.joined()
  103|      0|        for constraint in constraints {
  104|      0|            if constraint.identifier == "height" {
  105|      0|                constraint.constant = constraint.constant.scaledHeight
  106|      0|            } else if constraint.identifier == "width" {
  107|      0|                constraint.constant = constraint.constant.scaledWidth
  108|      0|            }
  109|      0|        }
  110|      0|        
  111|      0|        //Labels
  112|      0|        guard let labels = screenElements.filter({$0.isKind(of: UILabel.self)}) as? [UILabel] else {return}
  113|      0|        guard let buttons = screenElements.filter({$0.isKind(of: UIButton.self)}) as? [UIButton] else {return}
  114|      0|        
  115|      0|        for label in labels{
  116|      0|            label.font = label.font.withSize(label.font.pointSize.scaledHeight)
  117|      0|        }
  118|      0|        
  119|      0|        for button in buttons{
  120|      0|            button.titleLabel?.font = button.titleLabel?.font.withSize((button.titleLabel?.font.pointSize.scaledHeight)!)
  121|      0|        }
  122|      0|    }
  123|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/UIButton.swift:
    1|       |//
    2|       |//  UIButton.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 12/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |@IBDesignable
   12|       |extension UIButton {
   13|       |    @IBInspectable
   14|       |    var borderWidth: CGFloat {
   15|      0|        get {
   16|      0|            self.layer.borderWidth
   17|      0|        }
   18|      0|        set {
   19|      0|            self.layer.borderWidth = newValue
   20|      0|        }
   21|       |    }
   22|       |    
   23|       |    @IBInspectable
   24|       |    var borderColor: UIColor? {
   25|      0|        get {
   26|      0|            UIColor(cgColor: self.layer.borderColor ?? UIColor().cgColor)
   27|      0|        }
   28|      0|        set {
   29|      0|            self.layer.borderColor = newValue?.cgColor
   30|      0|        }
   31|       |    }
   32|       |    
   33|       |    @IBInspectable
   34|       |    var localizedKey: String? {
   35|      0|        get {
   36|      0|            ""
   37|      0|        }
   38|      0|        set {
   39|      0|            guard let key = newValue else {return}
   40|      0|            let localizedString = NSLocalizedString(key, comment: "")
   41|      0|            setTitle(localizedString, for: .normal)
   42|      0|        }
   43|       |    }
   44|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/UIImageView.swift:
    1|       |//
    2|       |//  UIImageView.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 15/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |@IBDesignable
   12|       |extension UIImageView {
   13|       |    
   14|       |    @IBInspectable
   15|       |    var iPhone8Below: UIImage? {
   16|      0|        get {
   17|      0|            self.image
   18|      0|        }
   19|      0|        set {
   20|      0|            if Device.deviceSize.rawValue <= 3 {
   21|      0|                self.image = newValue
   22|      0|            }
   23|      0|        }
   24|       |    }
   25|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/UILabel.swift:
    1|       |//
    2|       |//  UILabel.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 14/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |@IBDesignable
   12|       |extension UILabel {
   13|       |    @IBInspectable
   14|       |    var adjustedValue: CGFloat {
   15|      0|        get { 0 }
   16|      0|        set {
   17|      0|            self.font = UIFont(name: self.font.fontName, size: newValue.adjusted)
   18|      0|        }
   19|       |    }
   20|       |    
   21|       |    @IBInspectable
   22|       |    var localisedKey: String? {
   23|      0|        get { "" }
   24|      0|        set {
   25|      0|            guard let key = newValue else { return }
   26|      0|            text = NSLocalizedString(key, comment: "")
   27|      0|        }
   28|       |    }
   29|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/UIStoryboard.swift:
    1|       |//
    2|       |//  UIStoryboard.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 29/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |enum StoryboardID: String {
   12|       |    case NewProject, TimerPopUp, Onboarding
   13|       |}
   14|       |
   15|       |enum ViewControllerID: String {
   16|       |    case NewProjectID, NewProjectID2, TimerPopUpID, VC
   17|       |}
   18|       |
   19|       |fileprivate extension UIStoryboard {
   20|      0|    static func load(from storyboard: StoryboardID, identifier: String) -> UIViewController {
   21|      0|        let uiStoryboard = UIStoryboard(name: storyboard.rawValue, bundle: nil)
   22|      0|        return uiStoryboard.instantiateViewController(identifier: identifier)
   23|      0|    }
   24|       |}
   25|       |
   26|       |extension UIStoryboard {
   27|      0|    static func loadView(from: StoryboardID, identifier: ViewControllerID) -> UIViewController {
   28|      0|        return load(from: from, identifier: identifier.rawValue)
   29|      0|    }
   30|       |}
   31|       |
   32|       |
   33|       |//extension UIViewController {
   34|       |//    func hideKeyboardWhenTappedAround() {
   35|       |//        let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(UIViewController.dismissKeyboard))
   36|       |//        tap.cancelsTouchesInView = false
   37|       |//        view.addGestureRecognizer(tap)
   38|       |//    }
   39|       |//
   40|       |//    @objc func dismissKeyboard() {
   41|       |//        print("tap")
   42|       |//        view.endEditing(true)
   43|       |//    }
   44|       |//}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/UITextField.swift:
    1|       |//
    2|       |//  UITextField.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 12/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |@IBDesignable
   12|       |extension UITextField {
   13|       |    @IBInspectable
   14|       |    var borderWidth: CGFloat {
   15|      0|        get {
   16|      0|            self.layer.borderWidth
   17|      0|        }
   18|      0|        set {
   19|      0|            self.layer.borderWidth = newValue
   20|      0|        }
   21|       |    }
   22|       |    
   23|       |    @IBInspectable
   24|       |    var borderColor: UIColor {
   25|      0|        get {
   26|      0|            UIColor(cgColor: self.layer.borderColor ?? UIColor().cgColor)
   27|      0|        }
   28|      0|        set {
   29|      0|            self.layer.borderColor = newValue.cgColor
   30|      0|        }
   31|       |    }
   32|       |    
   33|       |    @IBInspectable
   34|       |    var cornerRadius: CGFloat {
   35|      0|        get {
   36|      0|            self.layer.cornerRadius
   37|      0|        }
   38|      0|        set {
   39|      0|            self.layer.cornerRadius = newValue
   40|      0|        }
   41|       |    }
   42|       |    
   43|       |    @IBInspectable
   44|       |    var leftPadding: CGFloat {
   45|      0|        get {
   46|      0|            self.leftView?.frame.size.width ?? CGFloat()
   47|      0|        }
   48|      0|        set {
   49|      0|            let paddingView = UIView(frame: CGRect(x: 0, y: 0, width: newValue, height: self.frame.size.height))
   50|      0|            self.leftView = paddingView
   51|      0|            self.leftViewMode = .always
   52|      0|        }
   53|       |    }
   54|       |    
   55|       |    @IBInspectable
   56|       |    var rightPadding: CGFloat {
   57|      0|        get {
   58|      0|            self.rightView?.frame.size.width ?? CGFloat()
   59|      0|        }
   60|      0|        set {
   61|      0|            let paddingView = UIView(frame: CGRect(x: 0, y: 0, width: newValue, height: self.frame.size.height))
   62|      0|            self.rightView = paddingView
   63|      0|            self.rightViewMode = .always
   64|      0|        }
   65|       |    }
   66|       |    
   67|       |    @IBInspectable
   68|       |    var localizedKey: String? {
   69|      0|        get {
   70|      0|            ""
   71|      0|        }
   72|      0|        set {
   73|      0|            guard let key = placeholder else {return}
   74|      0|            let localizedString = NSLocalizedString(key, comment: "")
   75|      0|            placeholder = localizedString
   76|      0|        }
   77|       |    }
   78|       |    
   79|      0|    func clearStrikeThrough(){
   80|      0|        if let text = self.text {
   81|      0|           let attributeString: NSMutableAttributedString =  NSMutableAttributedString(string: text)
   82|      0|            attributeString.setAttributes([:], range: NSMakeRange(0, attributeString.length))
   83|      0|            self.attributedText = attributeString
   84|      0|        }
   85|      0|    }
   86|       |    
   87|      0|    func addStrikeThrough(){
   88|      0|        
   89|      0|        if let text = self.text {
   90|      0|            let attributeString: NSMutableAttributedString =  NSMutableAttributedString(string: text)
   91|      0|            attributeString.addAttribute(NSAttributedString.Key.strikethroughStyle, value: 2, range: NSMakeRange(0, attributeString.length))
   92|      0|            self.attributedText = attributeString
   93|      0|        }
   94|      0|    }
   95|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/Extension/UIView.swift:
    1|       |//
    2|       |//  UIView.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Murilo Teixeira on 11/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |@IBDesignable
   12|       |extension UIView {
   13|       |    @IBInspectable
   14|       |    var alphaValue: CGFloat {
   15|      0|        get {
   16|      0|            self.alpha * 100
   17|      0|        }
   18|      0|        set {
   19|      0|            self.alpha = newValue / 100
   20|      0|        }
   21|       |    }
   22|       |    
   23|       |    @IBInspectable
   24|       |    var colorValue: UIColor? {
   25|      0|        get {
   26|      0|            self.backgroundColor
   27|      0|        }
   28|      0|        set {
   29|      0|            self.backgroundColor = newValue
   30|      0|        }
   31|       |    }
   32|       |    
   33|       |    @IBInspectable
   34|       |    var round: CGFloat {
   35|      0|        get {
   36|      0|            self.layer.cornerRadius
   37|      0|        }
   38|      0|        set {
   39|      0|            self.layer.cornerRadius = newValue
   40|      0|        }
   41|       |    }
   42|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/HandleErrors.swift:
    1|       |//
    2|       |//  HandleErrors.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Carlos Fontes on 05/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |enum ValidationError: Error {
   12|       |    case errorToAdd(String)
   13|       |    case errorToCreate(String)
   14|       |    case errorToRetrieve(String)
   15|       |    case errorToUpdate(String)
   16|       |    case errorToDelete(String)
   17|       |    case errorToFetch(String)
   18|       |    
   19|       |    case tooShort(String)
   20|       |}
   21|       |
   22|       |extension ValidationError: LocalizedError {
   23|      0|    var errorDescription: String? {
   24|      0|        switch self {
   25|      0|            
   26|      0|        case .errorToAdd(let object):
   27|      0|            let format = NSLocalizedString("Error to add %@", comment: "")
   28|      0|            return String(format: format, object)
   29|      0|            
   30|      0|        case .errorToCreate(let object):
   31|      0|            let format = NSLocalizedString("Error to create %@", comment: "")
   32|      0|            return String(format: format, object)
   33|      0|            
   34|      0|        case .errorToRetrieve(let object):
   35|      0|            let format = NSLocalizedString("Error to retrieve %@", comment: "")
   36|      0|            return String(format: format, object)
   37|      0|            
   38|      0|        case .errorToUpdate(let object):
   39|      0|            let format = NSLocalizedString("Error to update %@", comment: "")
   40|      0|            return String(format: format, object)
   41|      0|            
   42|      0|        case .errorToDelete(let object):
   43|      0|            let format = NSLocalizedString("Error to delete %@", comment: "")
   44|      0|            return String(format: format, object)
   45|      0|            
   46|      0|        case .errorToFetch(let object):
   47|      0|            let format = NSLocalizedString("Error to fetch %@", comment: "")
   48|      0|            return String(format: format, object)
   49|      0|            
   50|      0|        case .tooShort(let object):
   51|      0|            let format = NSLocalizedString("Your %@ needs to be at least 2 characters long", comment: "")
   52|      0|            return String(format: format, object)
   53|      0|        }
   54|      0|    }
   55|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/State/NormalState.swift:
    1|       |//
    2|       |//  NormalState.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Carlos Fontes on 19/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import GameplayKit
   11|       |
   12|       |class NormalState: GKState {
   13|       |    
   14|       |    
   15|      0|    override func isValidNextState(_ stateClass: AnyClass) -> Bool {
   16|      0|        switch stateClass {
   17|      0|        case is SaveState.Type:
   18|      0|            return true
   19|      0|        
   20|      0|        case is UpdateState.Type:
   21|      0|            return true
   22|      0|        default:
   23|      0|            return false
   24|      0|        }
   25|      0|    }
   26|       |    
   27|      0|    override init() {
   28|      0|    }
   29|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/State/SaveState.swift:
    1|       |//
    2|       |//  SaveState.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Carlos Fontes on 19/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import GameplayKit
   11|       |
   12|       |class SaveState: GKState {
   13|      0|    override func isValidNextState(_ stateClass: AnyClass) -> Bool {
   14|      0|        switch stateClass {
   15|      0|        case is NormalState.Type:
   16|      0|            return true
   17|      0|        default:
   18|      0|            return false
   19|      0|        }
   20|      0|    }
   21|       |    
   22|      0|    override init() {
   23|      0|    }
   24|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Helpers/State/UpdateState.swift:
    1|       |//
    2|       |//  UpdateState.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Carlos Fontes on 19/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import GameplayKit
   11|       |class UpdateState: GKState {
   12|       |    
   13|      0|    override func isValidNextState(_ stateClass: AnyClass) -> Bool {
   14|      0|        switch stateClass {
   15|      0|        case is NormalState.Type:
   16|      0|            return true
   17|      0|        default:
   18|      0|            return false
   19|      0|        }
   20|      0|    }
   21|       |    
   22|      0|    override init() {
   23|      0|    }
   24|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Model/DAO/Color.swift:
    1|       |//
    2|       |//  Color.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Carlos Fontes on 30/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |extension UIColor {
   13|       |    
   14|      0|    convenience init?(hex: String) {
   15|      0|        var hexNormalized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
   16|      0|        hexNormalized = hexNormalized.replacingOccurrences(of: "#", with: "")
   17|      0|
   18|      0|        var rgb: UInt64 = 0
   19|      0|        var r: CGFloat = 0.0
   20|      0|        var g: CGFloat = 0.0
   21|      0|        var b: CGFloat = 0.0
   22|      0|        var a: CGFloat = 1.0
   23|      0|        let length = hexNormalized.count
   24|      0|
   25|      0|        Scanner(string: hexNormalized).scanHexInt64(&rgb)
   26|      0|
   27|      0|        if length == 6 {
   28|      0|            r = CGFloat((rgb & 0xFF0000) >> 16) / 255.0
   29|      0|            g = CGFloat((rgb & 0x00FF00) >> 8) / 255.0
   30|      0|            b = CGFloat(rgb & 0x0000FF) / 255.0
   31|      0|
   32|      0|        } else if length == 8 {
   33|      0|            r = CGFloat((rgb & 0xFF000000) >> 24) / 255.0
   34|      0|            g = CGFloat((rgb & 0x00FF0000) >> 16) / 255.0
   35|      0|            b = CGFloat((rgb & 0x0000FF00) >> 8) / 255.0
   36|      0|            a = CGFloat(rgb & 0x000000FF) / 255.0
   37|      0|
   38|      0|        } else {
   39|      0|            return nil
   40|      0|        }
   41|      0|
   42|      0|        self.init(red: r, green: g, blue: b, alpha: a)
   43|      0|    }
   44|       |    
   45|       |    
   46|      0|    var toHex: String? {
   47|      0|        guard let components = cgColor.components, components.count >= 3 else {
   48|      0|            return nil
   49|      0|        }
   50|      0|
   51|      0|        let r = Float(components[0])
   52|      0|        let g = Float(components[1])
   53|      0|        let b = Float(components[2])
   54|      0|        var a = Float(1.0)
   55|      0|
   56|      0|        if components.count >= 4 {
   57|      0|            a = Float(components[3])
   58|      0|        }
   59|      0|
   60|      0|        let hex = String(format: "%02lX%02lX%02lX%02lX", lroundf(r * 255), lroundf(g * 255), lroundf(b * 255), lroundf(a * 255))
   61|      0|
   62|      0|        return hex
   63|      0|    }
   64|       |    //Convert to RGB value
   65|      0|    convenience init(_ r: CGFloat,_ g: CGFloat,_ b: CGFloat,_ a: CGFloat) {
   66|      0|        self.init(red: r/255, green: g/255, blue: b/255, alpha: a)
   67|      0|    }
   68|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/Model/Statistic.swift:
    1|       |//
    2|       |//  StatisticsBean.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Caio Azevedo on 28/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |/// Representation structure of database entities
   12|       |struct Statistic {
   13|       |    var id: UUID
   14|       |    var focusTime: Int
   15|       |    var lostFocusTime: Int
   16|       |    var restTime: Int
   17|       |    var qtdLostFocus: Int
   18|       |    var year: Int
   19|       |    var month: Int
   20|       |    var statisticCD: StatisticCD? = nil
   21|       |}
   22|       |
   23|       |extension Statistic: Equatable{
   24|       |    ///adding statistics += statistics
   25|      0|    static func += (lhs: inout Statistic, rhs: Statistic){
   26|      0|        lhs.id = rhs.id
   27|      0|        lhs.focusTime += rhs.focusTime
   28|      0|        lhs.restTime += rhs.restTime
   29|      0|        lhs.lostFocusTime += rhs.lostFocusTime
   30|      0|        lhs.qtdLostFocus += rhs.qtdLostFocus
   31|      0|        lhs.month = rhs.month
   32|      0|        lhs.year = rhs.year
   33|      0|        lhs.statisticCD = rhs.statisticCD
   34|      0|    }
   35|       |    ///adding statistics += projects
   36|      0|    static func += (lhs: inout Project, rhs: Statistic){
   37|      0|        lhs.time += rhs.focusTime
   38|      0|        lhs.time += rhs.lostFocusTime
   39|      0|        lhs.time += rhs.restTime
   40|      0|    }
   41|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/View/FlowLayout/CollectionViewFlowLayout.swift:
    1|       |//
    2|       |//  CollectionViewFlowLayout.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Caio Azevedo on 19/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |import UIKit
   12|       |
   13|       |class CollectionViewFlowLayout: UICollectionViewFlowLayout {
   14|       |
   15|      0|    required override init() {
   16|      0|        super.init()
   17|      0|        sectionInsetReference = .fromSafeArea
   18|      0|    }
   19|       |
   20|      0|    required init?(coder aDecoder: NSCoder) {
   21|      0|        fatalError("init(coder:) has not been implemented")
   22|      0|    }
   23|       |
   24|      0|    override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
   25|      0|        let layoutAttributes = super.layoutAttributesForElements(in: rect)!.map { $0.copy() as! UICollectionViewLayoutAttributes }
   26|      0|        guard scrollDirection == .vertical else { return layoutAttributes }
   27|      0|
   28|      0|        // Filter attributes to compute only cell attributes
   29|      0|        let cellAttributes = layoutAttributes.filter({ $0.representedElementCategory == .cell })
   30|      0|
   31|      0|        // Group cell attributes by row (cells with same vertical center) and loop on those groups
   32|      0|        for (_, attributes) in Dictionary(grouping: cellAttributes, by: { ($0.center.y / 10).rounded(.up) * 10 }) {
   33|      0|            // Set the initial left inset
   34|      0|            var leftInset = sectionInset.left
   35|      0|
   36|      0|            // Loop on cells to adjust each cell's origin and prepare leftInset for the next cell
   37|      0|            for attribute in attributes {
   38|      0|                attribute.frame.origin.x = leftInset
   39|      0|                leftInset = attribute.frame.maxX + minimumInteritemSpacing
   40|      0|            }
   41|      0|        }
   42|      0|
   43|      0|        return layoutAttributes
   44|      0|    }
   45|       |
   46|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/View/TableViewCell/TaskTableViewCell.swift:
    1|       |//
    2|       |//  TaskTableViewCell.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Carlos Fontes on 06/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |protocol TaskBtnDelegate {
   13|       |    func changeBtnState(isSelected: Bool, index: Int)
   14|       |}
   15|       |
   16|       |class TaskTableViewCell: UITableViewCell {
   17|       |    @IBOutlet weak var taskTextField: UITextField!
   18|       |    @IBOutlet weak var btnCheck: UIButton!
   19|       |    var delegate: TaskBtnDelegate?
   20|       |    
   21|      0|    @IBAction func checkButtonAction(_ sender: UIButton) {
   22|      0|        if sender.isSelected{
   23|      0|            sender.isSelected = false
   24|      0|            delegate?.changeBtnState(isSelected: false, index: sender.tag)
   25|      0|        }else {
   26|      0|            sender.isSelected = true
   27|      0|            delegate?.changeBtnState(isSelected: true, index: sender.tag)
   28|      0|        }
   29|      0|        
   30|      0|        
   31|      0|    }
   32|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/MiniChallengeIV/View/UIView/AnimatedRingView.swift:
    1|       |//
    2|       |//  AnimatedRingView.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Fábio Maciel de Sousa on 11/05/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |///Class that handles timer's progression bar
   12|       |class AnimatedRingView: UIView {
   13|       |    //MARK: - Atributes
   14|       |    private static let animationDuration = CFTimeInterval(60)
   15|      0|    private let π = CGFloat.pi
   16|      0|    let startAngle = 1.5 * CGFloat.pi
   17|      0|    let circleStrokeWidth = CGFloat(2)
   18|      0|    let ringStrokeWidth = CGFloat(5)
   19|      0|    var proportion = CGFloat(0) {
   20|      0|        didSet {
   21|      0|            setNeedsLayout()
   22|      0|        }
   23|       |    }
   24|       |    var isRunning = false
   25|       |    var totalTime: CGFloat = 0.0
   26|       |    ///Circle path layer
   27|      0|    lazy var circleLayer: CAShapeLayer = {
   28|      0|        let circleLayer = CAShapeLayer()
   29|      0|        circleLayer.strokeColor = UIColor.init(89, 126, 124, 1).cgColor
   30|      0|        circleLayer.fillColor = UIColor.clear.cgColor
   31|      0|        circleLayer.lineWidth = self.circleStrokeWidth
   32|      0|        self.layer.addSublayer(circleLayer)
   33|      0|        return circleLayer
   34|      0|    }()
   35|       |    ///Ring layer that goes through the circle path
   36|      0|    lazy var ringlayer: CAShapeLayer = {
   37|      0|        let ringlayer = CAShapeLayer()
   38|      0|        ringlayer.fillColor = UIColor.clear.cgColor
   39|      0|        ringlayer.strokeColor = UIColor.init(89, 126, 124, 1).cgColor
   40|      0|        ringlayer.lineCap = CAShapeLayerLineCap.round
   41|      0|        ringlayer.lineWidth = self.ringStrokeWidth
   42|      0|        self.layer.addSublayer(ringlayer)
   43|      0|        return ringlayer
   44|      0|    }()
   45|       |    ///Pin layer that follows ring
   46|      0|    lazy var pinlayer: CAShapeLayer = {
   47|      0|        let pinlayer = CAShapeLayer()
   48|      0|        pinlayer.fillColor = UIColor.init(89, 126, 124, 1).cgColor
   49|      0|        self.layer.addSublayer(pinlayer)
   50|      0|        return pinlayer
   51|      0|    }()
   52|       |    ///Circle background
   53|      0|    lazy var circleBackgroundLayer: CAShapeLayer = {
   54|      0|        let circleBackground = CAShapeLayer()
   55|      0|        circleBackground.fillColor = UIColor.init(229, 230, 220, 1).cgColor
   56|      0|        self.layer.addSublayer(circleBackground)
   57|      0|        circleBackground.zPosition =  -100
   58|      0|        return circleBackground
   59|      0|    }()
   60|       |    //MARK: - Methods
   61|       |    /**
   62|       |     Method called when view is loaded. It draws the layers.
   63|       |     */
   64|      0|    override func layoutSubviews() {
   65|      0|        super.layoutSubviews()
   66|      0|//        self.backgroundColor = UIColor.init(244, 244, 240, 1)
   67|      0|        let radius = (min(frame.size.width, frame.size.height) - ringStrokeWidth - 2)/2
   68|      0|        let pinRadius = 7
   69|      0|        let circlebackgroundRadius = (80.55*radius)/90
   70|      0|        let size = self.frame.size
   71|      0|        let pos = CGPoint(x: size.width/2, y: size.height/2)
   72|      0|        let circlePath = UIBezierPath(arcCenter: pos, radius: radius, startAngle: startAngle, endAngle: startAngle + 2 * π, clockwise: true)
   73|      0|        let pinPath = CGPath(ellipseIn: CGRect(x: -pinRadius, y: Int(-radius) - pinRadius, width: 2 * pinRadius, height: 2 * pinRadius), transform: nil)
   74|      0|        let circleBackgroundPath = CGPath(ellipseIn: CGRect(x: -CGFloat(circlebackgroundRadius), y: -CGFloat(circlebackgroundRadius), width: CGFloat(2 * circlebackgroundRadius), height: CGFloat(2 * circlebackgroundRadius)), transform: nil)
   75|      0|        circleLayer.path = circlePath.cgPath
   76|      0|        ringlayer.path = circlePath.cgPath
   77|      0|        ringlayer.strokeEnd = proportion
   78|      0|        pinlayer.position = pos
   79|      0|        pinlayer.path = pinPath
   80|      0|        circleBackgroundLayer.position = pos
   81|      0|        circleBackgroundLayer.path = circleBackgroundPath
   82|      0|    }
   83|       |    /**
   84|       |     Method that starts the progress animation
   85|       |     - Parameter startProportion: point in percentage of where the animation will start in the circle.(0 to 1)
   86|       |     - Parameter startPinPos: angle in which the pin will start in the circle. It ranges from 0 to 360 (pi * 2)
   87|       |     - Parameter endProportion: point in percentage of where the animation will end in the circle.(0 to 1)
   88|       |     - Parameter duratino: The duration in seconds for the animations. It comes with a default value.
   89|       |     */
   90|      0|    func animateRing(From startProportion: CGFloat,FromAngle startPinPos: CGFloat, To endProportion: CGFloat, Duration duration: CFTimeInterval = animationDuration, timing: CAMediaTimingFunctionName? = .linear) {
   91|      0|        self.isRunning = true
   92|      0|        let animation = CABasicAnimation(keyPath: "strokeEnd")
   93|      0|        animation.duration = duration
   94|      0|        animation.fromValue = startProportion
   95|      0|        animation.toValue = endProportion
   96|      0|        animation.timingFunction = CAMediaTimingFunction(name: timing!)
   97|      0|        ringlayer.strokeEnd = 1
   98|      0|        ringlayer.strokeStart = 0
   99|      0|        ringlayer.add(animation, forKey: "animateRing")
  100|      0|        
  101|      0|        let pinAnimation = CABasicAnimation(keyPath: "transform.rotation")
  102|      0|        pinAnimation.fromValue = startPinPos
  103|      0|        pinAnimation.toValue = 2 * CGFloat.pi
  104|      0|        pinAnimation.timingFunction = CAMediaTimingFunction(name: timing!)
  105|      0|        pinAnimation.duration = duration
  106|      0|        pinAnimation.isAdditive = true
  107|      0|        pinlayer.add(pinAnimation, forKey: "animatePin")
  108|      0|    }
  109|       |    /**
  110|       |     Method for removing animation when finished or reseted
  111|       |     */
  112|      0|    func removeAnimation(){
  113|      0|        pinlayer.removeAllAnimations()
  114|      0|        ringlayer.removeAllAnimations()
  115|      0|        proportion = 0
  116|      0|        isRunning = false
  117|      0|    }
  118|       |    /**
  119|       |     Method that calculates the starting point for when app went to background.
  120|       |     - Parameter currTime: current time after coming from background.
  121|       |     - Parameter toValue: Value when circle is filled. It can be endStroke or an angle.
  122|       |     - returns: The new position that the circle should be according to new updated time value coming from background.
  123|       |     */
  124|      0|    func calculateStartingPoint(With currTime: CGFloat, And toValue: CGFloat) -> CGFloat{
  125|      0|        if currTime <= 0 {return toValue}
  126|      0|        let newPos = toValue - ((currTime * toValue) / totalTime)
  127|      0|        return newPos
  128|      0|    }
  129|       |}

/Users/fabioms/Desktop/MiniChallengeIV/MiniChallengeIV/StatisticBO.swift:
    1|       |//
    2|       |//  StatisticsBO.swift
    3|       |//  MiniChallengeIV
    4|       |//
    5|       |//  Created by Caio Azevedo on 28/04/20.
    6|       |//  Copyright © 2020 Murilo Teixeira. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class StatisticBO {
   12|      0|    private var statisticDAO = StatisticDAO()
   13|       |        
   14|       |//MARK:- Initializer
   15|      0|    init() {}
   16|       |    
   17|       |//MARK:- Functions
   18|       |    /// Bisiness Object
   19|       |    
   20|       |    /// Description: function conform and create statistics in the database
   21|       |    /// - Parameter statistics: the model of statistic to save
   22|      0|    func createStatistic(id: UUID, focusTime: Int, lostFocusTime: Int, restTime: Int, qtdLostFocus: Int, year: Int, month: Int, completion: (Result<Bool, ValidationError>) -> Void) {
   23|      0|        
   24|      0|        /// Call cration function of statisticDAO to communicate with database
   25|      0|        let statistic = Statistic(id: id, focusTime: focusTime, lostFocusTime: lostFocusTime, restTime: restTime, qtdLostFocus: qtdLostFocus, year: year, month: month)
   26|      0|        statisticDAO.createStatistic(statistics: statistic, completion: { result in
   27|      0|            switch result {
   28|      0|            case .success(_):
   29|      0|                completion(.success(true))
   30|      0|            case .failure(let error):
   31|      0|                completion(.failure(error))
   32|      0|            }
   33|      0|        })
   34|      0|    }
   35|       |    
   36|       |    /// Description: function conform and update statistics in the database
   37|       |    /// - Parameter statistics: the model of statistic to update
   38|      0|    func updateStatistic(statistics: Statistic, completion: (Result<Void, ValidationError>) -> Void) {
   39|      0|        
   40|      0|        /// Call update function of statisticDAO to communicate with database
   41|      0|        statisticDAO.updateStatistic(statistics: statistics, completion: { result in
   42|      0|            switch result {
   43|      0|            case .success(_):
   44|      0|                completion(.success(()))
   45|      0|            case .failure(let error):
   46|      0|                completion(.failure(error))
   47|      0|            }
   48|      0|        })
   49|      0|    }
   50|       |    
   51|       |    /// Description: function fetch statistic from database
   52|      0|    func retrieveStatistic(completion: (Result<[Statistic]?, ValidationError>) -> Void) {
   53|      0|        
   54|      0|        /// Call cration function of statisticDAO to communicate with database
   55|      0|        statisticDAO.retrieveStatistic(completion: {result in
   56|      0|            switch result {
   57|      0|            case .success(let statistic):
   58|      0|                completion(.success(statistic))
   59|      0|            case .failure(let error):
   60|      0|                completion(.failure(error))
   61|      0|            }
   62|      0|        })
   63|      0|    }
   64|       |    
   65|       |    /// Description: Function to call the retrieve Statistics Dao Function searching by month and year
   66|       |    /// - Parameters:
   67|       |    ///   - month: search month
   68|       |    ///   - year: search yaer
   69|       |    ///   - completion: return the Statistic or a validation Error
   70|      0|    func retrieveStatisticPerMonth(month: Int32, year: Int32, completion: (Result<Statistic?, ValidationError>) -> Void) {
   71|      0|        
   72|      0|        /// Call retrieve function per month of statisticDAO to communicate with database
   73|      0|        statisticDAO.retrieveStatisticPerMonth(month: month, year: year, completion: {result in
   74|      0|            switch result {
   75|      0|            case .success(let statistic):
   76|      0|                completion(.success(statistic))
   77|      0|            case .failure(let error):
   78|      0|                completion(.failure(error))
   79|      0|            }
   80|      0|        })
   81|      0|    }
   82|       |}

/Users/fabioms/Library/Developer/Xcode/DerivedData/MiniChallengeIV-dpdpvvbidhaspvfphtbmxuzjweub/Build/Intermediates.noindex/MiniChallengeIV.build/Debug-iphoneos/MiniChallengeIV.build/DerivedSources/CoreDataGenerated/MiniChallengeIV/ProjectCD+CoreDataProperties.swift:
    1|       |//
    2|       |//  ProjectCD+CoreDataProperties.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Fábio Maciel de Sousa on 20/05/20.
    6|       |//
    7|       |//  This file was automatically generated and should not be edited.
    8|       |//
    9|       |
   10|       |import Foundation
   11|       |import CoreData
   12|       |
   13|       |
   14|       |extension ProjectCD {
   15|       |
   16|      0|    @nonobjc public class func fetchRequest() -> NSFetchRequest<ProjectCD> {
   17|      0|        return NSFetchRequest<ProjectCD>(entityName: "ProjectCD")
   18|      0|    }
   19|       |
   20|       |    @NSManaged public var color: String?
   21|       |    @NSManaged public var id: UUID?
   22|       |    @NSManaged public var name: String?
   23|       |    @NSManaged public var time: Int32
   24|       |    @NSManaged public var tasks: NSSet?
   25|       |
   26|       |}
   27|       |
   28|       |// MARK: Generated accessors for tasks
   29|       |extension ProjectCD {
   30|       |
   31|       |    @objc(addTasksObject:)
   32|       |    @NSManaged public func addToTasks(_ value: TaskCD)
   33|       |
   34|       |    @objc(removeTasksObject:)
   35|       |    @NSManaged public func removeFromTasks(_ value: TaskCD)
   36|       |
   37|       |    @objc(addTasks:)
   38|       |    @NSManaged public func addToTasks(_ values: NSSet)
   39|       |
   40|       |    @objc(removeTasks:)
   41|       |    @NSManaged public func removeFromTasks(_ values: NSSet)
   42|       |
   43|       |}

/Users/fabioms/Library/Developer/Xcode/DerivedData/MiniChallengeIV-dpdpvvbidhaspvfphtbmxuzjweub/Build/Intermediates.noindex/MiniChallengeIV.build/Debug-iphoneos/MiniChallengeIV.build/DerivedSources/CoreDataGenerated/MiniChallengeIV/StatisticCD+CoreDataProperties.swift:
    1|       |//
    2|       |//  StatisticCD+CoreDataProperties.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Fábio Maciel de Sousa on 20/05/20.
    6|       |//
    7|       |//  This file was automatically generated and should not be edited.
    8|       |//
    9|       |
   10|       |import Foundation
   11|       |import CoreData
   12|       |
   13|       |
   14|       |extension StatisticCD {
   15|       |
   16|      0|    @nonobjc public class func fetchRequest() -> NSFetchRequest<StatisticCD> {
   17|      0|        return NSFetchRequest<StatisticCD>(entityName: "StatisticCD")
   18|      0|    }
   19|       |
   20|       |    @NSManaged public var focusTime: Int32
   21|       |    @NSManaged public var id: UUID?
   22|       |    @NSManaged public var lostFocusTime: Int32
   23|       |    @NSManaged public var month: Int32
   24|       |    @NSManaged public var qtdLostFocus: Int32
   25|       |    @NSManaged public var restTime: Int32
   26|       |    @NSManaged public var year: Int32
   27|       |
   28|       |}

/Users/fabioms/Library/Developer/Xcode/DerivedData/MiniChallengeIV-dpdpvvbidhaspvfphtbmxuzjweub/Build/Intermediates.noindex/MiniChallengeIV.build/Debug-iphoneos/MiniChallengeIV.build/DerivedSources/CoreDataGenerated/MiniChallengeIV/TaskCD+CoreDataProperties.swift:
    1|       |//
    2|       |//  TaskCD+CoreDataProperties.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Fábio Maciel de Sousa on 20/05/20.
    6|       |//
    7|       |//  This file was automatically generated and should not be edited.
    8|       |//
    9|       |
   10|       |import Foundation
   11|       |import CoreData
   12|       |
   13|       |
   14|       |extension TaskCD {
   15|       |
   16|      0|    @nonobjc public class func fetchRequest() -> NSFetchRequest<TaskCD> {
   17|      0|        return NSFetchRequest<TaskCD>(entityName: "TaskCD")
   18|      0|    }
   19|       |
   20|       |    @NSManaged public var createdAt: Date?
   21|       |    @NSManaged public var descriptionTask: String?
   22|       |    @NSManaged public var id: UUID?
   23|       |    @NSManaged public var state: Bool
   24|       |    @NSManaged public var owner: ProjectCD?
   25|       |
   26|       |}

